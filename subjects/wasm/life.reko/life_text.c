// life_text.c
// Generated by decompiling life.wasm
// using Reko decompiler version 0.12.2.0.

#include "life.h"

// 000C0000: Stack word32 count_neighbors(Stack word32 arg0, Stack word32 arg1, Stack word32 arg2)
word32 count_neighbors(word32 arg0, word32 arg1, word32 arg2)
{
	return <invalid>;
}

// 000C0060: void update_gen(Stack ui32 arg0)
void update_gen(ui32 arg0)
{
	Eq_n loc1_n = arg0 * 10000 + 0x10;
	byte (* loc2_n)[] = (0x01 - arg0) * 10000 + 0x10;
	word32 arg0_n = ~0x00;
	word32 v17_n;
	do
	{
		v17_n = arg0_n + 0x01;
		ui32 v16_n = v17_n == 100 ? 0x00 : v17_n;
		int32 v16_n = arg0_n + 0x00;
		int32 loc12_n = 0x00;
		int32 v18_n;
		do
		{
			word32 loc13_n = 0x00;
			ui32 v16_n = arg0 * 10000 + 0x10;
			v18_n = loc12_n + 0x01;
			byte v16_n[] = v16_n + (v16_n % 100) * 100;
			int32 v17_n = loc12_n == 99 ? 0x00 : v18_n;
			int32 v18_n = loc12_n + ~0x00;
			byte v17_n[] = v16_n + v16_n * 100;
			loc12_n = v18_n;
			word32 v16_n = (word32) (v16_n[v17_n] + v16_n[v18_n % 100] + v17_n[v18_n % 100] + v17_n[v17_n]);
			switch (v16_n)
			{
			case 0x03:
				loc13_n = 0x01;
				break;
			case 0x02:
				loc13_n = (word32) *((word32) loc1_n + loc12_n);
				break;
			}
			loc2_n[loc12_n] = (byte) loc13_n;
		} while (v18_n != 100);
		loc1_n = (word32) loc1_n + 100;
		loc2_n = (byte (*)[]) (loc2_n + 100);
		arg0_n = v17_n;
	} while (v17_n == 100 == 0x00);
}

// 000C0153: Stack word32 main()
word32 main()
{
	return <invalid>;
}

