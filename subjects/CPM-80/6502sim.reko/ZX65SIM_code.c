// ZX65SIM_code.c
// Generated by decompiling ZX65SIM.COM
// using Reko decompiler version 0.12.2.0.

#include "ZX65SIM.h"

// 0100: void CpmCom_Start(Register byte f)
void CpmCom_Start(byte f)
{
	word16 de_n;
	byte d_n;
	word16 de_n;
	Eq_n de_n;
	word16 iy_n;
	byte d_n;
	byte d_n;
	byte d_n;
	fn0DA2();
	byte * de_n = g_a0A1E;
	word16 bc_n;
	byte * hl_n = SEQ(g_b0002, 0x00);
	byte d_n;
	for (bc_n = 0x2D; bc_n != 0x00; --bc_n)
	{
		*de_n = *hl_n;
		++de_n;
		++hl_n;
		d_n = SLICE(de_n, byte, 8);
	}
	word16 af_n = fn09C5(f, d_n, &g_b0ABC, out d_n);
	fn093B();
	g_w0DA0 = 288;
	fn093B();
	fn0945();
	struct Eq_n * de_n = (struct Eq_n *) <invalid>;
	byte f_n = (byte) af_n;
	byte d_n = SLICE(de_n, byte, 8);
	cu8 a_n = fn0A08(SLICE(af_n, byte, 8));
	struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
	while (a_n != 0x48)
	{
		if (a_n == 0x45)
		{
			word16 af_n = fn09BA(f_n, &g_b0B06);
			Eq_n de_n;
			fn094F(SLICE(af_n, byte, 8), out de_n);
			fn0940();
			word16 af_n = fn09BA((byte) af_n, &g_b0B1D);
			word16 de_n;
			fn094F(SLICE(af_n, byte, 8), out de_n);
			bcu8 b_n = SLICE(de_n, byte, 8);
			uint8 c_n = __rcr<byte,byte>((byte) de_n, 0x01, cond(b_n >> 0x01) & 0x01);
			byte f_n = (byte) af_n;
			byte e_n = 0x04;
			byte a_n = 0x00;
			uint16 bc_n = SEQ(b_n >> 0x01, c_n);
			bc_n = SEQ(b_n >> 0x01, c_n);
			if (c_n >= 0x00)
			{
l0895:
				do
				{
					byte f_n = f_n;
					--e_n;
					uint16 bc_n = bc_n;
					if (e_n == 0x00)
					{
						if (a_n != 0x00)
							bc_n = bc_n + 0x01;
						Eq_n hl_n = de_n;
						Eq_n bc_n = bc_n - 0x01;
						while (true)
						{
							fn093B();
							f_n = fn0923(f_n, hl_n);
							fn0930();
							byte e_n;
							Eq_n hl_n = hl_n;
							for (e_n = 0x10; e_n != 0x00; --e_n)
							{
								word16 af_n;
								word16 hl_n;
								fn0E24(hl_n, out af_n, out hl_n);
								uint8 a_n = <invalid>;
								f_n = (byte) fn0929(SEQ(a_n, f_n));
								fn0933();
								hl_n = hl_n + 0x01;
							}
							fn0930();
							byte e_n;
							for (e_n = 0x10; e_n != 0x00; --e_n)
							{
								word16 af_n;
								word16 hl_n;
								fn0E24(hl_n, out af_n, out hl_n);
								uint8 a_n = <invalid>;
								if (a_n < 0x20 || a_n >= 0x80)
									;
								fn0A19();
								hl_n = hl_n + 0x01;
							}
							if (bc_n == 0x00)
								break;
							--bc_n;
						}
						return;
					}
					bc_n >>= 0x01;
				} while ((byte) bc_n >= 0x00);
			}
			++a_n;
			goto l0895;
		}
		if (a_n == 77)
		{
			word16 af_n = fn09BA(f_n, &g_b0B06);
			Eq_n de_n;
			fn094F(SLICE(af_n, byte, 8), out de_n);
			byte f_n = (byte) af_n;
			Eq_n hl_n = de_n;
l08E3:
			fn093B();
			byte f_n = fn0923(f_n, hl_n);
			fn0930();
			word16 af_n;
			word16 hl_n;
			fn0E24(hl_n, out af_n, out hl_n);
			uint8 a_n = <invalid>;
			word16 af_n = fn0929(SEQ(a_n, f_n));
			fn0930();
			f_n = (byte) af_n;
			cu8 a_n = SLICE(af_n, byte, 8);
			cu8 a_n;
			do
			{
				a_n = fn0A08(a_n);
				if (a_n == 0x2E)
					return;
				if (a_n == 0x20)
				{
l0920:
					hl_n = hl_n + 0x01;
					goto l08E3;
				}
			} while (fn0975(a_n, out a_n));
			ui16 hl_n = 0x00;
			while (true)
			{
				a_n = fn0997(a_n, hl_n, out hl_n);
				cu8 a_n;
				do
				{
					a_n = fn0A08(a_n);
					struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
					if (a_n == 0x0D)
					{
						sp_n->wFFFFFFFE = hl_n;
						hl_n = fn0E2C(sp_n->b0002, sp_n->t0000.u1);
						goto l0920;
					}
				} while (fn0975(a_n, out a_n));
			}
		}
		struct Eq_n * ix_n = &g_t0AB3;
		word16 bc_n;
		byte d_n;
		if (a_n == 66)
		{
			word16 af_n = fn09C5(f_n, d_n, &g_b0B41, out d_n);
			word16 de_n;
			fn094F(SLICE(af_n, byte, 8), out de_n);
			g_w0AB0 = de_n;
			f_n = (byte) af_n;
			bool v29_n;
			do
			{
				byte f_n;
				byte d_n;
				word16 hl_n;
				fn02C5(f_n, ix_n, out f_n, out bc_n, out d_n, out hl_n, out ix_n);
				struct Eq_n * af_n = (struct Eq_n *) <invalid>;
				word16 de_n = g_w0AB0;
				byte h_n = SLICE(hl_n, byte, 8);
				d_n = SLICE(de_n, byte, 8);
				byte l_n = (byte) hl_n;
				f_n = (byte) af_n;
				byte e_n = (byte) de_n;
				v29_n = h_n == d_n;
				if (h_n == d_n)
				{
					v29_n = l_n == e_n;
					if (l_n == e_n)
					{
						byte f_n;
						word16 bc_n;
						byte d_n;
						word16 hl_n;
						struct Eq_n * ix_n;
						fn02C5(f_n, ix_n, out f_n, out bc_n, out d_n, out hl_n, out ix_n);
						struct Eq_n * de_n = (struct Eq_n *) <invalid>;
						struct Eq_n * af_n = (struct Eq_n *) <invalid>;
						byte d_n = SLICE(de_n, byte, 8);
						byte f_n = (byte) af_n;
						byte f_n;
						word16 bc_n;
						byte d_n;
						fn01FF(f_n, (byte) bc_n, d_n, ix_n, out f_n, out bc_n, out d_n);
						return;
					}
				}
				fn0A24();
			} while (v29_n);
			goto l01B7;
		}
		if (a_n == 0x43)
		{
			fn093B();
			byte f_n = fn027A(f_n, d_n, &g_b0B00, out d_n, out iy_n);
			Eq_n de_n;
			de_n.u1 = g_t0ABA.u1;
			word16 af_n;
			byte c_n;
			fn099E(SEQ(SLICE(de_n, byte, 8), f_n), (byte) de_n, out af_n, out c_n);
			fn0945();
			byte f_n = (byte) af_n;
			byte d_n = SLICE(de_n, byte, 8);
			if (!fn094F(SLICE(af_n, byte, 8), out de_n))
				g_t0ABA.u1 = (word16) de_n;
			byte * iy_n = &g_b0AE2;
			byte b_n;
			for (b_n = 0x05; b_n != 0x00; --b_n)
			{
				fn093B();
				byte d_n;
				word16 af_n;
				byte c_n;
				fn09A2(SEQ(ix_n->b0000, fn027A(f_n, d_n, iy_n, out d_n, out iy_n)), out af_n, out c_n);
				fn0945();
				f_n = (byte) af_n;
				byte e_n = (byte) de_n;
				d_n = SLICE(de_n, byte, 8);
				if (!fn094F(SLICE(af_n, byte, 8), out de_n))
					ix_n->b0000 = e_n;
				++ix_n;
			}
			return;
		}
		if (a_n == 0x47)
		{
			Eq_n Z_n;
			do
			{
				struct Eq_n * de_n = (struct Eq_n *) <invalid>;
				struct Eq_n * af_n = (struct Eq_n *) <invalid>;
				byte f_n;
				byte d_n;
				word16 hl_n;
				Z_n = fn02C5(f_n, ix_n, out f_n, out bc_n, out d_n, out hl_n, out ix_n);
				fn0A24();
				d_n = SLICE(de_n, byte, 8);
				f_n = (byte) af_n;
			} while (Z_n);
l01B7:
			fn0A27();
			byte f_n;
			word16 bc_n;
			byte d_n;
			fn01FF(f_n, (byte) bc_n, d_n, ix_n, out f_n, out bc_n, out d_n);
			return;
		}
		if (a_n == 0x54)
		{
			word16 af_n = fn09C5(f_n, d_n, &g_b0B30, out d_n);
			f_n = (byte) af_n;
			byte a_n = (byte) de_n;
			if (!fn094F(SLICE(af_n, byte, 8), out de_n))
			{
l016A:
				a_n = 0x01;
			}
			while (true)
			{
				g_b0AAC = a_n;
				byte f_n;
				word16 bc_n;
				byte d_n;
				word16 hl_n;
				fn02C5(f_n, ix_n, out f_n, out bc_n, out d_n, out hl_n, out ix_n);
				struct Eq_n * de_n = (struct Eq_n *) <invalid>;
				struct Eq_n * af_n = (struct Eq_n *) <invalid>;
				byte f_n;
				word16 bc_n;
				byte d_n;
				fn01FF((byte) af_n, (byte) bc_n, SLICE(de_n, byte, 8), ix_n, out f_n, out bc_n, out d_n);
				struct Eq_n * af_n = (struct Eq_n *) <invalid>;
				byte f_n = (byte) af_n;
				byte a_n = g_b0AAC;
				if (a_n == 0x01)
					break;
				Eq_n bc_n;
				bc_n.u1 = 0x0AAE;
				do
					--bc_n;
				while (bc_n != 0x00);
				a_n = a_n - 0x01;
				f_n = f_n;
			}
			return;
		}
		if (a_n == 0x20)
			goto l016A;
		fn0A2A();
		fn093B();
		fn0945();
		a_n = fn0A08(a_n);
		sp_n = (struct Eq_n *) <invalid>;
	}
	fn093B();
	byte * hl_n = (byte *) &g_t0A4B;
	Eq_n bc_n;
	bc_n.u0 = 0x28;
	while (bc_n != 0x00)
	{
		byte * hl_n = hl_n + 1;
		byte e_n = *hl_n;
		byte d_n = *hl_n;
		struct Eq_n * sp_n = sp_n - 0x02;
		sp_n->ptr0000 = hl_n + 1;
		sp_n->tFFFFFFFE.u0 = (cui16) bc_n;
		word16 af_n;
		byte c_n;
		fn099E(SEQ(d_n, f_n), e_n, out af_n, out c_n);
		fn0A19();
		Eq_n bc_n;
		bc_n.u0 = sp_n->tFFFFFFFE.u0;
		sp_n->tFFFFFFFE.u0 = (cui16) bc_n;
		f_n = (byte) af_n;
		if ((byte) bc_n == ~0x06)
			fn093B();
		Eq_n bc_n;
		bc_n.u0 = sp_n->tFFFFFFFE.u0;
		hl_n = sp_n->ptr0000;
		bc_n = SEQ(SLICE(bc_n - 0x01, byte, 8), (byte) bc_n - 0x01);
	}
	fn093B();
}

// 01FF: FlagGroup bool fn01FF(Register byte f, Register byte b, Register byte d, Register (ptr16 Eq_n) ix, Register out uint8 fOut, Register out word16 bcOut, Register out uint8 dOut)
// Called from:
//      CpmCom_Start
//      fn02C5
bool fn01FF(byte f, byte b, byte d, struct Eq_n * ix, uint8 & fOut, word16 & bcOut, uint8 & dOut)
{
	byte c_n;
	word16 af_n;
	word16 iy_n;
	byte d_n;
	byte d_n;
	word16 bc;
	byte * iy_n;
	byte d_n;
	byte * iy_n;
	byte d_n;
	fn093B();
	byte f_n = fn027A(f, d, &g_b0AD6, out d_n, out iy_n);
	Eq_n de_n;
	de_n.u1 = g_t0AB8.u1;
	byte d_n = SLICE(de_n, byte, 8);
	word16 af_n;
	byte c_n;
	fn099E(SEQ(d_n, f_n), (byte) de_n, out af_n, out c_n);
	byte f_n = fn027A((byte) af_n, d_n, iy_n, out d_n, out iy_n);
	byte c_n = 0x03;
	byte c_n;
	do
	{
		byte b_n;
		for (b_n = 0x05; b_n != 0x00; --b_n)
			;
		fn0A19();
		c_n = c_n - 0x01;
		c_n = c_n;
	} while (c_n != 0x01);
	struct Eq_n * de_n = (struct Eq_n *) <invalid>;
	byte d_n = SLICE(de_n, byte, 8);
	byte f_n = fn027F(f_n, 0x00, (uint16) (SLICE(bc, byte, 8) << 0x03) + 0x0C72, out d_n);
	byte * iy_n = iy_n;
	byte b_n;
	for (b_n = 0x05; b_n != 0x00; --b_n)
	{
		byte d_n;
		word16 af_n;
		byte c_n;
		fn09A2(SEQ(ix->b0000, fn027A(f_n, d_n, iy_n, out d_n, out iy_n)), out af_n, out c_n);
		struct Eq_n * de_n = (struct Eq_n *) <invalid>;
		d_n = SLICE(de_n, byte, 8);
		f_n = (byte) af_n;
		++ix;
	}
	byte f_n = fn027A(f_n, d_n, iy_n, out d_n, out iy_n);
	Eq_n de_n;
	de_n.u1 = g_t0ABA.u1;
	Eq_n Z_n = fn099E(SEQ(SLICE(de_n, byte, 8), f_n), (byte) de_n, out af_n, out c_n);
	fOut = <invalid>;
	bcOut = SEQ(b_n, c_n);
	dOut = <invalid>;
	return Z_n != 0x00;
}

// 027A: Register byte fn027A(Register byte f, Register byte d, Register (ptr16 byte) iy, Register out uint8 dOut, Register out word16 iyOut)
// Called from:
//      CpmCom_Start
//      fn01FF
byte fn027A(byte f, byte d, byte * iy, uint8 & dOut, word16 & iyOut)
{
	word16 iy_n;
	byte d_n;
	word16 af_n = fn09C7(f, 0x06, iy, out d_n, out iy_n);
	dOut = <invalid>;
	iyOut = iy_n;
	return (byte) af_n;
}

// 027F: Register byte fn027F(Register byte f, Register byte d, Register (ptr16 byte) iy, Register out uint8 dOut)
// Called from:
//      fn01FF
byte fn027F(byte f, byte d, byte * iy, uint8 & dOut)
{
	word16 iy_n;
	byte d_n;
	word16 af_n = fn09C7(f, 0x08, iy, out d_n, out iy_n);
	dOut = <invalid>;
	return (byte) af_n;
}

// 0284: Register byte fn0284(Register Eq_n hl, Register out uint8 dOut)
// Called from:
//      fn02C5
byte fn0284(Eq_n hl, uint8 & dOut)
{
	byte * hl_n = &g_b0A98;
	byte * de_n = &g_b0A9A;
	word16 bc_n;
	for (bc_n = 0x4E; bc_n != 0x00; --bc_n)
	{
		*de_n = *hl_n;
		--hl_n;
		--de_n;
	}
	g_t0A4B.u1 = (word16) hl;
	dOut = <invalid>;
	return (byte) bc_n;
}

// 02C5: FlagGroup bool fn02C5(Register byte f, Register (ptr16 Eq_n) ix, Register out uint8 fOut, Register out uint16 bcOut, Register out uint8 dOut, Register out Eq_n hlOut, Register out (ptr16 Eq_n) ixOut)
// Called from:
//      CpmCom_Start
bool fn02C5(byte f, struct Eq_n * ix, uint8 & fOut, uint16 & bcOut, uint8 & dOut, union Eq_n & hlOut, struct Eq_n & ixOut)
{
	Eq_n hl_n;
	Eq_n de_n;
	Eq_n hl_n;
	byte d_n;
	uint16 bc_n;
	byte f_n;
	byte d_n;
	ptr16 fp;
	ptr16 sp_n = fp;
	fn0E34();
	Eq_n hl_n;
	hl_n.u1 = g_t0ABA.u1;
	byte c_n = fn0284(hl_n, out d_n);
	g_t0AB8.u1 = (word16) hl_n;
	word16 af_n;
	Eq_n hl_n;
	fn0E24(hl_n, out af_n, out hl_n);
	struct Eq_n * de_n = (struct Eq_n *) <invalid>;
	byte d_n = SLICE(de_n, byte, 8);
	uint8 a_n = <invalid>;
	Eq_n Z_n;
	Eq_n hl_n;
	uint16 bc_n;
	if (a_n == 0x00)
	{
		ix[1] = (struct Eq_n) __set(ix[1], 0x04);
		Eq_n hl_n;
		hl_n.u1 = g_t0AAA.u1;
		if (hl_n == 0x00)
		{
			Eq_n Z_n = fn01FF(f, 0x29, d_n, ix, out f_n, out bc_n, out d_n);
			fOut = <invalid>;
			bcOut = bc_n;
			dOut = <invalid>;
			hlOut = hl_n;
			ixOut = ix;
			return Z_n != 0x00;
		}
		word16 de_n = fn0755(ix, out hl_n);
		word16 hl_n = fn0E2C(ix[1], fn0E2C((byte) de_n, fn0E2C(SLICE(de_n, byte, 8), hl_n) - 0x01) - 0x01);
		word16 hl_n;
		fn075C((byte) hl_n - 0x01, ix, out hl_n);
		Z_n = cond(hl_n - 0x01) & 0x40;
		hl_n.u1 = g_t0AAA.u1;
		bc_n = 0x0429;
		goto l0728;
	}
	uint8 c_n;
	word16 iy_n;
	if (!__bit(a_n, 0x00))
	{
		if (a_n == ~0x0E)
		{
			uint16 bc_n = SEQ(a_n, c_n);
			if (!__bit(a_n, 0x04))
			{
				if (a_n != 0x20)
				{
					if (a_n != 0x40)
					{
						if (a_n != 0x60)
							goto l0560;
						byte d_n;
						Z_n = fn0440(ix, out d_n, out hl_n);
						bc_n = 1193;
					}
					else
					{
						word16 hl_n;
						fn0755(ix, out hl_n);
						word16 af_n;
						word16 hl_n;
						fn0E24(hl_n + 0x01, out af_n, out hl_n);
						uint8 a_n = <invalid>;
						ix[1] = (struct Eq_n) a_n;
						byte d_n;
						Z_n = fn0443(hl_n, ix, out d_n, out hl_n);
						bc_n = 1189;
					}
				}
				else
				{
					bui8 e_n = (byte) de_n;
					if (!fn03E9((word16) hl_n.u1 + 1, out de_n, out hl_n))
					{
						byte d_n;
						Z_n = fn03FD(bc_n, e_n, ix, out d_n, out ix);
					}
					else
					{
						word16 de_n = fn0755(ix, out hl_n);
						word16 hl_n = fn0E2C((byte) de_n, fn0E2C(SLICE(de_n, byte, 8), hl_n) - 0x01);
						word16 hl_n;
						fn075C((byte) hl_n - 0x01, ix, out hl_n);
						Z_n = cond(hl_n - 0x01) & 0x40;
						hl_n = de_n;
					}
					bc_n = 0x0273;
				}
l0728:
				g_t0ABA.u1 = (word16) hl_n;
				fOut = <invalid>;
				bcOut = bc_n;
				dOut = <invalid>;
				hlOut = hl_n;
				ixOut = ix;
				return Z_n != 0x00;
			}
			word16 af_n;
			word16 hl_n;
			fn0E24(hl_n, out af_n, out hl_n);
			uint8 a_n = <invalid>;
			uint8 c_n = (a_n >> 0x04) - 0x01;
			struct Eq_n * bc_n = (uint16) c_n;
			hl_n = hl_n + 0x01;
			uint8 a_n = (uint8) ix[1];
			uint8 c_n = bc_n->b0B96;
			byte b_n = bc_n->b0B97;
			if (!__bit(c_n, 0x01))
			{
				if ((a_n & b_n) != 0x00)
					goto l039A;
			}
			else if ((a_n & b_n) == 0x00)
				goto l039A;
			word16 af_n;
			word16 hl_n;
			fn0E24(hl_n + 0x01, out af_n, out hl_n);
			uint8 a_n = <invalid>;
			uint16 de_n = (uint16) a_n;
			if (__bit(a_n, 0x07))
				de_n = SEQ(~0x00, a_n);
			hl_n = hl_n + de_n;
l039A:
			bc_n = (uint16) c_n;
			goto l0727;
		}
		uint8 a_n;
		byte c_n;
		uint8 a_n;
		if (a_n == ~0x06)
		{
			a_n = a_n;
			if (__bit(a_n, 0x04))
			{
				if (a_n != 0x98)
				{
					byte SZPC_n = cond(a_n - 0xB8);
					if (a_n == 0xB8)
						a_n = __res(a_n, 0x05);
					uint8 a_n = __rcr<byte,byte>(a_n, 0x01, SZPC_n & 0x01);
					uint8 a_n = __rcr<byte,byte>(a_n, 0x01, cond(a_n));
					uint8 a_n = __rcr<byte,byte>(a_n, 0x01, cond(a_n));
					struct Eq_n * bc_n = (uint16) (__rcr<byte,byte>(a_n, 0x01, cond(a_n)) + 0x0E);
					c_n = bc_n->b0BA6;
					byte a_n = bc_n->b0BA7;
					uint8 a_n;
					if (bc_n == (struct Eq_n *) 62554)
						a_n = ~a_n & ix[1];
					else
						a_n = a_n | ix[1];
					ix[1] = (struct Eq_n) a_n;
l055B:
					bc_n = SEQ(0x04, c_n);
					goto l0727;
				}
				a_n = (uint8) ix[3];
				ix->b0000 = a_n;
				c_n = ~0x22;
l052B:
				fn073E(a_n, ix);
				goto l055B;
			}
			goto l046B;
		}
		if (a_n != ~0x04)
		{
			Eq_n hl_n;
			uint16 bc_n;
			if (a_n != 0x4C)
			{
				if (a_n != 0x6C)
					goto l0560;
				word16 af_n;
				word16 hl_n;
				fn0E24((word16) hl_n.u1 + 1, out af_n, out hl_n);
				word16 af_n;
				word16 hl_n;
				fn0E24(hl_n + 0x01, out af_n, out hl_n);
				uint8 a_n = <invalid>;
				uint8 a_n = <invalid>;
				hl_n = SEQ(a_n, a_n);
				bc_n = 3183;
			}
			else
			{
				hl_n.u1 = (word16) hl_n.u1 + 1;
				bc_n = 0x026F;
			}
			Eq_n de_n;
			word16 hl_n;
			Z_n = fn03E9(hl_n, out de_n, out hl_n);
			bui8 e_n = (byte) de_n;
			Eq_n de_n = de_n;
			if (!Z_n)
			{
				byte d_n;
				fn03FD(bc_n, e_n, ix, out d_n, out ix);
				byte d_n;
				Eq_n hl_n;
				Z_n = fn0440(ix, out d_n, out hl_n);
				de_n = hl_n;
			}
			bc_n = bc_n;
			hl_n = de_n;
			goto l0728;
		}
		a_n = a_n + 0xF0;
		if (__bit(a_n + 0xF0, 0x04))
		{
			if (a_n == 0xA0)
			{
				ix[4] = ix[2];
				bc_n = 1241;
l0727:
				hl_n.u1 = (word16) hl_n.u1 + 1;
				Z_n = cond(hl_n) & 0x40;
				goto l0728;
			}
			a_n = (uint8) ix[4];
			ix[2] = (struct Eq_n) a_n;
			c_n = 0xD1;
			goto l052B;
		}
		if (a_n >= 0x80)
		{
l046B:
			c_n = a_n >> 0x04;
			iy_n = 0x0BB6;
			if (a_n != ~0x06)
				iy_n = 0x0BBE;
l0864:
			<anonymous> ** iy_n = iy_n + (uint16) c_n;
			<anonymous> ** sp_n = sp_n - 0x02;
			<anonymous> * bc_n = (<anonymous> *) *iy_n;
			*sp_n = (<anonymous> **) bc_n;
			<anonymous> * iy_n = (<anonymous> *) *sp_n;
			iy_n();
			fOut = <invalid>;
			uint16 bc_n;
			bcOut = bc_n;
			dOut = <invalid>;
			Eq_n hl_n;
			hlOut = hl_n;
			struct Eq_n * ix_n;
			ixOut = ix_n;
			byte SZPC_n;
			return (SZPC_n & 0x40) != 0x00;
		}
	}
l0560:
	word16 af_n;
	word16 hl_n;
	fn0E24(hl_n, out af_n, out hl_n);
	uint8 a_n = <invalid>;
	c_n = __res(a_n >> 0x04, 0x00);
	sp_n = fp - 0x02;
	iy_n = 0x0BE2;
	if (a_n >> 0x04 < 0x00)
		iy_n = 0x0BF2;
	goto l0864;
}

// 03E9: FlagGroup bool fn03E9(Register Eq_n hl, Register out (ptr16 Eq_n) deOut, Register out (ptr16 Eq_n) hlOut)
// Called from:
//      fn02C5
bool fn03E9(Eq_n hl, struct Eq_n & deOut, struct Eq_n & hlOut)
{
	word16 af_n;
	word16 hl_n;
	fn0E24(hl, out af_n, out hl_n);
	word16 af_n;
	word16 hl_n;
	fn0E24(hl_n + 0x01, out af_n, out hl_n);
	uint8 a_n = <invalid>;
	uint8 a_n = <invalid>;
	byte SZ_n = cond(a_n);
	if (a_n == 0x00)
	{
		byte SZPC_n = cond(0x04 - a_n);
		if (a_n <= 0x04)
		{
			deOut = (struct Eq_n *) <invalid>;
			hlOut = (struct Eq_n *) <invalid>;
			return (cond(0x00) & 0x40) != 0x00;
		}
		else
		{
			deOut = (struct Eq_n *) <invalid>;
			hlOut = (struct Eq_n *) <invalid>;
			return (SZPC_n & 0x40) != 0x00;
		}
	}
	else
	{
		deOut = (struct Eq_n *) <invalid>;
		hlOut = (struct Eq_n *) <invalid>;
		return (SZ_n & 0x40) != 0x00;
	}
}

// 03FD: FlagGroup bool fn03FD(Register uint16 bc, Register bui8 e, Register (ptr16 Eq_n) ix, Register out uint8 dOut, Register out (ptr16 Eq_n) ixOut)
// Called from:
//      fn02C5
bool fn03FD(uint16 bc, bui8 e, struct Eq_n * ix, uint8 & dOut, struct Eq_n & ixOut)
{
	Eq_n de_n;
	de_n.u0 = (uint16) (e * 0x03);
	(*((word16) de_n + 0x0A9B))();
	dOut = <invalid>;
	struct Eq_n * ix_n;
	ixOut = ix_n;
	byte SZPC_n;
	return (SZPC_n & 0x40) != 0x00;
}

// 0440: FlagGroup bool fn0440(Register (ptr16 Eq_n) ix, Register out uint8 dOut, Register out word16 hlOut)
// Called from:
//      fn02C5
bool fn0440(struct Eq_n * ix, uint8 & dOut, word16 & hlOut)
{
	word16 hl_n;
	word16 af_n;
	word16 hl_n;
	fn0755(ix, out hl_n);
	word16 af_n;
	word16 hl_n;
	fn0E24(hl_n + 0x01, out af_n, out hl_n);
	Eq_n Z_n = fn0E24(hl_n + 0x01, out af_n, out hl_n);
	word16 hl_n;
	fn075C((byte) hl_n, ix, out hl_n);
	dOut = <invalid>;
	hlOut = hl_n;
	return Z_n != 0x00;
}

// 0443: FlagGroup bool fn0443(Register word16 hl, Register (ptr16 Eq_n) ix, Register out uint8 dOut, Register out word16 hlOut)
// Called from:
//      fn02C5
bool fn0443(word16 hl, struct Eq_n * ix, uint8 & dOut, word16 & hlOut)
{
	word16 hl_n;
	word16 af_n;
	word16 af_n;
	word16 hl_n;
	fn0E24(hl + 0x01, out af_n, out hl_n);
	Eq_n Z_n = fn0E24(hl_n + 0x01, out af_n, out hl_n);
	word16 hl_n;
	fn075C((byte) hl_n, ix, out hl_n);
	dOut = <invalid>;
	hlOut = hl_n;
	return Z_n != 0x00;
}

// 073E: void fn073E(Register uint8 a, Register (ptr16 Eq_n) ix)
// Called from:
//      fn02C5
void fn073E(uint8 a, struct Eq_n * ix)
{
	ix[1] = (struct Eq_n) __res(ix[1], 0x01);
	if (a == 0x00)
		ix[1] = (struct Eq_n) __set(ix[1], 0x01);
	ix[1] = (struct Eq_n) __res(ix[1], 0x07);
	if (!__bit(a, 0x07))
		return;
	ix[1] = (struct Eq_n) __set(ix[1], 0x07);
}

// 0755: Register word16 fn0755(Register (ptr16 Eq_n) ix, Register out word16 hlOut)
// Called from:
//      fn02C5
//      fn0440
word16 fn0755(struct Eq_n * ix, word16 & hlOut)
{
	hlOut = SEQ(0x01, ix[4]);
	word16 hl;
	return hl;
}

// 075C: Register byte fn075C(Register byte l, Register (ptr16 Eq_n) ix, Register out word16 hlOut)
// Called from:
//      fn02C5
//      fn0440
//      fn0443
byte fn075C(byte l, struct Eq_n * ix, word16 & hlOut)
{
	word16 hl;
	ix[4] = (struct Eq_n) (byte) hl;
	word16 de;
	hlOut = de;
	return SLICE(hl, byte, 8);
}

// 0923: Register byte fn0923(Register byte f, Register Eq_n hl)
// Called from:
//      CpmCom_Start
byte fn0923(byte f, Eq_n hl)
{
	word16 af_n;
	byte c_n;
	fn099E(SEQ(SLICE(hl, byte, 8), f), (byte) hl, out af_n, out c_n);
	return (byte) af_n;
}

// 0929: Register word16 fn0929(Register word16 af)
// Called from:
//      CpmCom_Start
word16 fn0929(word16 af)
{
	word16 af_n;
	byte c_n;
	fn09A2(af, out af_n, out c_n);
	return af_n;
}

// 0930: void fn0930()
// Called from:
//      CpmCom_Start
void fn0930()
{
	fn0933();
	fn0933();
}

// 0933: void fn0933()
// Called from:
//      CpmCom_Start
//      fn0930
void fn0933()
{
	fn0A2A();
}

// 093B: void fn093B()
// Called from:
//      CpmCom_Start
//      fn01FF
void fn093B()
{
	fn0A2A();
	fn0A2A();
}

// 0940: void fn0940()
// Called from:
//      CpmCom_Start
void fn0940()
{
	fn0A2A();
}

// 0945: void fn0945()
// Called from:
//      CpmCom_Start
void fn0945()
{
	fn0A2A();
	fn0A2A();
}

// 094F: FlagGroup bool fn094F(Register cu8 a, Register out ui16 deOut)
// Called from:
//      CpmCom_Start
bool fn094F(cu8 a, ui16 & deOut)
{
	ui16 hl_n;
	cu8 a_n;
	do
	{
		a_n = fn0A08(a);
		byte SZPC_n = cond(a_n - 0x20);
		ui16 de;
		if (a_n == 0x20)
		{
			deOut = de;
			return (SZPC_n & 0x40) != 0x00;
		}
		ui16 hl;
		de = hl;
		hl = 0x00;
	} while (fn0975(a_n, out a));
	cu8 a_n = fn0997(a, 0x00, out hl_n);
	cu8 a_n;
	while (true)
	{
		a_n = fn0A08(a_n);
		if (a_n == 0x0D)
			break;
		if (!fn0975(a_n, out a_n))
			a_n = fn0997(a_n, hl_n, out hl_n);
	}
	deOut = hl_n;
	return (cond(a_n) & 0x40) != 0x00;
}

// 0975: FlagGroup bool fn0975(Register cu8 a, Register out cu8 aOut)
// Called from:
//      CpmCom_Start
//      fn094F
bool fn0975(cu8 a, cu8 & aOut)
{
	if (a < 0x30 || a >= 0x3A && (a < 0x41 || a >= 0x47))
	{
		fn0A2A();
		aOut = 0x00;
		return (cond(0x00) & 0x40) != 0x00;
	}
	else
	{
		cu8 a_n = a - 0x30;
		if (a >= 0x3A)
			a_n = a - 55;
		aOut = a_n;
		return (cond(a_n - ~0x00) & 0x40) != 0x00;
	}
}

// 0997: Register cu8 fn0997(Register cu8 a, Register ui16 hl, Register out word16 hlOut)
// Called from:
//      CpmCom_Start
//      fn094F
cu8 fn0997(cu8 a, ui16 hl, word16 & hlOut)
{
	cu8 a_n = a | (byte) hl * 0x10;
	hlOut = SEQ(SLICE(hl * 0x10, byte, 8), a_n);
	return a_n;
}

// 099E: FlagGroup bool fn099E(Sequence word16 d_f, Register byte e, Register out word16 afOut, Register out byte cOut)
// Called from:
//      CpmCom_Start
//      fn01FF
//      fn0923
bool fn099E(word16 d_f, byte e, word16 & afOut, byte & cOut)
{
	byte c_n;
	word16 af_n;
	byte f_n = fn09A3((byte) d_f);
	Eq_n Z_n = fn09A2(SEQ(e, f_n), out af_n, out c_n);
	afOut = af_n;
	cOut = c_n;
	return Z_n != 0x00;
}

// 09A2: FlagGroup bool fn09A2(Sequence word16 e_f, Register out word16 afOut, Register out byte cOut)
// Called from:
//      CpmCom_Start
//      fn01FF
//      fn0929
//      fn099E
//      fn09C5
bool fn09A2(word16 e_f, word16 & afOut, byte & cOut)
{
	byte c_n;
	byte a_n;
	byte e = SLICE(e_f, byte, 8);
	byte f = (byte) e_f;
	byte a_n;
	byte c_n;
	fn09B0(__ror<byte,byte>(e, 0x04), out a_n, out c_n);
	Eq_n Z_n = fn09B0(e, out a_n, out c_n);
	afOut = SEQ(a_n, f);
	cOut = c_n;
	return Z_n != 0x00;
}

// 09A3: Register byte fn09A3(Register byte a)
// Called from:
//      fn099E
byte fn09A3(byte a)
{
	word16 af;
	byte a_n = SLICE(af, byte, 8);
	byte a_n;
	byte c_n;
	fn09B0(__ror<byte,byte>(a_n, 0x04), out a_n, out c_n);
	byte a_n = SLICE(af, byte, 8);
	byte f_n = (byte) af;
	byte a_n;
	byte c_n;
	fn09B0(a_n, out a_n, out c_n);
	return f_n;
}

// 09B0: FlagGroup bool fn09B0(Register byte a, Register out byte aOut, Register out byte cOut)
// Called from:
//      fn09A2
//      fn09A3
bool fn09B0(byte a, byte & aOut, byte & cOut)
{
	cu8 a_n = __daa(a + ~0x60);
	byte a_n = __daa(a_n + 0x40 + (byte) (a_n < 0x00));
	byte SZPC_n = cond(a_n);
	byte c_n = fn0A19();
	aOut = a_n;
	cOut = c_n;
	return (SZPC_n & 0x40) != 0x00;
}

// 09BA: Register word16 fn09BA(Register byte f, Register (ptr16 byte) de)
// Called from:
//      CpmCom_Start
word16 fn09BA(byte f, byte * de)
{
	byte d_n = SLICE(de, byte, 8);
	byte d_n;
	return fn09C5(f, d_n, de, out d_n);
}

// 09C5: Register word16 fn09C5(Register byte f, Register byte d, Register (ptr16 byte) iy, Register out uint8 dOut)
// Called from:
//      CpmCom_Start
//      fn09BA
word16 fn09C5(byte f, byte d, byte * iy, uint8 & dOut)
{
	word16 iy_n;
	byte d_n;
	word16 af_n = fn09C7(f, 0x00, iy, out d_n, out iy_n);
	dOut = <invalid>;
	return af_n;
}

// 09C7: Register word16 fn09C7(Register byte f, Register byte e, Register (ptr16 byte) iy, Register out uint8 dOut, Register out (ptr16 byte) iyOut)
// Called from:
//      fn027A
//      fn027F
//      fn09C5
word16 fn09C7(byte f, byte e, byte * iy, uint8 & dOut, byte & iyOut)
{
	word16 de;
	word16 af_n;
	byte e_n;
	do
	{
		byte a_n = *iy;
		byte e_n = (byte) de;
		byte d_n = SLICE(de, byte, 8);
		word16 af_n = SEQ(a_n, f);
		if (a_n == 0x5E)
		{
			dOut = <invalid>;
			iyOut = iy;
			return af_n;
		}
		af_n = SEQ(a_n, f);
		if (a_n != 33)
		{
			Eq_n hl_n;
			hl_n.u1 = g_t0AB8.u1;
			word16 af_n;
			if (a_n == 0x32)
			{
				word16 af_n;
				word16 hl_n;
				fn0E24((word16) hl_n.u1 + 2, out af_n, out hl_n);
				uint8 a_n = <invalid>;
				byte c_n;
				fn09A2(SEQ(a_n, f), out af_n, out c_n);
			}
			else if (a_n == 0x31)
			{
				word16 af_n;
				word16 hl_n;
				fn0E24((word16) hl_n.u1 + 1, out af_n, out hl_n);
				uint8 a_n = <invalid>;
				byte c_n;
				fn09A2(SEQ(a_n, f), out af_n, out c_n);
			}
			else
			{
				fn0A2A();
				af_n = SEQ(a_n, f);
			}
			e_n = (byte) de;
			d_n = SLICE(de, byte, 8);
			af_n = af_n;
		}
		e_n = e_n - 0x01;
		f = (byte) af_n;
		++iy;
		de = SEQ(d_n, e_n);
	} while (e_n != 0x00);
	dOut = <invalid>;
	iyOut = iy;
	return af_n;
}

// 0A08: Register cu8 fn0A08(Register cu8 a)
// Called from:
//      CpmCom_Start
//      fn094F
cu8 fn0A08(cu8 a)
{
	fn0A27();
	switch (a)
	{
	case 0x03:
		cpm_warm_boot();
		return a;
	case 0x18:
		fn0A19();
		return 0x23;
	default:
		fn0A19();
		return a;
	}
}

// 0A19: Register byte fn0A19()
// Called from:
//      CpmCom_Start
//      fn01FF
//      fn09B0
//      fn0A08
byte fn0A19()
{
	fn0A2A();
	byte a;
	return a;
}

byte g_a0A1E[] = // 0A1E
	{
	};
// 0A24: void fn0A24()
// Called from:
//      CpmCom_Start
void fn0A24()
{
	cpm_warm_boot();
}

// 0A27: void fn0A27()
// Called from:
//      CpmCom_Start
//      fn0A08
void fn0A27()
{
	cpm_warm_boot();
}

// 0A2A: void fn0A2A()
// Called from:
//      CpmCom_Start
//      fn0933
//      fn093B
//      fn0940
//      fn0945
//      fn0975
//      fn09C5
//      fn0A19
void fn0A2A()
{
	cpm_warm_boot();
}

Eq_n g_t0A4B = // 0A4B
	{
		0x00
	};
byte g_b0A98 = 0x00; // 0A98
byte g_b0A9A = 0x00; // 0A9A
Eq_n g_t0AAA = // 0AAA
	{
		0x00
	};
byte g_b0AAC = 0x01; // 0AAC
word16 g_w0AB0 = 0x00; // 0AB0
Eq_n g_t0AB3 = // 0AB3
	{
		0x00,
		0x00,
		0x00,
		0x00,
		~0x00,
	};
Eq_n g_t0AB8 = // 0AB8
	{
		0x00
	};
Eq_n g_t0ABA = // 0ABA
	{
		0x00
	};
byte g_b0ABC = 0x2A; // 0ABC
byte g_b0AD6 = 0x20; // 0AD6
byte g_b0AE2 = 0x20; // 0AE2
byte g_b0B00 = 0x20; // 0B00
byte g_b0B06 = 0x20; // 0B06
byte g_b0B1D = 0x20; // 0B1D
byte g_b0B30 = 0x20; // 0B30
byte g_b0B41 = 0x20; // 0B41
word16 g_w0DA0 = 0x309B; // 0DA0
// 0DA2: void fn0DA2()
// Called from:
//      CpmCom_Start
void fn0DA2()
{
	if (g_b005D == 0x20)
		return;
	byte * de_n = g_a006D;
	if (g_a006D[0] != 0x20)
	{
		ui16 hl_n = 0x00;
		while (true)
		{
			byte a_n = *de_n;
			++de_n;
			if (a_n == 0x20)
				break;
			ui16 hl_n = hl_n * 0x02;
			hl_n = SEQ(SLICE(hl_n * 0x08, byte, 8), a_n + 0x0F | (byte) hl_n * 0x08);
		}
		g_w0E7A = hl_n;
	}
	if (F_OPEN(&g_t005C) != ~0x00)
	{
		void * de_n = g_w0E78 + g_w0E7A;
		while (true)
		{
			F_DMAOFF(de_n);
			de_n = (void *) ((char *) de_n + 0x0080);
			if (F_READ(&g_t005C) != 0x00)
				break;
			g_b0E75 = 0x01;
		}
		F_DMAOFF(&g_v0080);
		F_CLOSE(&g_t005C);
		if (g_b0E75 != 0x00)
			return;
		BDOS();
	}
	else
		BDOS();
}

// 0E24: FlagGroup bool fn0E24(Register Eq_n hl, Register out (ptr16 Eq_n) afOut, Register out Eq_n hlOut)
// Called from:
//      CpmCom_Start
//      fn02C5
//      fn03E9
//      fn0440
//      fn0443
//      fn09C5
bool fn0E24(Eq_n hl, struct Eq_n & afOut, union Eq_n & hlOut)
{
	word16 hl_n;
	Eq_n Z_n = fn0E35(hl, out hl_n);
	Eq_n hl_n;
	hl_n.u1 = g_t0E76.u1;
	afOut = (struct Eq_n *) <invalid>;
	hlOut = hl_n;
	return Z_n != 0x00;
}

// 0E2C: Register Eq_n fn0E2C(Register uint8 a, Register Eq_n hl)
// Called from:
//      CpmCom_Start
//      fn02C5
Eq_n fn0E2C(uint8 a, Eq_n hl)
{
	uint8 * hl_n;
	fn0E35(hl, out hl_n);
	*hl_n = a;
	return g_t0E76.u1;
}

// 0E34: void fn0E34()
// Called from:
//      fn02C5
void fn0E34()
{
}

// 0E35: FlagGroup bool fn0E35(Register Eq_n hl, Register out word16 hlOut)
// Called from:
//      fn0E24
//      fn0E2C
bool fn0E35(Eq_n hl, word16 & hlOut)
{
	g_t0E76.u1 = (word16) hl;
	word16 hl_n = (word16) hl.u1 + g_w0E78;
	hlOut = hl_n;
	return (cond(hl_n) & 0x40) != 0x00;
}

byte g_b0E75 = 0x00; // 0E75
Eq_n g_t0E76 = // 0E76
	{
		0x00
	};
word16 g_w0E78 = 0x0E7C; // 0E78
ui16 g_w0E7A = 0x1000; // 0E7A
