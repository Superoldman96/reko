// space_text.c
// Generated by decompiling space.sav
// using Reko decompiler version 0.12.2.0.

#include "space.h"

Eq_n t0000 = // 0000
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x03C0,
		0x00,
		0x1DAE,
		0x0200,
		0x00,
		0x00,
		23202,
		0x00,
		0x00,
		0x00,
		0x00,
	};
word16 g_w00A2 = 0x00; // 00A2
char g_b0380 = '?'; // 0380
char g_b0397 = '?'; // 0397
Eq_n g_t03B8 = // 03B8
	{
		0x1C00,
		0xC0,
		0x1C00,
		0xB6,
		0x1066,
	};
Eq_n g_t03BC = // 03BC
	{
		0x1C00,
		0xB6,
		0x1066,
		0x1D81,
		0x02,
	};
// 0468: void fn0468(Register (ptr16 byte) r3)
// Called from:
//      fn0472
void fn0468(byte * r3)
{
	while (true)
	{
		char v5_n = *r3;
		++r3;
		if (v5_n == 0x00)
			break;
		while (TTYOUT(v5_n))
			;
	}
}

// 0472: void fn0472(Register word16 r1, Stack Eq_n wArg10)
void fn0472(word16 r1, Eq_n wArg10)
{
	fn0468(&g_b05E4);
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	Eq_n r0_n = *((word16) r3_n + 0x007C);
	struct Eq_n * r3_n = (struct Eq_n *) *((word16) r3_n + 0x0E);
	if (r3_n != null)
		r0_n.u0 = r3_n->t0002.u0;
	fn0528(r0_n);
	struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
	fn0528(sp_n->t0000.u0);
	fn0468(&g_b05EF);
	ci16 v22_n = *g_ptr5426;
	if (v22_n == 0x00)
	{
		while (TTYOUT('?'))
			;
	}
	else
		fn04FA(v22_n);
	if ((byte) r1 == 0x3D || (byte) r1 == 0x3F)
	{
		fn0468(&g_b0601);
		Eq_n r1_n = wArg10;
		Eq_n C_n;
		C_n.u0 = 0x01;
		Eq_n r0_n;
		r0_n.u0 = 24;
		while (true)
		{
			Eq_n r1_n = __rcl<word16,byte>(r1_n, 0x01, C_n);
			Eq_n r0_n = __rcl<word16,byte>(r0_n, 0x01, (r1_n & 0x8000) != 0x00);
			while (TTYOUT((char) r0_n))
				;
			int32 r0_r1_n = SEQ(0x0086, r1_n);
			cui16 r0_n;
			do
			{
				r0_r1_n <<= 0x01;
				r0_n = SLICE(r0_r1_n, word16, 16);
				r1_n = (word16) r0_r1_n;
				if (r1_n == 0x00)
				{
					while (TTYOUT(')'))
						;
					goto l04F2;
				}
				r0_n = SLICE(r0_r1_n, word16, 16);
				C_n = (r0_n & 0x80) != 0x00;
			} while ((r0_n & 0x80) != 0x00);
		}
	}
	else
	{
l04F2:
		PRINT(&g_b05E1);
	}
}

// 04FA: void fn04FA(Register ci16 r0)
// Called from:
//      fn0472
//      fn04FA
void fn04FA(ci16 r0)
{
	ci16 wLoc02_n = r0;
	word16 r0_n = 0x00;
	ci16 v11_n;
	do
	{
		v11_n = wLoc02_n - 0x0A;
		++r0_n;
		wLoc02_n = v11_n;
	} while (v11_n >= 0x00);
	char bLoc02_n = (byte) v11_n + 0x3A;
	if (r0_n != 0x01)
		fn04FA(r0_n - 0x01);
	while (TTYOUT(bLoc02_n))
		;
}

// 051A: Register Eq_n fn051A(Register Eq_n r0, Register Eq_n r2, Register out Eq_n r3Out)
// Called from:
//      fn0528
Eq_n fn051A(Eq_n r0, Eq_n r2, union Eq_n & r3Out)
{
	Eq_n r3_n;
	Eq_n r0_n;
	r0_n.u0 = 0x00;
	for (r3_n = r0; r2 <= r3_n; r3_n -= r2)
		r0_n = (word16) r0_n + 1;
	r3Out = r3_n;
	return r0_n;
}

// 0528: void fn0528(Register Eq_n r0)
// Called from:
//      fn0472
void fn0528(Eq_n r0)
{
	word16 r3_n;
	Eq_n r3_n;
	Eq_n r0_n = fn051A(fn051A(r0, 0x28, out r3_n), 0x28, out r3_n);
	word16 r3_n = 0x03;
	while (true)
	{
		int16 r0_n = (int16) *((word16) r0_n + 1455);
		while (TTYOUT((char) r0_n))
			;
		--r3_n;
		if (r3_n == 0x00)
			break;
		r0_n = r3_n;
	}
}

// 054C: void fn054C(Register ci16 r0, Register (ptr16 Eq_n) r3)
void fn054C(ci16 r0, struct Eq_n * r3)
{
	r3->b00A0 = (byte) r0;
	r3->b00A1 = r3->b00A2;
	struct Eq_n * r0_n = (struct Eq_n *) ((char *) r3 + (r0 >> 3 & ~0x01));
	ci16 r2_n = r0 & 0x0F;
	Eq_n wLoc02_n;
	wLoc02_n.u0 = 0x00;
	Eq_n C_n;
	C_n.u0 = 0x01;
	Eq_n v18_n;
	do
	{
		v18_n = __rcl<word16,byte>(wLoc02_n, 0x01, C_n);
		wLoc02_n = v18_n;
		C_n = (wLoc02_n & 0x8000) != 0x00;
		--r2_n;
	} while (r2_n > 0x00);
	r0_n->w0096 |= v18_n;
}

Eq_n g_t0592 = // 0592
	{
		0x0300,
		0x057A,
		17727,
		0x7272,
		0x3620,
	};
char g_b05E1 = '\r'; // 05E1
byte g_b05E4 = 0x20; // 05E4
byte g_b05EF = 0x22; // 05EF
byte g_b0601 = 0x20; // 0601
// 0608: void fn0608(Stack (ptr16 code) wArg00, Stack Eq_n wArg02)
void fn0608(<anonymous> * wArg00, Eq_n wArg02)
{
	byte bArg03_n = SLICE(wArg02, byte, 8);
	byte bArg02_n = (byte) wArg02;
	Eq_n r4_n;
	r4_n.u0 = g_t5424.u0;
	*((word16) r4_n + 42) = wArg00;
	Eq_n wArg00_n;
	wArg00_n.u0 = 0x00;
	Eq_n r1_n = wArg02;
	if (wArg02 <= 0x00)
	{
		if (wArg02 == 0x00)
			goto l065C;
		r1_n = -wArg02;
	}
	cui16 r2_n = 0x90;
	Eq_n C_n;
	C_n.u0 = 0x00;
	while (true)
	{
		r1_n = __rcl<word16,byte>(r1_n, 0x01, C_n);
		C_n = (r1_n & 0x8000) != 0x00;
		if ((r1_n & 0x8000) != 0x00)
			break;
		--r2_n;
	}
	Eq_n r1_n = __swab(SEQ(SLICE(r1_n, byte, 8), 0x00) | r2_n);
	cui16 wLoc04;
	wArg00_n = __rcr<word16,byte>(r1_n, 0x01, (wLoc04 << 0x01 & 0x01) != 0x00);
	wArg02 = SEQ(__rcr<byte,byte>(bArg03_n, 0x01, (r1_n & 0x01) != 0x00), bArg02_n);
l065C:
	(*((word16) r4_n + 42))();
}

// 0670: void fn0670(Register Eq_n r5, Stack (ptr16 code) wArg00, Stack cui16 wArg02, Stack Eq_n wArg04, Stack cui16 wArg06, Stack Eq_n wArg08)
// Called from:
//      fn3B42
void fn0670(Eq_n r5, <anonymous> * wArg00, cui16 wArg02, Eq_n wArg04, cui16 wArg06, Eq_n wArg08)
{
	Eq_n r4_n;
	r4_n.u0 = g_t5424.u0;
	*((word16) r4_n + 42) = wArg00;
	cui16 r2_n = wArg06;
	Eq_n r3_n = wArg08;
	ui32 r0_r1_n = SEQ(wArg02, wArg04);
	if (wArg08 == 0x00)
	{
		r3_n = wArg04;
		r2_n = wArg02;
		r0_r1_n = SEQ(wArg06, wArg08);
	}
	ui32 v49_n = r0_r1_n << 0x01;
	Eq_n r1_n = (word16) v49_n;
	Eq_n r0_n = SLICE(v49_n, word16, 16);
	Eq_n r5_n = __rcl<word16,byte>(r5, 0x01, (SLICE(r0_r1_n, word16, 16) & 0x8000) != 0x00);
	word16 r2_n;
	word16 r3_n;
	if (r0_n == 0x00)
	{
l06B2:
		r2_n = 0x00;
		r3_n = 0x00;
		goto l0738;
	}
	Eq_n r2_n = r2_n << 1;
	if (r2_n == 0x00)
		goto l06B2;
	cui16 r5_n = (word16) r5_n + (word16) (r2_n < 0x00);
	wchar_t r4_n = (word16) r2_n + SEQ(SLICE(r0_n, byte, 8), 0x00);
	if (r4_n < 0x00)
	{
		if (r4_n <= 0x00)
		{
			__syscall<word16>(0x898A);
			goto l06B2;
		}
	}
	else
	{
		if (r4_n >= 0x00)
			goto l06B0;
		r4_n &= 0x7F00;
		if ((r4_n & 0x7F00) == 0x00)
		{
l06B0:
			__syscall<word16>(0x898B);
			goto l06B2;
		}
	}
	cui16 r4_n = SEQ(SLICE(r4_n, byte, 8), 0x00);
	Eq_n r4_n = __rcr<word16,byte>(r4_n + 0x7F01, 0x01, (r5_n & 0x01) != 0x00);
	Eq_n r2_n = __rcr<word16,byte>(r2_n, 0x01, (r4_n + 0x7F01 & 0x01) != 0x00);
	cui16 r3_n = __swab(r3_n);
	cu16 r2_n = SEQ(SLICE(__swab(r2_n), byte, 8), 0x00) | r3_n;
	Eq_n r3_n = __rcr<word16,byte>(SEQ(SLICE(r3_n, byte, 8), 0x00), 0x01, (r2_n & 0x01) != 0x00);
	cui16 r1_n = __swab(r1_n);
	uint32 r4_r5_n = SEQ(r2_n >> 0x01, r3_n);
	ui32 r0_r1_n = SEQ(SEQ(SLICE(__swab(r0_n), byte, 8), 0x00) | r1_n, SLICE(r1_n, byte, 8), 0x00);
	uint32 r2_r3_n = SEQ(r2_n >> 0x01, r3_n);
	ui32 v53_n;
	Eq_n r1_n;
	Eq_n r0_n;
	uint32 r2_r3_n;
	while (true)
	{
		v53_n = r0_r1_n << 0x01;
		r1_n = (word16) v53_n;
		r0_n = SLICE(r0_r1_n, word16, 16);
		r4_r5_n >>= 1;
		cui16 NZVC_n = cond(r1_n);
		if (r1_n == 0x00)
			break;
		Eq_n r0_n = __rcl<word16,byte>(r0_n, 0x01, NZVC_n & 0x01);
		r0_r1_n = SEQ(r0_n, r1_n);
		r2_r3_n = r2_r3_n;
		r2_r3_n = r2_r3_n;
		if ((r0_n & 0x8000) != 0x00)
		{
			r2_r3_n = r2_r3_n + r4_r5_n;
			r0_r1_n = SEQ(r0_n, r1_n);
		}
	}
	uint16 r0_n = SLICE(v53_n, word16, 16);
	if ((r0_n & 0x8000) != 0x00)
	{
l0700:
		r2_r3_n += r4_r5_n;
	}
	Eq_n r3_n;
	Eq_n r2_n;
	do
	{
		r3_n = (word16) r2_r3_n;
		r2_n = SLICE(r2_r3_n, word16, 16);
		r4_r5_n >>= 1;
		r0_n <<= 1;
		if (r0_n < 0x00)
			goto l0700;
	} while (r0_n != 0x00);
	Eq_n r4_n = r4_n;
	Eq_n C_n;
	C_n.u0 = 0x00;
	if (r2_n < 0x00)
	{
l0724:
		uint32 r2_r3_n = SEQ((word16) r4_n + __swab(SEQ(SLICE(r2_n, byte, 8), 0x00)), __swab(SEQ(SLICE(__rcl<word16,byte>(r3_n, 0x01, C_n), byte, 8), 0x00) | r2_n)) + (uint32) __rcl<word16,byte>(r1_n, 0x01, (r3_n & 0x80) != 0x00);
		r3_n = (word16) r2_r3_n;
		r2_n = SLICE(r2_r3_n, word16, 16);
l0738:
		(*((word16) r4_n + 42))();
		return;
	}
	r3_n <<= 0x01;
	r2_n = __rcl<word16,byte>(r2_n, 0x01, (r3_n & 0x8000) != 0x00);
	if ((r4_n & 0x7F80) != 0x00)
	{
		r4_n = (r4_n & 0x7F80) - 0x80;
		C_n = cond(r4_n) & 0x01;
		goto l0724;
	}
	goto l06B0;
}

// 0754: void fn0754(Stack (ptr16 code) wArg00, Stack cui16 wArg02, Stack word16 wArg04, Stack cui16 wArg06, Stack word16 wArg08)
void fn0754(<anonymous> * wArg00, cui16 wArg02, word16 wArg04, cui16 wArg06, word16 wArg08)
{
	Eq_n r4_n;
	r4_n.u0 = g_t5424.u0;
	*((word16) r4_n + 42) = wArg00;
	if (wArg02 << 1 == 0x00)
	{
		__syscall<word16>(0x898C);
		goto l080C;
	}
	if (wArg06 << 1 != 0x00)
	{
		word16 r2_n = SEQ(SLICE(wArg06 << 1, byte, 8), 0x00);
		word16 r0_n = SEQ(SLICE(wArg02 << 1, byte, 8), 0x00);
		Eq_n r4_n = wArg06 << 1 & ~r2_n;
		Eq_n r5_n = wArg02 << 1 & ~r0_n;
		wchar_t r2_n = r2_n - r0_n;
		if (r2_n >= 0x00)
		{
			if (r2_n <= 0x00)
			{
				__syscall<word16>(0x898A);
				goto l080A;
			}
l078E:
			Eq_n r4_n = __rcr<word16,byte>(r4_n, 0x01, 0x01);
			Eq_n r5_n = __rcr<word16,byte>(r5_n, 0x01, (r2_n + 0x7F01 & 0x01) != 0x00);
			Eq_n r0_n;
			r0_n.u0 = 0x0100;
			cup16 v34_n = r4_n - r5_n;
			ui32 r4_r3_n;
			if (v34_n > 0x00)
			{
l07AC:
				r4_r3_n = SEQ(r4_n, wArg08) - SEQ(r5_n, wArg04);
				r0_n.u0 = 0x0202;
				goto l07B6;
			}
			else
			{
				r4_r3_n = SEQ(r4_n, wArg08);
				if (v34_n >= 0x00)
				{
					cup16 v36_n = wArg08 - wArg04;
					r4_r3_n = SEQ(r4_n, wArg08);
					if (v36_n >= 0x00)
					{
						if (v36_n == 0x00)
						{
							fn07E6();
							return;
						}
						goto l07AC;
					}
				}
l07B6:
				fn07BA(r4_r3_n, SEQ(r5_n, wArg04), r0_n, 2028, (word16) r4_n + 42);
				return;
			}
		}
		if (r2_n <= 0x00)
			goto l078E;
		__syscall<word16>(0x898B);
	}
l080C:
	fn07E8();
}

// 07BA: void fn07BA(Sequence ui32 r4_r3, Sequence ui32 r5_r1, Register Eq_n r0, Stack word16 wArg00, Stack (ptr16 word16) wArg04)
// Called from:
//      fn0754
void fn07BA(ui32 r4_r3, ui32 r5_r1, Eq_n r0, word16 wArg00, word16 * wArg04)
{
	word16 r5 = SLICE(r5_r1, word16, 16);
	word16 r1 = (word16) r5_r1;
	ui32 r4_r3_n = r4_r3;
	Eq_n r0_n;
	do
	{
		ui32 r4_r3_n = r4_r3_n << 0x01;
		word16 r3_n = (word16) r4_r3_n;
		word16 r4_n = SLICE(r4_r3_n, word16, 16);
		Eq_n C_n;
		if ((SLICE(r4_r3_n, word16, 16) & 0x80) == 0x00)
		{
			cu8 v13_n = (byte) (r5 - r4_n);
			C_n = cond(v13_n) & 0x01;
			if (v13_n > 0x00)
				goto l07CE;
			if (v13_n != 0x00)
				goto l07C6;
			cup16 v17_n = r1 - r3_n;
			C_n = cond(v17_n) & 0x01;
			if (v17_n > 0x00)
				goto l07CE;
			if (v17_n >= 0x00)
			{
				Eq_n C_n;
				C_n.u0 = 0x01;
				Eq_n r0_n;
				do
				{
					r0_n = __rcl<word16,byte>(r0_n, 0x01, C_n);
					C_n = (r0_n & 0x8000) != 0x00;
					r0_n = r0_n;
				} while ((r0_n & 0x8000) == 0x00);
				if (wArg00 == 0x07F6)
				{
					fn07E8();
					return;
				}
				else
				{
					fn07E6();
					return;
				}
			}
		}
l07C6:
		r4_r3_n -= r5_r1;
		C_n.u0 = 0x01;
l07CE:
		r0 = __rcl<word16,byte>(r0_n, 0x01, C_n);
		r4_r3_n = r4_r3_n;
		r0_n = r0;
	} while ((r0_n & 0x8000) == 0x00);
}

// 07E6: void fn07E6()
// Called from:
//      fn0754
//      fn07BA
void fn07E6()
{
	fn07E8();
}

// 07E8: void fn07E8()
// Called from:
//      fn0754
//      fn07BA
void fn07E8()
{
	<anonymous> * v29;
	v29();
}

// 0818: void fn0818(Register (ptr16 word16) r5)
void fn0818(word16 * r5)
{
	fn11A6((char *) r5 + *r5 + *r5 + 2, r5);
	g_ptr53F0();
}

<unknown> g_t0A00 = // 0A00;
// 0A64: void fn0A64(Register (ptr16 word16) r5)
void fn0A64(word16 * r5)
{
	fn11A6((char *) r5 + *r5 + *r5 + 2, r5);
	g_ptr5414();
}

// 0AAE: Register word16 fn0AAE(Register (ptr16 Eq_n) r5, Register out ptr16 r4Out)
// Called from:
//      fn3B42
word16 fn0AAE(struct Eq_n * r5, ptr16 & r4Out)
{
	struct Eq_n * r4_n = r5->ptr0002;
	word16 v10_n = r4_n->w0002;
	cui16 v12_n = r4_n->w0000;
	Eq_n r3_n = __rcr<word16,byte>(0x00, 0x01, cond(v12_n << 1) & 0x01);
	Eq_n r0_n = __rcr<word16,byte>(v12_n << 1, 0x01, 0x01);
	Eq_n r2_n = SEQ(SLICE(r0_n, byte, 8), 0x00);
	cui16 r0_n = r0_n & ~r2_n;
	wchar_t r2_n = __swab(r2_n);
	int16 r0_n;
	if (r2_n <= 0x00)
	{
		int32 r0_r1_n = SEQ(r0_n, v10_n);
		if (r2_n < 0x91)
		{
			do
			{
				word16 r1_n;
				ci16 v32_n;
				while (true)
				{
					r0_n = SLICE(r0_r1_n, word16, 16);
					r1_n = (word16) r0_r1_n;
					v32_n = 0x88 - r2_n;
					if (v32_n >= 0x00)
						break;
					r0_r1_n <<= 0x01;
					--r2_n;
				}
				if (v32_n == 0x00)
					break;
				++r2_n;
				r0_n >>= 1;
				r0_r1_n = SEQ(r0_n >> 1, r1_n);
			} while (r0_n >> 1 != 0x00);
			if (r3_n <= 0x00)
				r0_n = -r0_n;
l107E:
			if (r0_n == 0x00)
			{
l1086:
				g_ptr0ABE();
				r4Out = &g_t0AC0;
				word16 r0_n;
				return r0_n;
			}
			r3_n = (word16) r3_n + r0_n;
			if (r3_n >= 0x00)
				goto l1086;
			goto l105E;
		}
l105E:
		__syscall<word16>(0x8981);
	}
	r0_n = 0x00;
	goto l107E;
}

<anonymous> * g_ptr0ABE = &g_t0AC0; // 0ABE
<unknown> g_t0AC0 = // 0AC0;
// 0AC4: void fn0AC4(Register (ptr16 (ptr16 code)) r4, Stack Eq_n wArg00, Stack Eq_n wArg02, Stack (ptr16 code) wArg04)
void fn0AC4(<anonymous> ** r4, Eq_n wArg00, Eq_n wArg02, <anonymous> * wArg04)
{
	fn0AE6(r4, 0x0101, wArg00, wArg02, wArg04);
}

// 0AE2: Register word16 fn0AE2(Register (ptr16 (ptr16 code)) r4, Stack Eq_n wArg00, Stack Eq_n wArg02, Stack (ptr16 code) wArg04)
// Called from:
//      fn3B42
word16 fn0AE2(<anonymous> ** r4, Eq_n wArg00, Eq_n wArg02, <anonymous> * wArg04)
{
	return fn0AE6(r4, 0x0202, wArg00, wArg02, wArg04);
}

// 0AE6: Register Eq_n fn0AE6(Register (ptr16 (ptr16 code)) r4, Stack word16 wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack (ptr16 code) wArg06)
// Called from:
//      fn0AC4
//      fn0AE2
Eq_n fn0AE6(<anonymous> ** r4, word16 wArg00, Eq_n wArg02, Eq_n wArg04, <anonymous> * wArg06)
{
	uint8 bArg00 = (byte) wArg00;
	uint8 bArg01 = SLICE(wArg00, byte, 8);
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	uint16 wLoc04_n;
	if (bArg00 != 0x01)
	{
		wLoc04_n = (uint16) bArg00;
		if (bArg00 != 0x08)
			wLoc04_n += 0x03;
	}
	*((word16) r3_n + 0x00A4) = wLoc04_n + (word16) (bArg00 < bArg01);
	if (*((word16) r3_n + 116) == 0x00)
	{
		*((word16) r3_n + 82) = wArg00;
		*((word16) r3_n + 0x0044) = wArg04;
		wArg06();
		Eq_n r3;
		return r3;
	}
	else
	{
		*((word16) r3_n + 82) = wArg00;
		*((word16) r3_n + 0x0044) = wArg02;
		wArg04();
		(*r4)();
		return r3_n;
	}
}

// 0B3E: void fn0B3E(Register Eq_n r0, Stack Eq_n wArg00, Stack Eq_n wArg02, Stack (ptr16 word16) ptrArg04)
void fn0B3E(Eq_n r0, Eq_n wArg00, Eq_n wArg02, word16 * ptrArg04)
{
	fn0B60(r0, 0x0202, wArg00, wArg02, ptrArg04);
}

// 0B44: void fn0B44(Register Eq_n r0, Stack Eq_n wArg00, Stack Eq_n wArg02, Stack (ptr16 word16) ptrArg04)
void fn0B44(Eq_n r0, Eq_n wArg00, Eq_n wArg02, word16 * ptrArg04)
{
	fn0B60(r0, 0x0101, wArg00, wArg02, ptrArg04);
}

// 0B60: void fn0B60(Register Eq_n r0, Stack word16 wArg00, Stack Eq_n wArg02, Stack Eq_n wArg04, Stack (ptr16 word16) ptrArg06)
// Called from:
//      fn0B3E
//      fn0B44
void fn0B60(Eq_n r0, word16 wArg00, Eq_n wArg02, Eq_n wArg04, word16 * ptrArg06)
{
	uint8 bArg00 = (byte) wArg00;
	uint8 bArg01 = SLICE(wArg00, byte, 8);
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	uint16 wLoc04_n;
	if (bArg00 != 0x01)
	{
		wLoc04_n = (uint16) bArg00;
		if (bArg00 != 0x08)
			wLoc04_n += 0x03;
	}
	*((word16) r3_n + 0x00A4) = wLoc04_n + (word16) (bArg00 < bArg01);
	<anonymous> ** sp_n;
	ptr16 fp;
	word16 * sp_n;
	if (*((word16) r3_n + 116) != 0x00)
	{
		*((word16) r3_n + 82) = wArg00;
		*((word16) r3_n + 0x0044) = wArg02;
		*((word16) r3_n + 90) = *wArg04;
		((word16) r3_n + 0x007E)->u0 = 0x0BEC;
		sp_n = fp + 0x06;
l0BC6:
		(*sp_n)();
		struct Eq_n * sp_n = (struct Eq_n *) ((char *) sp_n + 2);
		sp_n->tFFFFFFFE.u0 = (struct Eq_n *) r3_n;
		Eq_n r0_n;
		sp_n->tFFFFFFFC.u0 = (struct Eq_n *) r0_n;
		Eq_n r3_n;
		r3_n.u0 = g_t5424.u0;
		*((word16) r3_n + 0x0044) = (word16) *((word16) r3_n + 0x0044) + (int16) (*((word16) r3_n + 83));
		Eq_n v37_n;
		v37_n.u0 = sp_n->tFFFFFFFC.u0;
		word16 v39_n = *((word16) r3_n + 90) - 0x01;
		*((word16) r3_n + 90) = v39_n;
		sp_n = sp_n - 0x02;
		r0 = v37_n;
		if (v39_n == 0x00)
		{
			sp_n->tFFFFFFFC.u0 = sp_n->tFFFFFFFE.u0;
			sp_n->tFFFFFFFE.u0 = (struct Eq_n *) *((word16) r3_n + 0x007E);
			sp_n->tFFFFFFFE.u0();
			return;
		}
	}
	else
	{
		*((word16) r3_n + 82) = wArg00;
		*((word16) r3_n + 0x007E) = wArg02;
		*((word16) r3_n + 0x0044) = wArg04;
		*((word16) r3_n + 90) = *ptrArg06;
		sp_n = fp + 0x06;
	}
	sp_n = sp_n + 1;
	r3_n = *sp_n;
	goto l0BC6;
}

// 0C4A: void fn0C4A(Register ci16 r0, Register Eq_n r1, Stack cui16 wArg02, Stack (ptr16 code) wArg04)
void fn0C4A(ci16 r0, Eq_n r1, cui16 wArg02, <anonymous> * wArg04)
{
	if (r0 > 0x01)
		return;
	if (wArg02 << 1 < 0x00)
	{
		if (wArg02 << 1 <= 0x00)
			r1 = -r1;
		r1 = __rcl<word16,byte>(r1 >> 0x01, 0x01, (r1 & 0x01) != 0x00);
		if (OVERFLOW<word16>(r1))
		{
			wArg04();
			return;
		}
	}
	wArg04();
}

// 0CF4: void fn0CF4(Register (ptr16 Eq_n) r5)
void fn0CF4(struct Eq_n * r5)
{
	if (r5->b0000 == 0x01)
	{
		struct Eq_n * r0_n = r5->ptr0002;
		Eq_n tLoc08;
		tLoc08.ptr0006 = (char *) &tLoc08 + 6;
		tLoc08.ptr0004 = (char *) &tLoc08 + 4;
		tLoc08.ptr0002 = (char *) &tLoc08 + 2;
		tLoc08.w0000 = 0x03;
		fn15CC(&tLoc08);
		struct Eq_n * r1_n = (tLoc08.w0002 << 1) + tLoc08.w0002;
		struct Eq_n * r0_n = fn0D3E(r0_n, tLoc08.t0004.u0);
		r0_n->b0000 = 0x2D;
		r0_n->b0001 = r1_n->b0D4F;
		r0_n->b0002 = r1_n->b0D50;
		r0_n->b0003 = r1_n->b0D51;
		r0_n->b0004 = 0x2D;
		Eq_n v36_n;
		v36_n.u0 = tLoc08.t0006.u0;
		fn0D3E(&r0_n->b0004 + 1, v36_n);
	}
	else
		__syscall<word16>(0x8990);
}

// 0D3E: Register (ptr16 Eq_n) fn0D3E(Register (ptr16 Eq_n) r0, Register Eq_n r2)
// Called from:
//      fn0CF4
struct Eq_n * fn0D3E(struct Eq_n * r0, Eq_n r2)
{
	ci16 r2_n = __swab(r2);
	do
		r2_n += 0xF601;
	while (r2_n > 0x00);
	r0->b0000 = (byte) r2_n + 0x2F;
	r0->b0001 = (byte) __swab(r2_n + 0x3A2F);
	return &r0->b0001 + 1;
}

// 0D7A: void fn0D7A(Register word16 r0, Stack word16 wArg00, Stack word16 wArg02, Stack word16 wArg04)
void fn0D7A(word16 r0, word16 wArg00, word16 wArg02, word16 wArg04)
{
	g_t0D7E();
}

<anonymous> g_t0D7E = <code>; // 0D7E
// 0DC8: void fn0DC8(Register word16 r0, Stack word16 wArg00, Stack word16 wArg02, Stack word16 wArg04)
void fn0DC8(word16 r0, word16 wArg00, word16 wArg02, word16 wArg04)
{
	g_t0DCC();
}

<anonymous> g_t0DCC = <code>; // 0DCC
// 0E0E: FlagGroup cui16 fn0E0E(Stack (ptr16 code) wArg00, Stack cui16 wArg02, Stack Eq_n wArg04, Stack cui16 wArg06, Stack Eq_n wArg08)
// Called from:
//      fn3B42
cui16 fn0E0E(<anonymous> * wArg00, cui16 wArg02, Eq_n wArg04, cui16 wArg06, Eq_n wArg08)
{
	Eq_n r4_n;
	r4_n.u0 = g_t5424.u0;
	*((word16) r4_n + 42) = wArg00;
	cup16 v19_n = wArg06 - wArg02;
	bool v25_n = v19_n >= 0x00;
	if (v19_n == 0x00)
	{
		cup16 v21_n = wArg08 - wArg04;
		v25_n = v21_n >= 0x00;
		if (v21_n == 0x00)
		{
l0E7C:
			(*((word16) r4_n + 42))();
			cui16 NZVC_n;
			return NZVC_n & 0x08 | NZVC_n & 0x02;
		}
	}
	goto l0E7C;
}

// 0EA8: void fn0EA8(Stack Eq_n wArg00)
// Called from:
//      fn3B42
void fn0EA8(Eq_n wArg00)
{
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	((word16) r3_n + 0x0044)->u0 = 0x00;
	if (*((word16) r3_n + 116) == 0x00)
		*((word16) r3_n + 0x007E) = wArg00;
	wArg00();
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	*((word16) r3_n + 116) != 0x00;
	*((word16) r3_n + 114) = null;
	*((word16) r3_n + 112) = null;
	*((word16) r3_n + 20) = null;
	*((word16) r3_n + 0x0C) = *((word16) r3_n + 88);
	*((word16) r3_n + 0x00A2) = 0x00;
}

Eq_n g_t0EF4 = // 0EF4
	{
		
		{
			0x5C
		},
		&g_w15C1,
		0x0A01,
		40166,
		0x00,
		4838,
		5158,
		5158,
		0x0A0B,
	};
// 0EF8: void fn0EF8(Register (ptr16 Eq_n) r4, Register (ptr16 word16) r5)
// Called from:
//      fn243A
//      fn2B90
//      fn2E20
//      fn2EC4
//      fn3220
//      fn34AC
//      fn395C
//      fn3B3C
//      fn3E12
//      fn3F42
//      fn4030
//      fn4072
//      fn413C
//      fn4180
//      fn4230
//      fn4534
//      fn457C
//      fn45C8
void fn0EF8(struct Eq_n * r4, word16 * r5)
{
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	struct Eq_n * v14_n = r4->ptr0000;
	struct Eq_n * v18_n = (struct Eq_n *) *((word16) r3_n + 0x0E);
	word16 v19_n = (word16) *r3_n;
	byte v17_n = (byte) *((word16) r3_n + 116);
	byte bLoc04_n = v14_n->b0001;
	*r3_n = 0x00;
	ptr16 fp;
	*((word16) r3_n + 0x0E) = fp - 0x07;
	word16 v23_n = *r5;
	byte bLoc03_n = (byte) v19_n;
	byte bLoc01_n = (byte) v18_n;
	byte bLoc02_n = SLICE(v19_n, byte, 8);
	byte bArg00_n = SLICE(v18_n, byte, 8);
	word16 * r0_n = &v14_n->w0004;
	word16 * r5_n = r5 + 1;
	word16 r1_n = v23_n;
	word16 wLoc04_n = SEQ(bLoc03_n, bLoc04_n);
	wLoc04_n = SEQ(bLoc03_n, bLoc04_n);
	struct Eq_n * wLoc02_n = SEQ(bLoc01_n, bLoc02_n);
	wLoc02_n = SEQ(bLoc01_n, bLoc02_n);
	if (v23_n != 0x00)
	{
		word16 v24_n = v14_n->w0004;
		r0_n = &v14_n->ptr0006;
		word16 r2_n = v24_n;
		if (v24_n != 0x00)
		{
			r0_n = v14_n->ptr0006;
			do
			{
				*r0_n = *r5_n;
				++r5_n;
				++r0_n;
				--r1_n;
				if (r1_n == 0x00)
					break;
				--r2_n;
			} while (r2_n != 0x00);
		}
	}
	*((word16) r3_n + 116) = 0x00;
	word16 wArg00_n = SEQ(v17_n, bArg00_n);
	if (true)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		struct Eq_n * stackArg0 = (struct Eq_n *) <invalid>;
		fn3B42(stackArg0);
		Eq_n r4_n;
		r4_n.u0 = g_t5424.u0;
		*r4_n = wLoc04_n;
		*((word16) r4_n + 0x0E) = wLoc02_n;
		*((word16) r4_n + 116) = bArg00_n;
	}
	else
		r4->ptr0002();
}

// 0F48: Register uint16 fn0F48(Register (ptr16 Eq_n) r5, Register out Eq_n r1Out, Register out (ptr16 Eq_n) r5Out)
// Called from:
//      fn3B42
uint16 fn0F48(struct Eq_n * r5, union Eq_n & r1Out, struct Eq_n & r5Out)
{
	uint16 r0;
	Eq_n r1;
	if (r5->b0000 == 0x02)
	{
		union Eq_n * v14_n = r5->ptr0002;
		ui16 * v16_n = r5->ptr0004;
		r5 = (struct Eq_n *) ((char *) &r5->ptr0004 + 2);
		Eq_n r0_n;
		r0_n.u0 = v14_n->u0;
		ui16 r1_n = *v16_n;
		ui32 r0_r1_n;
		if (r1_n != 0x00)
		{
			r0_r1_n = SEQ(__rcl<word16,byte>(r0_n, 0x01, cond(r1_n << 1) & 0x01) + v14_n->u0, r1_n << 1) + SEQ(*v16_n, *v16_n);
			word16 r1_n = (word16) r0_r1_n;
			ci16 r0_n = SLICE(r0_r1_n, word16, 16);
			if (r0_n <= 0x00)
				r0_r1_n = SEQ(r0_n + 0x8000, r1_n);
		}
		else
			r0_r1_n = SEQ((word16) r0_n + 1, 0x03);
		v14_n->u0 = SLICE(r0_r1_n, word16, 16);
		*v16_n = (word16) r0_r1_n;
		cui16 r2_n = 0x81;
		ui32 r0_r1_n = r0_r1_n;
		word16 r1_n;
		cui16 r0_n;
		while (true)
		{
			r0_r1_n <<= 0x01;
			r1_n = (word16) r0_r1_n;
			r0_n = SLICE(r0_r1_n, word16, 16);
			if ((SLICE(r0_r1_n, word16, 16) & 0x8000) != 0x00)
				break;
			--r2_n;
		}
		Eq_n r1_n = __swab(SEQ(SLICE(r1_n, byte, 8), 0x00) | r0_n);
		cu16 r0_n = __swab(SEQ(SLICE(r0_n, byte, 8), 0x00) | r2_n);
		r0 = r0_n >> 0x01;
		r1 = __rcr<word16,byte>(r1_n, 0x01, (r0_n & 0x01) != 0x00);
	}
	else
		__syscall<word16>(0x8990);
	r1Out = r1;
	r5Out = r5;
	return r0;
}

// 0F9C: void fn0F9C()
void fn0F9C()
{
	t0000.b002B |= 0x01;
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	*((word16) r3_n + 0x0066) = (word16) *((word16) r3_n + 0x0066) + 1;
	struct Eq_n * r4_n = (struct Eq_n *) *((word16) r3_n + 4);
	struct Eq_n * r4_n;
	while (r4_n < *((word16) r3_n + 2))
	{
		r4_n = r4_n + 1;
		r4_n = r4_n;
		if (r4_n->b0000 != 0x00)
		{
			if (*((word16) r3_n + 0x0066) == 0x02)
			{
				r4_n->bFFFFFFFF = 0x00;
				--*((word16) r3_n + 0x0066);
				--r4_n;
			}
			else
				g_ptr1DAA();
		}
	}
	union Eq_n * r0_n = (union Eq_n *) *((word16) r3_n + 110);
	if (r0_n == null)
	{
		cui16 v31_n = t0000.w0024 & 0x0800;
		t0000.w0024 = v31_n;
		if (v31_n == 0x00)
			r0_n = (union Eq_n *) ((char *) r0_n + 1);
		EXIT(r0_n);
	}
	else
		r0_n();
}

// 0FA4: void fn0FA4(Register int16 r0, Stack (ptr16 Eq_n) wArg00, Stack (ptr16 Eq_n) wArg02, Stack word16 wArg04, Stack word16 wArg06)
// Called from:
//      fn3B42
void fn0FA4(int16 r0, struct Eq_n * wArg00, struct Eq_n * wArg02, word16 wArg04, word16 wArg06)
{
	fn0FB2(r0, &g_t1020, wArg00, wArg02, wArg04, wArg06);
}

// 0FAE: void fn0FAE(Register int16 r0, Stack (ptr16 Eq_n) wArg00, Stack (ptr16 Eq_n) wArg02, Stack word16 wArg04, Stack word16 wArg06)
void fn0FAE(int16 r0, struct Eq_n * wArg00, struct Eq_n * wArg02, word16 wArg04, word16 wArg06)
{
	fn0FB2(r0, &g_t101E, wArg00, wArg02, wArg04, wArg06);
}

// 0FB2: void fn0FB2(Register int16 r0, Stack (ptr16 Eq_n) wArg00, Stack (ptr16 Eq_n) wArg02, Stack (ptr16 Eq_n) wArg04, Stack word16 wArg06, Stack word16 wArg08)
// Called from:
//      fn0FA4
//      fn0FAE
void fn0FB2(int16 r0, struct Eq_n * wArg00, struct Eq_n * wArg02, struct Eq_n * wArg04, word16 wArg06, word16 wArg08)
{
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	ptr16 fp;
	*((word16) r3_n + 100) = fp + 0x0A;
	if (*((word16) r3_n + 20) != null)
		__syscall<word16>(0x899A);
	*((word16) r3_n + 20) = wArg00;
	*((word16) r3_n + 28) = wArg04;
	g_t0FE2();
}

<anonymous> g_t0FE2 = <code>; // 0FE2
Eq_n g_t101E = // 101E
	{
		
		{
			0x00
		},
		&g_wFFFF8000,
		0x1DC4,
		0x0109,
		0x1D,
		0x2A,
		5516,
		5558,
		0x02,
	};
Eq_n g_t1020 = // 1020
	{
		
		{
			0x00
		},
		&g_w1DC4,
		0x4400,
		0x1DC4,
		0x43,
		5516,
		5558,
		0x02,
		5558,
	};
// 11A6: void fn11A6(Register (ptr16 Eq_n) r0, Register (ptr16 word16) r5)
// Called from:
//      fn0818
//      fn0A64
void fn11A6(struct Eq_n * r0, word16 * r5)
{
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	*((word16) r3_n + 100) = r0;
	*((word16) r3_n + 88) = *((word16) r3_n + 0x0C);
	word16 * r0_n = g_a541C;
	word16 * r1_n = &g_w542C;
	word16 * r2_n = &g_ptr5426;
	word16 ** r5_n = r5 + 1;
	while (true)
	{
		r2_n -= 0x02;
		word16 * r3_n = *r2_n;
		if (r3_n == null)
			break;
		uint16 r4_n = *r0_n;
		r1_n -= 0x02;
		*r1_n = **r5_n;
		uint16 v25_n = *r1_n;
		++r0_n;
		r5_n = (word16 **) ((char *) r5_n + 2);
		uint16 wLoc02_n = v25_n;
		bool v40_n = v25_n == 0x00;
		while (!v40_n)
		{
			uint16 v29_n = wLoc02_n >> 0x01;
			wLoc02_n = v29_n;
			if ((wLoc02_n & 0x01) != 0x00)
			{
				r4_n &= 0x01;
				if (r4_n != 0x00)
				{
					*r3_n = *r5_n;
					r5_n = (word16 **) ((char *) r5_n + 2);
				}
			}
			++r3_n;
			r4_n >>= 0x01;
			v40_n = v29_n == 0x00;
		}
	}
}

<anonymous> g_t11EC = <code>; // 11EC
// 12AC: void fn12AC(Register int16 r2)
void fn12AC(int16 r2)
{
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	*((word16) r3_n + 0x00A2) = (byte) r2;
	if (*((word16) r3_n + 20) != null)
		__syscall<word16>(0x899A);
	struct Eq_n * r0_n = fn1420(r2, r3_n);
	*((word16) r3_n + 20) = r0_n;
	r0_n->t0000.u1 = (ci16) (r0_n->t0000.u1 & 0x0800);
}

// 12CA: void fn12CA(Register ptr16 r2, Register Eq_n r3)
void fn12CA(ptr16 r2, Eq_n r3)
{
	struct Eq_n * r4_n = (struct Eq_n *) *((word16) r3 + 20);
	struct Eq_n * r1_n = (struct Eq_n *) *((word16) r3 + 26);
	if (r4_n->t0000.u0 <= 0x00)
	{
		PRINT(&g_b138E);
		r2 = (ptr16) *((word16) r3 + 84);
		ptr16 fp;
		*((word16) r3 + 84) = fp - 0x04;
	}
	Eq_n v19_n = r4_n->t0000.u1 & 0x20;
	r4_n->t0000.u1 = (ci16) v19_n;
	int16 r0_n = 0x0A;
	if (v19_n != 0x00)
	{
		byte v21_n = r1_n->b0000;
		++r1_n;
		if (v21_n == 0x31)
		{
			r0_n = 0x0C;
l1326:
			word16 r2_n;
			fn1366(r0_n, r3, r4_n, out r2_n, out r3, out r4_n);
l132A:
			if (r4_n->t0000.u0 <= 0x00)
			{
				if (r1_n < *((word16) r3 + 28))
				{
					int16 r5_n = (int16) **((word16) r3 + 28);
					**((word16) r3 + 28) = 0x80;
					PRINT(r1_n);
					**((word16) r3 + 28) = (byte) r5_n;
				}
			}
			else
			{
				for (; r1_n < *((word16) r3 + 28); ++r1_n)
				{
					word16 r2_n;
					fn1370((int16) r1_n->b0000, r3, r4_n, out r2_n, out r3, out r4_n);
				}
			}
			return;
		}
		if (v21_n == 0x2B)
			goto l132A;
		if (v21_n == 0x24)
		{
			--*((word16) r3 + 28);
			*((word16) r3 + 84) = null;
		}
		else if (v21_n == 0x30)
			r0_n = fn1366(0x0A, r3, r4_n, out r2, out r3, out r4_n);
	}
	if (r4_n->t0000.u0 <= 0x00 && r2 == null)
		goto l132A;
	goto l1326;
}

// 1366: Register int16 fn1366(Register int16 r0, Register Eq_n r3, Register (ptr16 Eq_n) r4, Register out word16 r2Out, Register out Eq_n r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn12CA
int16 fn1366(int16 r0, Eq_n r3, struct Eq_n * r4, word16 & r2Out, union Eq_n & r3Out, struct Eq_n & r4Out)
{
	struct Eq_n * r4_n;
	Eq_n r3_n;
	word16 r2_n;
	if (r4->t0000.u0 > 0x00)
	{
		int16 r0_n = fn1370(r0, r3, r4, out r2_n, out r3_n, out r4_n);
		r2Out = r2_n;
		r3Out = r3_n;
		r4Out = r4_n;
		return r0_n;
	}
	else
	{
		while (TTYOUT((char) r0))
			;
		word16 r2;
		r2Out = r2;
		r3Out = r3;
		r4Out = r4;
		return r0;
	}
}

// 1370: Register int16 fn1370(Register int16 r0, Register Eq_n r3, Register (ptr16 Eq_n) r4, Register out (ptr16 byte) r2Out, Register out Eq_n r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn12CA
//      fn1366
int16 fn1370(int16 r0, Eq_n r3, struct Eq_n * r4, byte & r2Out, union Eq_n & r3Out, struct Eq_n & r4Out)
{
	struct Eq_n * r4_n;
	Eq_n r3_n;
	byte * r2_n;
	byte * r2_n = r4[7] + r4[1];
	*r2_n = (byte) r0;
	r4[7] = (struct Eq_n) ((word16) r4[7].t0000 + 1);
	cui16 v16_n = r4[7] & 0x01FF;
	r4[7] = (struct Eq_n) v16_n;
	if (v16_n != 0x00)
	{
		r2Out = r2_n;
		r3Out = r3;
		r4Out = r4;
		return r0;
	}
	else
	{
		r4[7] = (struct Eq_n) 0x00;
		int16 r0_n = fn1836(r3, r4, out r2_n, out r3_n, out r4_n);
		r2Out = r2_n;
		r3Out = r3_n;
		r4Out = r4_n;
		return r0_n;
	}
}

char g_b138E = '\x80'; // 138E
Eq_n g_t1396 = // 1396
	{
		&g_t15C4,
		&g_t13F0,
	};
<anonymous> g_t13F0 = <code>; // 13F0
// 13FE: void fn13FE()
// Called from:
//      fn14A8
//      fn45F6
void fn13FE()
{
	WAIT0();
	__syscall<word16>(0x88A1);
	__syscall<word16>(0x88A2);
	__syscall<word16>(0x88A3);
	__syscall<word16>(0x88A4);
	__syscall<word16>(0x88A5);
	__syscall<word16>(0x88A6);
	__syscall<word16>(0x88A7);
	__syscall<word16>(0x88A8);
	__syscall<word16>(0x88A9);
	__syscall<word16>(0x88AA);
	__syscall<word16>(0x88AB);
	__syscall<word16>(0x88AC);
	__syscall<word16>(0x88AD);
	__syscall<word16>(0x88AE);
	__syscall<word16>(0x88AF);
}

// 1420: Register word16 fn1420(Register int16 r2, Register Eq_n r3)
// Called from:
//      fn12AC
//      fn145E
//      fn14A8
word16 fn1420(int16 r2, Eq_n r3)
{
	if (r2 <= 0x00 || r2 > 99)
		__syscall<word16>(0x8994);
	struct Eq_n * v15_n = (struct Eq_n *) *((word16) r3 + 4);
	struct Eq_n * r1_n = v15_n;
	do
	{
		++r1_n;
		if ((byte) r2 == r1_n->b0000)
			goto l144A;
	} while (r1_n < *((word16) r3 + 2));
	r1_n = v15_n;
	do
	{
		++r1_n;
		if (r1_n->b0000 == 0x00)
			goto l144A;
	} while (r1_n < *((word16) r3 + 2));
	__syscall<word16>(0x8995);
l144A:
	byte * r1_n = r1_n - 0x01;
	*r1_n = (byte) r2;
	word16 r0_n = (word16) *((word16) r3 + 6);
	ptr16 r1_n;
	for (r1_n = r1_n - v15_n; r1_n != null; --r1_n)
		r0_n += 0x20;
	return r0_n;
}

// 145E: void fn145E(Register word16 r2, Stack (ptr16 code) wArg00, Stack word16 wArg02, Stack (ptr16 int16) ptrArg04)
void fn145E(word16 r2, <anonymous> * wArg00, word16 wArg02, int16 * ptrArg04)
{
	struct Eq_n * r0_n;
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	ptr16 fp;
	*((word16) r3_n + 100) = fp + 22;
	*((word16) r3_n + 0x00A2) = (byte) r2;
	if (*((word16) r3_n + 20) != null)
		__syscall<word16>(0x899A);
	*((word16) r3_n + 18) = wArg02;
	int16 v19_n = *ptrArg04;
	struct Eq_n * r0_n = fn1420(v19_n, r3_n);
	*((word16) r3_n + 20) = r0_n;
	r0_n->t0000.u1 = (ci16) (r0_n->t0000.u1 & 0x0800);
	wArg00();
	ci16 v23_n = r0_n->w0000 & 0x0800;
	r0_n->w0000 = v23_n;
	if (v23_n == 0x00)
		fn45F6(r0_n, v19_n, r3_n);
	*((word16) r3_n + 26) = *((word16) r3_n + 2);
	*((word16) r3_n + 88) = *((word16) r3_n + 0x0C);
}

// 14A8: void fn14A8(Register int16 r2, Register uint16 r5)
void fn14A8(int16 r2, uint16 r5)
{
	Eq_n r3_n;
	r3_n.u0 = g_t5424.u0;
	*((word16) r3_n + 0x00A2) = (byte) r2;
	struct Eq_n * r0_n = fn1420(r2, r3_n);
	*((word16) r3_n + 20) = r0_n;
	cui16 v15_n = r0_n->t0000.u1 & 0x0800;
	r0_n->t0000.u1 = v15_n;
	if (v15_n != 0x00)
	{
		word16 * wLoc08_n;
		if (r0_n->t0000.u0 >= 0x00)
		{
			struct Eq_n * r4_n;
			r3_n = fn1D30(r0_n, r3_n, out r4_n);
			ci16 v22_n = r4_n->t0000.u1 & 0x0200;
			r4_n->t0000.u1 = v22_n;
			if (v22_n != 0x00)
			{
				cu16 v24_n = (cu16) r4_n[0x0C];
				r4_n[11] = (struct Eq_n) v24_n;
				if (v24_n != 0x00)
				{
					word16 * r2_n = (word16 *) r4_n[1];
					word16 r5_n;
					for (r5_n = 0x0100; r5_n != 0x00; --r5_n)
					{
						*r2_n = 0x00;
						++r2_n;
					}
					ci16 v27_n = r4_n->t0000.u1 & 0x0100;
					r4_n->t0000.u1 = v27_n;
					if (v27_n != 0x00)
					{
						*((word16) r3_n + 112) = &g_t1520;
						if (*((word16) r3_n + 116) != 0x00)
							*((word16) r3_n + 114) = &g_t151E;
						ptr16 fp;
						*((word16) r3_n + 100) = fp - 0x09;
						while (true)
						{
							word16 r2_n;
							fn1836(r3_n, r4_n, out r2_n, out r3_n, out r4_n);
						}
					}
					while (r4_n[11] <= r4_n[0x0D])
					{
						word16 r2_n;
						fn1836(r3_n, r4_n, out r2_n, out r3_n, out r4_n);
					}
				}
			}
			fn13FE();
			cui16 r5_n = (cui16) r4_n[2];
			word16 * r2_n = (word16 *) r4_n[1];
			ci16 v49_n = r4_n->t0000.u1 & 0x01;
			r4_n->t0000.u1 = v49_n;
			r5 = r5_n << 1;
			if (v49_n != 0x00)
				r2_n -= 0x0200;
			wLoc08_n = r2_n;
			word16 * r0_n = r2_n + r5_n;
			do
			{
				*r2_n = *r0_n;
				++r0_n;
				++r2_n;
			} while (r0_n < *((word16) r3_n + 0x0C));
			*((word16) r3_n + 0x0C) -= r5_n << 1;
			ci16 v63_n = r4_n->t0000.u1 & 0x04;
			r4_n->t0000.u1 = v63_n;
			int16 r1_n = (int16) r4_n->b0011;
			__syscall<word16>(0x88FC);
			Eq_n r0_n;
			r0_n.u0 = 0x00;
			Eq_n C_n;
			C_n.u0 = 0x01;
			do
			{
				r0_n = __rcl<word16,byte>(r0_n, 0x01, C_n);
				C_n = (r0_n & 0x8000) != 0x00;
				--r1_n;
			} while (r1_n > 0x00);
			*((word16) r3_n + 16) &= ~r0_n;
		}
		else
			wLoc08_n = (word16 *) ~0x00;
		*((word16) r3_n + 114) = null;
		*((word16) r3_n + 112) = null;
		struct Eq_n * r4_n = (struct Eq_n *) *((word16) r3_n + 4);
		while (r4_n < *((word16) r3_n + 2))
		{
			++r4_n;
			int16 r2_n = (int16) r4_n->b0000;
			if (r2_n != 0x00)
			{
				struct Eq_n * r0_n = fn1420(r2_n, r3_n);
				if (wLoc08_n < r0_n[1])
					r0_n[1] = (struct Eq_n) (r0_n[1] - r5);
			}
		}
		r0_n = (struct Eq_n *) *((word16) r3_n + 20);
	}
	word16 r4_n;
	for (r4_n = 0x10; r4_n != 0x00; --r4_n)
	{
		r0_n->t0000.u1 = (ci16) 0x00;
		++r0_n;
	}
	struct Eq_n * r0_n = (struct Eq_n *) *((word16) r3_n + 4);
	struct Eq_n * r0_n;
	do
	{
		r0_n = r0_n + 1;
		r0_n = r0_n;
	} while (r0_n->b0000 != (byte) r2);
	r0_n->bFFFFFFFF = 0x00;
	*((word16) r3_n + 20) = null;
	*((word16) r3_n + 0x00A2) = 0x00;
}

Eq_n g_t151E = // 151E
	{
		
		{
			0x20
		},
		&g_wFFFF95B3,
		0xA2,
		0x04,
		0x0C,
		0x35CC,
		0x01,
		770,
		58818,
	};
Eq_n g_t1520 = // 1520
	{
		
		{
			~0x4C
		},
		&g_w00A2,
		5508,
		0x0CC5,
		0x1D,
		0x01,
		770,
		58818,
		0x0200,
	};
word16 g_w15C1 = 0x8715; // 15C1
Eq_n g_t15C4 = // 15C4
	{
		0x1004,
		5606,
	};
// 15CC: void fn15CC(Register (ptr16 Eq_n) r5)
// Called from:
//      fn0CF4
void fn15CC(struct Eq_n * r5)
{
	if (r5->b0000 != 0x03)
		__syscall<word16>(0x8990);
	else
	{
		Eq_n tLoc04;
		tLoc04.w0000 = 0x1100;
		tLoc04.w0002 = &tLoc04;
		FnSubfn(&tLoc04);
		__syscall<word16>(0x88FC);
		ptr16 r2_n = &g_t0A00;
		if (true)
			r2_n = &t0000.w0036 + 9;
		r5->ptr0002->u1 = (ptr16) (__swab(0x0280) & 0x1F);
		*r5->ptr0004 = &t0000.w0010;
		*r5->ptr0006 = r2_n;
	}
}

<anonymous> g_t15FF = <code>; // 15FF
// 16DA: void fn16DA(Register int16 r0, Register cui16 r2, Register Eq_n r3, Register (ptr16 Eq_n) r4)
void fn16DA(int16 r0, cui16 r2, Eq_n r3, struct Eq_n * r4)
{
	r4[7] = (struct Eq_n) r2;
	if (r4[11] != *((word16) r3 + 94))
	{
		ci16 v14_n = r4->t0000.u1 & 0x02;
		r4->t0000.u1 = v14_n;
		if (v14_n != 0x00)
		{
			word16 r2_n;
			r0 = fn1836(r3, r4, out r2_n, out r3, out r4);
			r4[0x0C] = (struct Eq_n) 0x00;
			r4->t0000.u1 &= ~0x02;
		}
		r4[11] = (struct Eq_n) *((word16) r3 + 94);
		if (r4->t0000.u1 > 0x00 || (*((word16) r3 + 92) < 0x0200 || r4[7] != 0x00))
		{
			struct Eq_n * r4_n;
			r3 = fn18BE(r0, r3, r4, out r4_n);
			--r4_n->w0016;
		}
	}
	*((word16) r3 + 94) = (word16) *((word16) r3 + 94) + 1;
}

// 171E: void fn171E(Register (ptr16 Eq_n) r0, Register (ptr16 Eq_n) r3)
void fn171E(struct Eq_n * r0, struct Eq_n * r3)
{
	ptr16 r2_n = *r3->ptr0012;
	*r0->ptr0012 = r2_n;
	++*r0->ptr0012;
	fn172C(r0, r2_n - 0x01);
}

// 172C: void fn172C(Register (ptr16 Eq_n) r0, Register uint16 r2)
// Called from:
//      fn171E
void fn172C(struct Eq_n * r0, uint16 r2)
{
	Eq_n r3_n;
	r3_n.u0 = r0->t0014.u0;
	uint32 r4_r1_n = 0x00;
	uint32 r5_r2_n = (uint32) r2;
	while (true)
	{
		Eq_n r4_n = SLICE(r4_r1_n, word16, 16);
		word16 r1_n = (word16) r4_r1_n;
		r3_n >>= 1;
		if (r3_n >= 0x00)
		{
			if (r3_n == 0x00)
			{
				cui16 r1_n = __swab(SEQ(SLICE(r1_n, byte, 8), 0x00));
				cui16 r4_n = __swab(r4_n);
				if (r4_n != 0x00)
					__syscall<word16>(0x89A8);
				Eq_n r3_n;
				r3_n.u0 = g_t5424.u0;
				*((word16) r3_n + 94) = r1_n | r4_n;
				*((word16) r3_n + 92) = r0->t0014.u0;
				*((word16) r3_n + 92) <<= 1;
				return;
			}
		}
		else
			r4_r1_n += r5_r2_n;
		r5_r2_n <<= 0x01;
	}
}

// 1836: Register word16 fn1836(Register Eq_n r3, Register (ptr16 Eq_n) r4, Register out word16 r2Out, Register out (ptr16 Eq_n) r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn1370
//      fn14A8
//      fn16DA
//      fn1D30
word16 fn1836(Eq_n r3, struct Eq_n * r4, word16 & r2Out, struct Eq_n & r3Out, struct Eq_n & r4Out)
{
	struct Eq_n * r4_n;
	struct Eq_n * r3_n;
	r4[0x0C] = r4[11];
	r4[0x0C] = (struct Eq_n) ((word16) r4[0x0C].t0000 + 1);
	if (r4[11] >= r4[0x0D])
		r4[0x0D] = r4[11];
	Eq_n v20_n = r4->t0000.u1 & 0x40;
	r4->t0000.u1 = (ci16) v20_n;
	if (v20_n != 0x00)
	{
		r4->t0000.u1 = (ci16) (r4->t0000.u1 & 0x7FFF);
		r4[0x0C] = (struct Eq_n) 0x00;
		__syscall<word16>(35235);
	}
	word16 r2_n = fn1900(r3, r4, out r3_n, out r4_n);
	byte v27_n = r4_n->b0011 | 0x90;
	SEQ(0x88, v27_n)();
	r2Out = r2_n;
	r3Out = r3_n;
	r4Out = r4_n;
	word16 r0_n;
	return r0_n;
}

// 18BE: Register Eq_n fn18BE(Register int16 r0, Register Eq_n r3, Register (ptr16 Eq_n) r4, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn16DA
Eq_n fn18BE(int16 r0, Eq_n r3, struct Eq_n * r4, struct Eq_n & r4Out)
{
	if (r4[0x0C] == 0x00 || r4[11] < r4[0x0C])
	{
		Eq_n r3_n;
		struct Eq_n * r4_n;
		fn1900(r3, r4, out r3_n, out r4_n);
		byte v19_n = r4_n->b0011 | 0x80;
		SEQ(0x88, v19_n)();
		r4Out = r4_n;
		return r3_n;
	}
	else
	{
		Eq_n r3_n;
		struct Eq_n * r4_n;
		fn1932(r3, r4, out r3_n, out r4_n);
		r4Out = r4_n;
		return r3_n;
	}
}

// 18F6: void fn18F6(Register (ptr16 Eq_n) r4)
// Called from:
//      fn1900
void fn18F6(struct Eq_n * r4)
{
	r4[11] = (struct Eq_n) ((word16) r4[11].t0000 + 1);
	fn18FE();
}

// 18FE: void fn18FE()
// Called from:
//      fn18F6
//      fn1900
void fn18FE()
{
}

// 1900: Register word16 fn1900(Register Eq_n r3, Register (ptr16 Eq_n) r4, Register out Eq_n r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn1836
//      fn18BE
word16 fn1900(Eq_n r3, struct Eq_n * r4, union Eq_n & r3Out, struct Eq_n & r4Out)
{
	struct Eq_n * r4_n;
	Eq_n r3_n;
	struct Eq_n * r4_n;
	Eq_n r3_n;
	struct Eq_n * r4_n;
	Eq_n r3_n;
	ptr16 fp;
	(*(fp - 0x04))();
	cui16 NZVC_n;
	if (NZVC_n & 0x01)
	{
		fn18FE();
		r3Out = r3;
		r4Out = r4;
		word16 r2;
		return r2;
	}
	else
	{
		r4->t0000.u1 &= 0x7FFD;
		cui16 v13_n = r4->t0000.u1 & 0x4000;
		r4->t0000.u1 = v13_n;
		if (v13_n != 0x00)
			r4[11] = (struct Eq_n) ~0x00;
		if (t0000.b002A == 0x00)
		{
			word16 r2_n = fn1932(r3, r4, out r3_n, out r4_n);
			r3Out = r3_n;
			r4Out = r4_n;
			return r2_n;
		}
		else
		{
			*((word16) r3 + 112) = null;
			struct Eq_n * r4_n = (struct Eq_n *) *((word16) r3 + 114);
			if (r4_n != null)
			{
				word16 r2_n = fn1932(r3, r4_n, out r3_n, out r4_n);
				r3Out = r3_n;
				r4Out = r4_n;
				return r2_n;
			}
			else
			{
				__syscall<word16>(35223);
				word16 r2_n = fn1932(r3, r4_n, out r3_n, out r4_n);
				r3Out = r3_n;
				r4Out = r4_n;
				return r2_n;
			}
		}
	}
}

// 1932: Register word16 fn1932(Register Eq_n r3, Register (ptr16 Eq_n) r4, Register out Eq_n r3Out, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn18BE
//      fn1900
word16 fn1932(Eq_n r3, struct Eq_n * r4, union Eq_n & r3Out, struct Eq_n & r4Out)
{
	cui16 v5_n = r4[0x0E] & 0x08;
	r4[0x0E] = (struct Eq_n) v5_n;
	if (v5_n != 0x00)
	{
		fn18F6(r4);
		r3Out = r3;
		r4Out = r4;
		word16 r2_n;
		return r2_n;
	}
	else
	{
		r4->t0000.u1 |= 0x1000;
		*((word16) r3 + 114) = null;
		struct Eq_n * r4_n = (struct Eq_n *) *((word16) r3 + 112);
		if (r4_n == null)
			__syscall<word16>(0x8998);
		struct Eq_n * sp_n = (struct Eq_n *) *((word16) r3 + 100);
		sp_n->ptrFFFFFFFE = &g_t0EF4;
		sp_n->tFFFFFFFC.u0 = (struct Eq_n *) r3;
		word16 r2;
		if (*((word16) r3 + 116) != 0x00)
		{
			*((word16) r3 + 114) = null;
			*((word16) r3 + 112) = null;
			*((word16) r3 + 20) = null;
			*((word16) r3 + 0x0C) = *((word16) r3 + 88);
			*((word16) r3 + 0x00A2) = 0x00;
			r3Out.u0 = sp_n->tFFFFFFFC.u0;
			r4Out = r4_n;
			return r2;
		}
		else
		{
			sp_n->ptrFFFFFFFE = r4_n;
			*((word16) r3 + 114) = null;
			*((word16) r3 + 112) = null;
			*((word16) r3 + 20) = null;
			*((word16) r3 + 0x0C) = *((word16) r3 + 88);
			*((word16) r3 + 0x00A2) = 0x00;
			r3Out.u0 = sp_n->tFFFFFFFC.u0;
			r4Out = r4_n;
			return r2;
		}
	}
}

// 194E: void fn194E(Register (ptr16 Eq_n) r3)
void fn194E(struct Eq_n * r3)
{
	++r3->w0012;
}

// 195A: void fn195A(Register (ptr16 Eq_n) r3)
void fn195A(struct Eq_n * r3)
{
	fn196A(r3);
}

// 1962: void fn1962(Register (ptr16 Eq_n) r3)
void fn1962(struct Eq_n * r3)
{
	fn1966(32, r3);
}

// 1966: void fn1966(Register int16 r0, Register (ptr16 Eq_n) r3)
// Called from:
//      fn1962
//      fn197A
void fn1966(int16 r0, struct Eq_n * r3)
{
	r3->t001C.u1->u1 = (ptr16) (byte) r0;
	fn196A(r3);
}

// 196A: Register Eq_n fn196A(Register (ptr16 Eq_n) r3)
// Called from:
//      fn195A
//      fn1966
Eq_n fn196A(struct Eq_n * r3)
{
	Eq_n r0_n;
	r0_n.u0 = r3->t001C.u0;
	if (r0_n < (r3->t0018).u0)
		r3->t001C.u0 = (cup16) (r3->t001C.u0 + 0x01);
	return r0_n;
}

// 197A: void fn197A(Register (ptr16 Eq_n) r3)
void fn197A(struct Eq_n * r3)
{
	if (r3->t001C.u0 < (r3->t0046).u0)
		r3->t001C.u0 = r3->t0046.u0;
	r3->t0046.u0 = 0x00;
	if (r3->w0056 != 0x00)
	{
		r3->ptr0060();
		r3->w0056 = 0x00;
		if (*r3->ptr0014 <= 0x00)
			r3->w0054 = 0x00;
	}
	else
	{
		fn1966(0x0D, r3);
		r3->ptr0060();
	}
}

// 1CFA: void fn1CFA()
// Called from:
//      fn1DAE
void fn1CFA()
{
}

// 1CFC: void fn1CFC()
void fn1CFC()
{
}

// 1D30: Register Eq_n fn1D30(Register (ptr16 Eq_n) r0, Register Eq_n r3, Register out (ptr16 Eq_n) r4Out)
// Called from:
//      fn14A8
Eq_n fn1D30(struct Eq_n * r0, Eq_n r3, struct Eq_n & r4Out)
{
	ci16 v8_n = r0->t0000.u1 & 0x4000;
	r0->t0000.u1 = v8_n;
	struct Eq_n * r4_n = r0;
	if (v8_n != 0x00)
	{
		ci16 v10_n = r0->t0000.u1 & 0x02;
		r0->t0000.u1 = v10_n;
		if (v10_n == 0x00)
			goto l1D84;
		r0->t0000.u1 &= ~0x02;
	}
	else
	{
		if (r0->t0000.u1 > 0x00)
			goto l1D84;
		ci16 v16_n = r0->t0000.u1 & 0x0200;
		r0->t0000.u1 = v16_n;
		if (v16_n != 0x00)
		{
			cui16 r2_n = (cui16) r0[7];
			byte * r2_n = (word16) r0[1].t0000 + r2_n;
			ci16 v22_n = r0->t0000.u1 & 0x2000;
			r0->t0000.u1 = v22_n;
			if (v22_n != 0x00)
				*r2_n = 0x00;
			else
				*r2_n = 0x0A;
			byte * r2_n = (word16) r0[1].t0000 + r2_n + 0x01;
			ci16 r1_n = r2_n - 0x01FF;
			if (r2_n != 0x01FF)
			{
				do
				{
					*r2_n = 0x00;
					++r2_n;
					++r1_n;
				} while (r1_n < 0x00);
			}
		}
		else
		{
			cui16 * r2_n = (word16) r0[1].w001C + 482;
			*r2_n |= 0x8000;
		}
	}
	word16 r2_n;
	fn1836(r3, r0, out r2_n, out r3, out r4_n);
l1D84:
	r4Out = r4_n;
	return r3;
}

<anonymous> * g_ptr1DAA = fn14A8; // 1DAA
// 1DAE: void fn1DAE()
void fn1DAE()
{
	<anonymous> * r0_n = g_ptr1DAA;
	if (r0_n != null)
		r0_n();
	struct Eq_n * sp_n = t0000.w0022;
	sp_n->ptrFFFFFFFE = (struct Eq_n *) &g_t1DB2;
	FnSubfn(&g_t0592);
	struct Eq_n * r5_n = t0000.w0028;
	sp_n->ptrFFFFFFFC = r5_n;
	sp_n->ptrFFFFFFFA = null;
	sp_n->wFFFFFFF8 = 0x1000;
	sp_n->ptrFFFFFFFA = sp_n - 0x18;
	FnSubfn(sp_n - 0x08);
	word16 r4_n = sp_n->wFFFFFFEA;
	if (g_ptr1DAA == null)
	{
		FnSubfn(&g_t03B8);
		if (false)
			t0000.w001E = 0xF000;
		if (true)
		{
			t0000.w0026 = 0x0200;
			if (g_w53EA != 0x00)
			{
				if (sp_n->wFFFFFFE8 != 0x00)
					PRINT(&g_b0380);
				else
				{
					FnSubfn(&g_t03BC);
					t0000.w0026 = 0x00;
					r4_n = 0x03BC;
				}
			}
		}
	}
	SETTOP(r4_n - 0x02);
	struct Eq_n * r4_n = t0000.w0028;
	if (r4_n > r5_n + 1)
	{
		g_ptr5426 = r4_n - 0xB2;
		cu16 r4_n = r4_n - 0xB2 - g_w53E8;
		sp_n->wFFFFFFE6 = r4_n & ~0x01;
		cui16 r2_n = g_w53EC;
		if (r2_n == 0x00)
			goto l0372;
		cui16 r4_n = (r4_n & ~0x01) - r2_n;
		sp_n->wFFFFFFE4 = r4_n;
		cu16 r4_n = r4_n & ~0x01;
		do
		{
			r4_n -= 0x20;
			--r2_n;
		} while (r2_n != 0x00);
		sp_n->wFFFFFFE2 = r4_n;
		sp_n->wFFFFFFE0 = r4_n - 0x38;
		if (r4_n - 0x38 > r5_n + 1)
		{
			struct Eq_n * r2_n = r4_n;
			do
			{
				r2_n -= 0x02;
				r2_n->w0000 = 0x00;
			} while (r2_n > r4_n - 0x38);
			r4_n->bFFFFFFC2 = 0x00;
			r4_n->bFFFFFFC3 = 0x00;
			r4_n->wFFFFFF56 = sp_n->wFFFFFFE0;
			r4_n->wFFFFFF54 = sp_n->wFFFFFFE2;
			r4_n->wFFFFFF52 = sp_n->wFFFFFFE4;
			r4_n->wFFFFFF50 = sp_n->wFFFFFFE6;
			r4_n->wFFFFFFC4 = sp_n->wFFFFFFEA;
			r4_n->wFFFFFFC6 = sp_n->wFFFFFFEC;
			r4_n->wFFFFFF58 = r4_n - 0x38;
			r4_n->wFFFFFF5A = r5_n + 1;
			if (r4_n - 0x38 > r5_n + 1)
			{
				if (g_ptr1DAA != null)
				{
					FnSubfn(&g_t03B8);
					if (false && (sp_n->wFFFFFFE8 >= g_w53EA && r4_n - 0x38 <= t0000.w0022 + 0x1000))
						goto l0372;
				}
				r4_n->wFFFFFF5E = 0x8000;
				r4_n->ptrFFFFFF9E = r4_n - 0xB2;
				r4_n->ptrFFFFFF9E += 0x22;
				r4_n->ptrFFFFFFB8 = sp_n->ptrFFFFFFFC;
				struct Eq_n * v57_n = sp_n->ptrFFFFFFFE;
				r4_n->ptrFFFFFFB6 = v57_n;
				struct Eq_n * v58_n = v57_n->ptr0000;
				r4_n->wFFFFFFCA = v58_n->w0000;
				r4_n->wFFFFFFC8 = v58_n->w0002;
				t0000.w0020 = 0x0202;
				t0000.w0024 |= 0x2000;
				fn1CFA();
				if (r4_n->bFFFFFFC3 == 0x00)
				{
					sp_n->ptrFFFFFFFE = &g_t1396;
					v57_n->ptr0002();
					return;
				}
				else
				{
					v57_n->ptr0002();
					return;
				}
			}
		}
	}
l0372:
	PRINT(&g_b0397);
	t0000.b002B |= 0x08;
	EXIT(&g_b0397);
}

struct Eq_n g_t1DB2 = // 1DB2
	{
		&g_t47FE,
		&g_t15FF,
	};
word16 g_w1DC4 = 0x3660; // 1DC4
// 243A: void fn243A(Register (ptr16 word16) r5)
void fn243A(word16 * r5)
{
	fn0EF8(&g_t243E, r5);
}

struct Eq_n g_t243E = // 243E
	{
		&g_t4968,
		&g_t15FF,
	};
// 2B90: void fn2B90(Register (ptr16 word16) r5)
void fn2B90(word16 * r5)
{
	fn0EF8(&g_t2B94, r5);
}

struct Eq_n g_t2B94 = // 2B94
	{
		&g_t4DAA,
		&g_t15FF,
	};
// 2E20: void fn2E20(Register (ptr16 word16) r5)
void fn2E20(word16 * r5)
{
	fn0EF8(&g_t2E24, r5);
}

struct Eq_n g_t2E24 = // 2E24
	{
		&g_t507E,
		&g_t15FF,
	};
// 2EC4: void fn2EC4(Register (ptr16 word16) r5)
void fn2EC4(word16 * r5)
{
	fn0EF8(&g_t2EC8, r5);
}

struct Eq_n g_t2EC8 = // 2EC8
	{
		&g_t50B2,
		&g_t15FF,
	};
// 3220: void fn3220(Register (ptr16 word16) r5)
void fn3220(word16 * r5)
{
	fn0EF8(&g_t3224, r5);
}

struct Eq_n g_t3224 = // 3224
	{
		&g_t512C,
		&g_t15FF,
	};
// 34AC: void fn34AC(Register (ptr16 word16) r5)
void fn34AC(word16 * r5)
{
	fn0EF8(&g_t34B0, r5);
}

struct Eq_n g_t34B0 = // 34B0
	{
		&g_t517E,
		&g_t15FF,
	};
// 395C: void fn395C(Register (ptr16 word16) r5)
void fn395C(word16 * r5)
{
	fn0EF8(&g_t3960, r5);
}

struct Eq_n g_t3960 = // 3960
	{
		&g_t51DC,
		&g_t15FF,
	};
// 3B3C: void fn3B3C(Register (ptr16 word16) r5)
void fn3B3C(word16 * r5)
{
	fn0EF8(&g_t3B40, r5);
}

struct Eq_n g_t3B40 = // 3B40
	{
		&g_t526E,
		&g_t15FF,
	};
// 3B42: void fn3B42(Stack (ptr16 Eq_n) wArg00)
// Called from:
//      fn3B3C
void fn3B42(struct Eq_n * wArg00)
{
	<anonymous> ** r4_n;
	*g_ptr5426 = 0x07;
	<anonymous> * wLoc0A;
	if (g_w5788 != 0x01)
	{
		*g_ptr5426 = 0x09;
		ci16 r1_n;
		word16 r5_n;
		g_t578C.u0 = (struct Eq_n *) fn0F48(&g_t529C, out r1_n, out r5_n);
		g_w578E = r1_n;
		++*g_ptr5426;
		fn0E0E(wLoc0A, 0x407D, 0x70A4, g_w578A, g_t578C.u0);
		struct Eq_n * V_n = (struct Eq_n *) <invalid>;
		struct Eq_n * N_n = (struct Eq_n *) <invalid>;
		struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
		if ((V_n | N_n) == 0x00)
		{
			*g_ptr5426 = 0x0C;
			g_w578A = 0x01;
			++*g_ptr5426;
			sp_n->tFFFFFFFE.u0 = g_t578C.u0;
			sp_n->wFFFFFFFC = g_w578A;
			sp_n->tFFFFFFFA.u0 = 0xB852;
			sp_n->wFFFFFFF8 = 0x407E;
			fn0E0E(sp_n->ptrFFFFFFF6, sp_n->wFFFFFFF8, sp_n->tFFFFFFFA.u0, sp_n->wFFFFFFFC, sp_n->tFFFFFFFE.u0);
			struct Eq_n * V_n = (struct Eq_n *) <invalid>;
			struct Eq_n * N_n = (struct Eq_n *) <invalid>;
			struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
			if ((V_n | N_n) == 0x00)
			{
				*g_ptr5426 = 0x0F;
				g_w5790 = 0x4C;
				++*g_ptr5426;
				g_w5792 = ~0x00;
				++*g_ptr5426;
			}
			else
			{
				*g_ptr5426 = 0x12;
				g_w5790 = 0x04;
				++*g_ptr5426;
				g_w5792 = 0x01;
			}
			*g_ptr5426 = 0x14;
			ci16 r1_n;
			Eq_n r5_n;
			g_t5794.u0 = (struct Eq_n *) fn0F48(&g_t529C, out r1_n, out r5_n);
			g_w5796 = r1_n;
			++*g_ptr5426;
			sp_n->tFFFFFFFE.u0 = g_t5794.u0;
			sp_n->wFFFFFFFC = g_w5792;
			sp_n->tFFFFFFFA.u0 = 0x00;
			sp_n->wFFFFFFF8 = 0x4180;
			fn0670(r5_n, sp_n->ptrFFFFFFF6, sp_n->wFFFFFFF8, sp_n->tFFFFFFFA.u0, sp_n->wFFFFFFFC, sp_n->tFFFFFFFE.u0);
			struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
			g_t5794.u0 = sp_n->t0000.u0;
			g_w5796 = sp_n->w0002;
			++*g_ptr5426;
			word16 r4_n;
			g_w5798 = fn0AAE(&g_t52A2, out r4_n) + 0x13;
			++*g_ptr5426;
			if (g_w5796 >= 0x17)
			{
				++*g_ptr5426;
				g_w5798 = 22;
			}
		}
	}
	*g_ptr5426 = 0x19;
	if (g_w5788 != 0x00)
	{
		*g_ptr5426 = 0x1B;
		g_w578A += g_w5790;
		++*g_ptr5426;
		cui16 r0_n = 0x00;
		if (g_w578E < 0x04)
			r0_n = ~0x00;
		cui16 r1_n = 0x00;
		if (g_w578E > 0x4C)
			r1_n = ~0x00;
		if ((r0_n | r1_n) != 0x00)
		{
			*g_ptr5426 = 0x39;
			g_w57A8 = g_w578E;
			g_w57A8 = g_w57A6 - 0x01;
			fn4230(&g_w52D8);
			++*g_ptr5426;
			g_w578A = 0x00;
			goto l3E0A;
		}
		*g_ptr5426 = 0x1E;
		g_w579E = g_w578E;
		g_w579E = g_w579C - 0x01;
		fn4230(&g_w52A6);
		++*g_ptr5426;
		if (g_w58C0 == 0x00)
			goto l3E0A;
		*g_ptr5426 = 33;
		ci16 r1_n = g_w58BC;
		if (r1_n != g_w578E)
		{
			*g_ptr5426 = 0x23;
			if (r1_n != g_w578E + 0x01)
			{
				*g_ptr5426 = 0x25;
				if (r1_n != g_w578E + 0x02)
				{
					*g_ptr5426 = 0x27;
					goto l3E0A;
				}
			}
		}
		*g_ptr5426 = 0x28;
		if (g_w58BE + 0x01 == g_w5796)
		{
			*g_ptr5426 = 0x2A;
			g_w57A0 = g_w578E;
			g_w57A0 = g_w579E - 0x01;
			fn4230(&g_w52B0);
			++*g_ptr5426;
			g_w57A2 = g_w578E;
			g_w57A2 = g_w57A0 + 0x01;
			fn3F42(&g_w52BA);
			++*g_ptr5426;
			g_w58C0 = 0x00;
			++*g_ptr5426;
			g_w58BE = 0x00;
			++*g_ptr5426;
			g_w58C2 = 0x00;
			++*g_ptr5426;
			ci16 r1_n;
			Eq_n r5_n;
			g_t5794.u0 = (struct Eq_n *) fn0F48(&g_t529C, out r1_n, out r5_n);
			g_w5796 = r1_n;
			++*g_ptr5426;
			Eq_n v158_n;
			v158_n.u0 = g_t5794.u0;
			fn0670(r5_n, wLoc0A, 0x4220, 0x00, g_w5792, v158_n);
			struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
			g_t57A4.u0 = sp_n->t0000.u0;
			g_w57A6 = sp_n->w0002;
			int16 r0_n = fn0AAE(&g_t52C0, out r4_n);
			g_w579A = r0_n *s 0x19 + 0x32;
			++*g_ptr5426;
			fn0FA4(r0_n, wArg00, &g_t5784, 21134, 0x5292);
			fn0AE2(r4_n, v158_n, 22426, &g_t5784);
			fn0EA8(v158_n);
			++*g_ptr5426;
			g_w579C = 0x01;
			g_w57AA = 0x0A;
			ci16 v183_n;
			do
			{
				*g_ptr5426 = 0x33;
				fn4230(&g_w52C4);
				++*g_ptr5426;
				fn4230(&g_w52CE);
				*g_ptr5426 = 0x35;
				v183_n = g_w57A8 - 0x01;
				g_w57AA = v183_n;
			} while (v183_n > 0x00);
			++*g_ptr5426;
			g_w5870 += g_w5798;
			++*g_ptr5426;
			g_w578A = 0x00;
			++*g_ptr5426;
		}
		goto l3E0A;
	}
	else
	{
l3E0A:
		*g_ptr5426 = 0x3B;
	}
}

// 3E12: void fn3E12(Register (ptr16 word16) r5)
void fn3E12(word16 * r5)
{
	fn0EF8(&g_t3E16, r5);
}

struct Eq_n g_t3E16 = // 3E16
	{
		&g_t52E2,
		&g_t15FF,
	};
// 3F42: void fn3F42(Register (ptr16 word16) r5)
// Called from:
//      fn3B42
void fn3F42(word16 * r5)
{
	fn0EF8(&g_t3F46, r5);
}

struct Eq_n g_t3F46 = // 3F46
	{
		&g_t530A,
		&g_t15FF,
	};
// 4030: void fn4030(Register (ptr16 word16) r5)
void fn4030(word16 * r5)
{
	fn0EF8(&g_t4034, r5);
}

struct Eq_n g_t4034 = // 4034
	{
		&g_t5330,
		&g_t15FF,
	};
// 4072: void fn4072(Register (ptr16 word16) r5)
void fn4072(word16 * r5)
{
	fn0EF8(&g_t4076, r5);
}

struct Eq_n g_t4076 = // 4076
	{
		&g_t5344,
		&g_t15FF,
	};
// 413C: void fn413C(Register (ptr16 word16) r5)
void fn413C(word16 * r5)
{
	fn0EF8(&g_t4140, r5);
}

struct Eq_n g_t4140 = // 4140
	{
		&g_t5354,
		&g_t15FF,
	};
// 4180: void fn4180(Register (ptr16 word16) r5)
void fn4180(word16 * r5)
{
	fn0EF8(&g_t4184, r5);
}

struct Eq_n g_t4184 = // 4184
	{
		&g_t5368,
		&g_t15FF,
	};
// 4230: void fn4230(Register (ptr16 word16) r5)
// Called from:
//      fn3B42
void fn4230(word16 * r5)
{
	fn0EF8(&g_t4234, r5);
}

struct Eq_n g_t4234 = // 4234
	{
		&g_t537A,
		&g_t15FF,
	};
// 4534: void fn4534(Register (ptr16 word16) r5)
void fn4534(word16 * r5)
{
	fn0EF8(&g_t4538, r5);
}

struct Eq_n g_t4538 = // 4538
	{
		&g_t53B0,
		&g_t15FF,
	};
// 457C: void fn457C(Register (ptr16 word16) r5)
void fn457C(word16 * r5)
{
	fn0EF8(&g_t4580, r5);
}

struct Eq_n g_t4580 = // 4580
	{
		&g_t53C0,
		&g_t15FF,
	};
// 45C8: void fn45C8(Register (ptr16 word16) r5)
void fn45C8(word16 * r5)
{
	fn0EF8(&g_t45CC, r5);
}

struct Eq_n g_t45CC = // 45CC
	{
		&g_t53D8,
		&g_t15FF,
	};
// 45F6: void fn45F6(Register (ptr16 Eq_n) r0, Register int16 r2, Register Eq_n r3)
// Called from:
//      fn145E
void fn45F6(struct Eq_n * r0, int16 r2, Eq_n r3)
{
	ptr16 fp;
	ui16 r4_n = 0x00;
	int16 r2_n = r2;
	while (true)
	{
		r2_n -= 0x0A;
		if (r2_n < 0x00)
			break;
		++r4_n;
	}
	word16 r2_n = r2_n + 0x0A;
	if (r4_n == 0x00)
	{
l4614:
		r4_n += r2_n;
		r2_n = 65506;
	}
	ui16 r4_n = r4_n + 0x1E;
	r4_n = r4_n * 0x28;
	if (r4_n * 0x28 <= 0x00)
	{
		ui16 r2_n = r0->w0006;
		if (r2_n == 0x00)
		{
			r0->w0006 = r4_n * 0x28;
			struct Eq_n * r1_n = (struct Eq_n *) &g_t47E4;
			while (r1_n->w0000 != 0x00 && r1_n->w0000 != r2)
				++r1_n;
			r2_n = r1_n->wFFFFFFFE;
			r0->w0008 = 10414;
			r0->w000A = r4_n * 0x28;
			r0->w000C = 6460;
		}
		if (r0->w0000 >= 0x00)
			r0->w0000 |= 0x0100;
		Eq_n r0_n = *((word16) r3 + 16);
		Eq_n r1_n;
		r1_n.u0 = 0x00;
		Eq_n C_n;
		C_n.u0 = 0x00;
		Eq_n r0_n = r0_n;
		Eq_n r0_n;
		do
		{
			r1_n = (word16) r1_n + 1;
			if (OVERFLOW<word16>(r1_n))
			{
				__syscall<word16>(~0x7660);
				__syscall<word16>(0x899B);
				__syscall<word16>(0x899C);
				__syscall<word16>(0x899D);
				*((word16) r3 + 16) = r0_n;
				r1_n.u0[0x0000FFFA] = (struct Eq_n) (r1_n.u0[0x0000FFFA] | 0x80);
				r1_n.u0[0x0A] = (struct Eq_n) 0x00;
				r0->w0018 = 0x00;
				ci16 v55_n = r0->w0000 & 0x18;
				r0->w0000 = v55_n;
				if (v55_n != 0x00)
				{
					ci16 v56_n = r0->w0000 & 0x10;
					r0->w0000 = v56_n;
					if (v56_n != 0x00)
						goto l473C;
				}
				else
				{
					ci16 v57_n = r0->w0000 & 0x0480;
					r0->w0000 = v57_n;
					if (v57_n != 0x00)
					{
l473C:
						r0->w0000 |= 0x20;
					}
				}
				r0->w0000 |= 0x0800;
				return;
			}
			r0_n = __rcr<word16,byte>(r0_n, 0x01, C_n);
			C_n = (r0_n & 0x01) != 0x00;
			r0_n = r0_n;
		} while ((r0_n & 0x01) != 0x00);
		r0->b0011 = (byte) r1_n;
		--r0->b0011;
		Eq_n C_n;
		C_n.u0 = 0x01;
		do
		{
			r0_n = __rcl<word16,byte>(r0_n, 0x01, C_n);
			C_n = (r0_n & 0x8000) != 0x00;
			--r1_n;
		} while (r1_n != 0x00);
		*((word16) r3 + 16) = r0_n;
		fn13FE();
		word16 r4_n = (word16) *((word16) r3 + 80);
		cup16 r5_n = t0000.w0026;
		if (r5_n != 0x00 && r5_n > 14158)
		{
			word16 * r5_n = &g_w47E0;
			if (t0000.w0026 < 0x47E0)
			{
				word16 * sp_n = fp - 0x0E;
				do
				{
					r5_n -= 0x02;
					sp_n -= 0x02;
					*sp_n = *r5_n;
				} while (r5_n > g_a474C);
			}
		}
		// This indirect jump appears to use the range [-1,1], which Reko can't deduce. This is a typical place where a user annotation (indicating the range of valid values) would help.
		ui16 r4_n;
		(*((char *) g_a46C4 + r4_n * 0x02))();
		return;
	}
	goto l4614;
}

<anonymous> * g_a46C4[] = // 46C4
	{
	};
// 474C: Register (ptr16 Eq_n) fn474C(Register (ptr16 Eq_n) r1, Register word16 r2, Register (ptr16 Eq_n) r3, Register (ptr16 Eq_n) r4, Register out word16 r4Out)
// Called from:
//      fn45F6
struct Eq_n * fn474C(struct Eq_n * r1, word16 r2, struct Eq_n * r3, struct Eq_n * r4, word16 & r4Out)
{
	ptr16 fp;
	LOCK();
	ptr16 sp_n = fp - 0x02;
	ptr16 r0_n = r3->ptr0008;
	if (r0_n != null)
	{
		QSET(r0_n, 0x04);
		r3->ptr0008 = null;
		sp_n = fp - 0x04;
	}
	struct Eq_n * sp_n = sp_n - 0x02;
	sp_n->ptr0000 = r4;
	struct Eq_n * r0_n = r1;
	if (!DSTAT(sp_n->ptr0000, r1))
	{
		r1->w0000 = r2;
		sp_n->ptrFFFFFFFE = r4;
		sp_n -= 0x02;
		if (DSTAT(sp_n->ptrFFFFFFFE, r1))
			goto l47DC;
	}
	if (r4->b0000 != 0x04)
	{
		word16 v19_n = r4->w0002;
		if (r4->w0004 == 0x00)
		{
			r3->ptr000A -= v19_n;
			if (r3->ptr000A <= r3->ptr000C)
			{
l47D8:
				sp_n->ptr0000 = &sp_n->ptr0000->b0000 + 1;
l47DA:
				sp_n->ptr0000 = &sp_n->ptr0000->b0000 + 1;
l47DC:
				UNLOCK();
				r4Out = 0x00;
				return r0_n;
			}
			sp_n -= 0x02;
			sp_n->ptr0000 = r3->ptr000A;
			if (FETCH(sp_n->ptr0000, r1, out r0_n))
				goto l47DC;
		}
		while (true)
		{
			struct Eq_n * sp_n = sp_n - 0x02;
			sp_n->w0000 = 0x00;
			cui16 v29_n = r1->wFFFA & 0x0100;
			r1->wFFFA = v29_n;
			cui16 r0_n = 0x0100;
			if (v29_n == 0x00)
			{
				sp_n->wFFFFFFFE = r1->w0012;
				sp_n -= 0x02;
				r0_n = 0x0200;
			}
			struct Eq_n * sp_n = sp_n - 0x02;
			sp_n->ptr0000 = r1;
			sp_n->wFFFFFFFE = r0_n | (r1->t000B).u1;
			r0_n = sp_n - 0x02;
			if (FnSubfn(sp_n - 0x02))
				break;
			cui16 v34_n = r1->w0016 & 0x04;
			r1->w0016 = v34_n;
			if (v34_n == 0x00)
				goto l47DA;
			r1->wFFFA &= ~0x0100;
			r1->w0016 &= ~0x04;
		}
		sp_n->ptr0000 = &sp_n->ptr0000->b0000 + 1;
	}
	sp_n->ptr0000 = &sp_n->ptr0000->b0000 + 1;
	goto l47D8;
}

word16 g_w47E0 = 0x87; // 47E0
Eq_n g_a47E2[] = // 47E2
	{
	};
struct Eq_n g_t47E4 = // 47E4
	{
		0x05,
	};
Eq_n g_t47FE = // 47FE
	{
		0xB109,
		14988,
	};
Eq_n g_t4968 = // 4968
	{
		0x4B,
		0x01,
		&g_w5506,
	};
Eq_n g_t4DAA = // 4DAA
	{
		0x3A,
		0x00,
		&g_w56B2,
	};
Eq_n g_t507E = // 507E
	{
		0x12,
		0x01,
		&g_w56C4,
	};
Eq_n g_t50B2 = // 50B2
	{
		0x0C,
		0x00,
		&g_w56DE,
	};
Eq_n g_t512C = // 512C
	{
		0x46,
		0x01,
		&g_w56FE,
	};
Eq_n g_t517E = // 517E
	{
		0x0E,
		0x02,
		&g_w571E,
	};
Eq_n g_t51DC = // 51DC
	{
		0x19,
		0x00,
		&g_w575A,
	};
Eq_n g_t526E = // 526E
	{
		0x55,
		0x00,
		&g_w5784,
	};
Eq_n g_t529C = // 529C
	{
		0x02,
		&g_t58B6,
		&g_w58B8,
	};
Eq_n g_t52A2 = // 52A2
	{
		&g_t5794,
	};
word16 g_w52A6 = 0x04; // 52A6
word16 g_w52B0 = 0x04; // 52B0
word16 g_w52BA = 0x02; // 52BA
Eq_n g_t52C0 = // 52C0
	{
		&g_t57A4,
	};
word16 g_w52C4 = 0x04; // 52C4
word16 g_w52CE = 0x04; // 52CE
word16 g_w52D8 = 0x04; // 52D8
Eq_n g_t52E2 = // 52E2
	{
		0x78,
		0x00,
		&g_w57AC,
	};
Eq_n g_t530A = // 530A
	{
		0x23,
		0x02,
		&g_w57C0,
	};
Eq_n g_t5330 = // 5330
	{
		0x14,
		0x00,
		&g_w57D4,
	};
Eq_n g_t5344 = // 5344
	{
		0x66,
		0x02,
		&g_w57D8,
	};
Eq_n g_t5354 = // 5354
	{
		0x2E,
		0x01,
		&g_w57E4,
	};
Eq_n g_t5368 = // 5368
	{
		0x70,
		0x00,
		&g_w57E8,
	};
Eq_n g_t537A = // 537A
	{
		0x66,
		0x04,
		&g_w5808,
	};
Eq_n g_t53B0 = // 53B0
	{
		0x60,
		0x02,
		&g_w5864,
	};
Eq_n g_t53C0 = // 53C0
	{
		0x8C,
		0x00,
		&g_w586E,
	};
Eq_n g_t53D8 = // 53D8
	{
		0x8C,
		0x00,
		&g_w5874,
	};
cup16 g_w53E8 = 22644; // 53E8
cup16 g_w53EA = 0x88; // 53EA
cui16 g_w53EC = 0x00; // 53EC
<anonymous> * g_ptr53F0 = &g_t11EC; // 53F0
<anonymous> * g_ptr5414 = &g_t11EC; // 5414
uint16 g_a541C[] = // 541C
	{
	};
Eq_n g_t5424 = // 5424
	{
		&g_t542C
	};
ci16 * g_ptr5426 = null; // 5426
word16 g_w542C = 0x00; // 542C
word16 g_w5506 = 0x00; // 5506
word16 g_w56B2 = 0x00; // 56B2
word16 g_w56C4 = 0x00; // 56C4
word16 g_w56DE = 0x00; // 56DE
word16 g_w56FE = 0x00; // 56FE
word16 g_w571E = 0x00; // 571E
word16 g_w575A = 0x00; // 575A
Eq_n g_t5784 = // 5784
	{
		'\0',
	};
word16 g_w5788 = 0x00; // 5788
cui16 g_w578A = 0x00; // 578A
Eq_n g_t578C = // 578C
	{
		null
	};
ci16 g_w578E = 0x00; // 578E
word16 g_w5790 = 0x00; // 5790
cui16 g_w5792 = 0x00; // 5792
Eq_n g_t5794 = // 5794
	{
		null
	};
ci16 g_w5796 = 0x00; // 5796
word16 g_w5798 = 0x00; // 5798
int16 g_w579A = 0; // 579A
word16 g_w579C = 0x00; // 579C
ci16 g_w579E = 0x00; // 579E
ci16 g_w57A0 = 0x00; // 57A0
ci16 g_w57A2 = 0x00; // 57A2
Eq_n g_t57A4 = // 57A4
	{
		null
	};
ci16 g_w57A6 = 0x00; // 57A6
ci16 g_w57A8 = 0x00; // 57A8
ci16 g_w57AA = 0x00; // 57AA
word16 g_w57AC = 0x00; // 57AC
word16 g_w57C0 = 0x00; // 57C0
word16 g_w57D4 = 0x00; // 57D4
word16 g_w57D8 = 0x00; // 57D8
word16 g_w57E4 = 0x00; // 57E4
word16 g_w57E8 = 0x00; // 57E8
word16 g_w5808 = 0x00; // 5808
word16 g_w5864 = 0x00; // 5864
word16 g_w586E = 0x00; // 586E
word16 g_w5870 = 0x00; // 5870
word16 g_w5874 = 0x00; // 5874
Eq_n g_t58B6 = // 58B6
	{
		null
	};
ui16 g_w58B8 = 0x00; // 58B8
ci16 g_w58BC = 0x00; // 58BC
word16 g_w58BE = 0x00; // 58BE
word16 g_w58C0 = 0x00; // 58C0
word16 g_w58C2 = 0x00; // 58C2
// 5A90: void fn5A90()
void fn5A90()
{
	t0000.w0024 |= 0x5040;
	word16 r0_n;
	TTYIN(out r0_n);
}

