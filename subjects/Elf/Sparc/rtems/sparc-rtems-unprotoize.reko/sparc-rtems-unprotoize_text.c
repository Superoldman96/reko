// sparc-rtems-unprotoize_text.c
// Generated by decompiling sparc-rtems-unprotoize
// using Reko decompiler version 0.12.2.0.

#include "sparc-rtems-unprotoize.h"

// 00011498: void _start(Register (ptr32 Eq_n) g1, Register word32 o3, Register word32 o4, Register word32 o5, Register word32 o7, Stack int32 dwArg40, Stack Eq_n tArg44)
void _start(void (* g1)(), word32 o3, word32 o4, word32 o5, word32 o7, int32 dwArg40, Eq_n tArg44)
{
	if (g1 == null)
	{
		atexit(&g_t16EE4);
		_init(o3, o4, o5, o7);
		_environ = (char *) &tArg44 + ((dwArg40 << 0x02) + 0x04);
		exit(main(dwArg40, &tArg44));
	}
	else
		atexit(g1);
}

// 0001150C: Register word32 fn0001150C(Register word32 o7, Register word32 l7)
// Called from:
//      __do_global_dtors_aux
//      frame_dummy
word32 fn0001150C(word32 o7, word32 l7)
{
	return o7 + l7;
}

// 00011514: void __do_global_dtors_aux(Register word32 o3, Register word32 o4, Register word32 o5, Register word32 o7)
// Called from:
//      _fini
void __do_global_dtors_aux(word32 o3, word32 o4, word32 o5, word32 o7)
{
	struct Eq_n * l7_n = fn0001150C(o7, 0x00016660);
	if (*l7_n->ptr0008 != 0x00)
		return;
	struct Eq_n ** o2_n = l7_n->ptr0004;
	if (**o2_n != 0x00)
	{
		struct Eq_n * o0_n = (struct Eq_n *) ((char *) *o2_n + 4);
		struct Eq_n ** o2_n = o2_n;
		while (true)
		{
			*o2_n = (struct Eq_n **) o0_n;
			<anonymous> * o1_n = o0_n->ptrFFFFFFFC;
			o1_n();
			struct Eq_n * o0_n = (struct Eq_n *) *o2_n;
			if (o0_n->dw0000 == 0x00)
				break;
			o0_n = &o0_n->dw0000 + 1;
		}
	}
	if (l7_n->dw001C == 0x00)
		*l7_n->ptr0008 = 0x01;
	else
		__deregister_frame_info(l7_n->dw000C, 0x0C);
}

// 000115CC: void fini_dummy()
void fini_dummy()
{
}

// 000115D8: void frame_dummy(Register word32 o7)
// Called from:
//      _init
void frame_dummy(word32 o7)
{
	struct Eq_n * l7_n = fn0001150C(o7, 0x0001659C);
	if (l7_n->dw0018 == 0x00)
		return;
	__register_frame_info(l7_n->dw000C, 0x0C, l7_n->dw0010, 0x00, 0x10);
}

// 00011620: void init_dummy()
void init_dummy()
{
}

// 0001162C: void notice(Register (ptr32 char) o0, Register Eq_n o1, Stack word32 dwArg48)
// Called from:
//      xmalloc
//      xrealloc
//      fancy_abort
//      safe_write
//      usage
//      abspath
//      find_file
//      aux_info_corrupted
//      save_def_or_dec
//      gen_aux_info_file
//      process_aux_info_file
//      declare_source_confusing
//      edit_fn_declaration
//      edit_formals_lists
//      edit_fn_definition
//      scan_for_missed_items
//      edit_file
//      main
void notice(char * o0, Eq_n o1, word32 dwArg48)
{
	dwArg48 = (word32) o1;
	vfprintf(&g_t2B640, o0, &dwArg48);
}

// 00011660: Register (ptr32 char) xstrerror(Register (ptr32 char) o0)
// Called from:
//      safe_write
//      find_file
//      gen_aux_info_file
//      process_aux_info_file
//      main
//      pexecute
char * xstrerror(char * o0)
{
	return strerror(o0);
}

// 00011674: Register Eq_n xmalloc(Register Eq_n o0)
// Called from:
//      savestring
//      savestring2
//      dupnstr
//      string_list_cons
//      lookup
//      unexpand_if_needed
//      shortpath
//      find_file
//      save_def_or_dec
//      munge_compile_params
//      process_aux_info_file
//      main
//      getpwd
//      choose_temp_base
//      make_temp_file
Eq_n xmalloc(Eq_n o0)
{
	Eq_n o0_n = malloc(o0);
	if (o0_n != 0x00)
		return o0_n;
	word32 dwLoc28;
	notice("\n%s: virtual memory exceeded\n", g_t28150.u0, dwLoc28);
	exit(33);
}

// 000116B0: Register Eq_n xrealloc(Register Eq_n o0, Register Eq_n o1)
// Called from:
//      unexpand_if_needed
//      output_bytes
Eq_n xrealloc(Eq_n o0, Eq_n o1)
{
	Eq_n o0_n;
	bool v33_n;
	if (o0 != 0x00)
	{
		o0_n = realloc(o0, o1);
		v33_n = o0_n != 0x00;
	}
	else
	{
		o0_n = malloc(o1);
		v33_n = o0_n != 0x00;
	}
	if (v33_n)
		return o0_n;
	word32 dwLoc28;
	notice("\n%s: virtual memory exceeded\n", g_t28150.u0, dwLoc28);
	exit(33);
}

// 00011708: void xfree(Register (ptr32 Eq_n) o0)
// Called from:
//      free_def_dec
void xfree(struct Eq_n * o0)
{
	if (o0 == null)
		return;
	free(o0);
}

// 00011728: Register Eq_n savestring(Register Eq_n o0, Register Eq_n o1)
// Called from:
//      add_symbol
//      unexpand_if_needed
//      abspath
Eq_n savestring(Eq_n o0, Eq_n o1)
{
	Eq_n o0_n = xmalloc((word32) o1 + 1);
	strcpy(o0_n, o0);
	return o0_n;
}

// 0001174C: Register Eq_n savestring2(Register Eq_n o0, Register Eq_n o1, Register (ptr32 char) o2, Register word32 o3)
// Called from:
//      gen_aux_info_file
Eq_n savestring2(Eq_n o0, Eq_n o1, char * o2, word32 o3)
{
	Eq_n o0_n = xmalloc((word32) o1 + o3 + 0x01);
	strcpy(o0_n, o0);
	strcpy(o0_n + o1, o2);
	return o0_n;
}

// 00011780: void fancy_abort()
void fancy_abort()
{
	word32 dwLoc28;
	notice("%s: internal abort\n", g_t28150.u0, dwLoc28);
	exit(33);
}

// 000117A0: Register Eq_n dupnstr(Register Eq_n o0, Register Eq_n o1)
// Called from:
//      save_def_or_dec
//      munge_compile_params
//      edit_formals_lists
Eq_n dupnstr(Eq_n o0, Eq_n o1)
{
	Eq_n o0_n = xmalloc((word32) o1 + 1);
	strncpy(o0_n, o0, o1);
	*(o0_n + o1) = (word32) 0x00;
	return o0_n;
}

// 000117CC: Register (ptr32 int8) substr(Register (ptr32 int8) o0, Register (ptr32 int8) o1)
// Called from:
//      other_variable_style_function
int8 * substr(int8 * o0, int8 * o1)
{
	int32 g2_n = (int32) *o0;
	if (g2_n != 0x00)
	{
		int8 * o3_n = o1;
		int32 g3_n = (int32) *o1;
		if (g3_n == 0x00)
			return o0;
		int8 * o2_n = o0;
		while ((int32) *o2_n == g3_n)
		{
			++o3_n;
			g3_n = (int32) *o3_n;
			if (g3_n == 0x00)
			{
				++o0;
				return o0;
			}
			++o2_n;
		}
	}
	else
	{
		o0 = null;
		return o0;
	}
}

// 00011828: Register Eq_n safe_read(Register Eq_n o0, Register Eq_n o1, Register Eq_n o2)
// Called from:
//      process_aux_info_file
Eq_n safe_read(Eq_n o0, Eq_n o1, Eq_n o2)
{
safe_read_entry:
	i1_n = o1
	l0_n = o2
	goto l00011840
l00011828:
l0001183C:
	i1_n.u0 = i1_n + o0_n
l00011840:
	v34_n = l0_n <= 0x00
l00011844:
	branch v34_n l00011848_ds_t
l00011848_ds_f:
	o0_n = read(o0, i1_n, l0_n)
	branch o0_n >= 0x00 l00011860_ds_t
	goto l00011860_ds_f
l0001184C:
l00011860_ds_f:
	o0_n = errno
	branch o0_n == (char *) 0x04 l0001186C_ds_t
	goto l0001186C_ds_f
l00011860_ds_t:
	branch o0_n != 0x00 l00011878_ds_t
l00011864:
l0001186C_ds_f:
	branch l0_n != 0x00 l00011878_ds_t
l0001186C_ds_t:
	v34_n = l0_n <= 0x00
	goto l00011844
l00011870:
l00011874:
l00011878_ds_t:
	l0_n = l0_n - o0_n
	goto l0001183C
l00011878_ds_t:
	l0_n = l0_n - o0_n
	goto l0001183C
l0001187C:
l00011880:
	return o0_n
safe_read_exit:
}

// 00011888: void safe_write(Register int32 o0, Register (ptr32 void) o1, Register Eq_n o2, Register Eq_n o3)
void safe_write(int32 o0, void * o1, Eq_n o2, Eq_n o3)
{
	void * i1_n = o1;
	Eq_n i2_n = o2;
	if (o2 > 0x00)
	{
		do
		{
			Eq_n o0_n = write(o0, i1_n, i2_n);
			if (o0_n < 0x00)
			{
				char * l2_n = errno;
				if (l2_n != (char *) 0x04)
				{
					Eq_n l1_n;
					l1_n.u0 = g_t28150.u0;
					shortpath(0x00, o3);
					xstrerror(l2_n);
					struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
					notice("%s: error writing file `%s': %s\n", l1_n, sp_n->dw0048);
					return;
				}
			}
			else
			{
				i2_n -= o0_n;
				i1_n += o0_n;
			}
		} while (i2_n > 0x00);
	}
}

// 00011914: void save_pointers()
// Called from:
//      edit_fn_declaration
//      edit_fn_definition
void save_pointers()
{
	up32 o1_n = g_dw28210;
	g_t2B280.u0 = g_t281E0.u0;
	g_dw2B290 = o1_n;
}

// 00011938: void restore_pointers()
// Called from:
//      edit_fn_declaration
//      edit_fn_definition
void restore_pointers()
{
	up32 o1_n = g_dw2B290;
	g_t281E0.u0 = g_t2B280.u0;
	g_dw28210 = o1_n;
}

// 0001195C: Register int32 is_id_char(Register int32 o0)
// Called from:
//      unexpand_if_needed
//      save_def_or_dec
//      edit_formals_lists
//      scan_for_missed_items
int32 is_id_char(int32 o0)
{
	int32 g2_n;
	if (((ui32) (o0 & 0xFF)->b2B411 & 0x07) == 0x00)
	{
		g2_n = 0x00;
		if ((o0 & 0xFF) != 0x5F)
		{
			ui32 g0_n = (o0 & 0xFF) - 0x24;
			if (g0_n != 0x00)
				return g2_n;
		}
	}
	g2_n = 0x01;
	return g2_n;
}

// 00011998: void usage()
// Called from:
//      main
void usage()
{
	word32 dwLoc28;
	notice("%s: usage '%s [ -VqfnkN ] [ -i <istring> ] [ filename ... ]'\n", g_t28150.u0, dwLoc28);
	exit(33);
}

// 000119BC: Register Eq_n in_system_include_dir(Register Eq_n o0)
// Called from:
//      edit_file
Eq_n in_system_include_dir(Eq_n o0)
{
	if ((int32) *o0.u0 == 0x2F)
	{
		Eq_n i0_n;
		if (g_ptr27ED0 != null)
		{
			struct Eq_n * l1_n = (struct Eq_n *) &g_ptr27ED0;
			char * l0_n = g_ptr27ED0;
			while (true)
			{
				if (strncmp(o0, l0_n, strlen(l0_n)) == 0x00)
				{
					if ((int32) *(o0 + strlen(l1_n->ptr0000)) == 0x2F)
					{
						i0_n.u0 = 0x01;
						return i0_n;
					}
					++l1_n;
				}
				else
					++l1_n;
				if (l1_n->ptr0000 == 0x00)
					break;
				l0_n = l1_n->ptr0000;
			}
		}
		i0_n.u0 = 0x00;
		return i0_n;
	}
	else
		abort();
}

// 00011A4C: Register (ptr32 Eq_n) needs_to_be_converted(Register (ptr32 Eq_n) o0)
// Called from:
//      edit_file
struct Eq_n * needs_to_be_converted(struct Eq_n * o0)
{
	struct Eq_n * g3_n = o0->ptr0004;
	struct Eq_n * o0_n;
	if (g3_n != null)
	{
		int32 g2_n = (int32) g3_n->b0020;
		while (g2_n == 0x00)
		{
			g3_n = g3_n->ptr0000;
			if (g3_n == null)
			{
				o0_n = null;
				return o0_n;
			}
			g2_n = (int32) g3_n->b0020;
		}
		o0_n = (struct Eq_n *) ~0x00;
	}
	else
		o0_n = null;
	return o0_n;
}

// 00011A88: Register Eq_n directory_specified_p(Register Eq_n o0)
// Called from:
//      edit_file
Eq_n directory_specified_p(Eq_n o0)
{
	struct Eq_n * l1_n = directory_list;
	Eq_n i0_n;
	if (l1_n == null)
	{
		i0_n.u0 = 0x00;
		return i0_n;
	}
	else
	{
		char * l0_n = l1_n->ptr0000;
		while (true)
		{
			if (strncmp(o0, l0_n, strlen(l0_n)) == 0x00)
			{
				if ((int32) *(o0 + strlen(l1_n->ptr0000)) == 0x2F)
				{
					struct Eq_n * o0_n = o0 + strlen(l1_n->ptr0000);
					if ((int32) o0_n->b0001 == 0x00)
					{
l00011B1C:
						i0_n.u0 = 0x01;
						return i0_n;
					}
					int8 * o2_n = &o0_n->b0001;
					bool v32_n = (int32) o0_n->b0001 == 0x2F;
					while (!v32_n)
					{
						++o2_n;
						int32 o0_n = (int32) *o2_n;
						if (o0_n == 0x00)
							goto l00011B1C;
						v32_n = o0_n == 0x2F;
					}
					l1_n = l1_n->ptr0004;
				}
				else
					l1_n = l1_n->ptr0004;
			}
			else
				l1_n = l1_n->ptr0004;
			if (l1_n == null)
			{
				i0_n.u0 = 0x00;
				return i0_n;
			}
			l0_n = l1_n->ptr0000;
		}
	}
}

// 00011B40: Register Eq_n file_excluded_p(Register Eq_n o0)
// Called from:
//      edit_file
Eq_n file_excluded_p(Eq_n o0)
{
	Eq_n o0_n = strlen(o0);
	struct Eq_n * l0_n = exclude_list;
	Eq_n i0_n;
	if (l0_n != null)
	{
		ptr32 l2_n = o0 + o0_n;
		do
		{
			if (strcmp(l2_n - strlen(l0_n->ptr0000), l0_n->ptr0000) == 0x00)
			{
				if ((int32) *((word32) (o0_n - strlen(l0_n->ptr0000) + o0) - 1) == 0x2F)
				{
					i0_n.u0 = 0x01;
					return i0_n;
				}
				l0_n = l0_n->ptr0004;
			}
			else
				l0_n = l0_n->ptr0004;
		} while (l0_n != null);
		i0_n.u0 = 0x00;
	}
	else
		i0_n.u0 = 0x00;
	return i0_n;
}

// 00011BC8: Register Eq_n string_list_cons(Register Eq_n o0, Register Eq_n o1)
// Called from:
//      main
Eq_n string_list_cons(Eq_n o0, Eq_n o1)
{
	Eq_n o0_n = xmalloc(0x08);
	*o0_n = o0;
	*((word32) o0_n + 4) = o1;
	return o0_n;
}

// 00011BE4: void visit_each_hash_node(Register (ptr32 Eq_n) o0)
// Called from:
//      do_processing
void visit_each_hash_node(struct Eq_n * o0)
{
	struct Eq_n * i0_n = o0;
	if (o0 < o0 + 0x0200)
	{
		word32 o0_n = o0->dw0004;
		while (true)
		{
			struct Eq_n * l0_n;
			if (o0_n != 0x00)
			{
				l0_n = i0_n + 1;
				do
				{
					reverse_def_dec_list(i0_n);
					i0_n = i0_n->dw0000;
				} while (i0_n != null);
			}
			else
				l0_n = i0_n + 1;
			i0_n = l0_n;
			if (l0_n >= o0 + 0x0200)
				break;
			o0_n = l0_n->dw0004;
		}
	}
}

// 00011C3C: void add_symbol(Register Eq_n o0, Register Eq_n o1)
// Called from:
//      lookup
void add_symbol(Eq_n o0, Eq_n o1)
{
	o0->u0 = 0x00;
	*((word32) o0 + 4) = savestring(o1, strlen(o1));
	((word32) o0 + 8)->u0 = 0x00;
}

// 00011C6C: Register Eq_n lookup(Register Eq_n o0, Register Eq_n o1)
// Called from:
//      find_file
//      save_def_or_dec
Eq_n lookup(Eq_n o0, Eq_n o1)
{
	ui32 o3_n = 0x00;
	if ((int32) *o1.u0 != 0x00)
	{
		Eq_n o2_n = o1;
		int32 o1_n;
		while (true)
		{
			o2_n.u0 = (word32) o2_n + 1;
			o1_n = (int32) *o2_n.u0;
			if ((int32) *o2_n.u0 == 0x00)
				break;
			o3_n += o1_n;
		}
		o3_n += o1_n;
	}
	ui32 o3_n = o3_n & 0x01FF;
	Eq_n i0_n;
	i0_n.u0 = o0.u0 + o3_n * 0x0C;
	Eq_n o0_n = *((word32) i0_n + 4);
	Eq_n o0_n;
	if (o0_n == 0x00)
		o0_n = i0_n;
	else
	{
		if (strcmp(o0_n, o1) == 0x00)
			return i0_n;
		if (*((word32) o0 + o3_n * 0x0C) != 0x00)
		{
			i0_n = *i0_n;
			while (strcmp(*((word32) i0_n + 4), o1) != 0x00)
			{
				if (*i0_n == 0x00)
					goto l00011D1C;
				i0_n = *i0_n;
			}
			return i0_n;
		}
l00011D1C:
		o0_n = xmalloc(0x0C);
		*i0_n = o0_n;
	}
	add_symbol(o0_n, o1);
	i0_n = o0_n;
	return i0_n;
}

// 00011D3C: void free_def_dec(Register (ptr32 Eq_n) o0)
// Called from:
//      save_def_or_dec
void free_def_dec(struct Eq_n * o0)
{
	xfree(o0->ptr000C);
	xfree(o0);
}

// 00011D58: void unexpand_if_needed(Register (ptr32 Eq_n) o0)
void unexpand_if_needed(struct Eq_n * o0)
{
	struct Eq_n * i0_n = o0;
	word32 i1_n = 0x00;
	if (line_buf.78.u0 == 0x00)
	{
		line_buf_size.79.u0 = 0x0400;
		line_buf.78.u0 = (int8 *) xmalloc(0x0400);
	}
	Eq_n l1_n;
	if ((int32) o0->t0000.u0 == 0x0A)
	{
		l1_n.u0 = line_buf.78.u0;
		goto l00011EC8;
	}
	l1_n.u0 = line_buf.78.u0;
	char * o0_n = (char *) "struct _iobuf";
l00011DA0:
	if (o0_n != null)
	{
		struct Eq_n * l4_n = (struct Eq_n *) &g_ptr16F14;
		char * l0_n = (char *) "struct _iobuf";
		while (true)
		{
			Eq_n o0_n = strlen(l0_n);
			if ((int32) (i0_n->t0000.u0 - *l0_n) == 0x00)
			{
				if (strncmp(i0_n, l0_n, o0_n) == 0x00)
				{
					if (is_id_char((int32) *(i0_n + o0_n)) == 0x00)
					{
						Eq_n o0_n = strlen(l4_n->dw0004);
						Eq_n o1_n;
						o1_n.u0 = line_buf.78.u0;
						Eq_n o2_n;
						o2_n.u0 = line_buf_size.79.u0;
						i1_n = 0x01;
						if (l1_n + o0_n - o1_n >= o2_n)
						{
							Eq_n o2_n = (word32) o0_n + (o2_n << 0x01);
							line_buf_size.79.u0 = (ptr32) o2_n;
							Eq_n o0_n = xrealloc(o1_n, o2_n);
							line_buf.78.u0 = (int8 *) o0_n;
							l1_n.u0 = o0_n + (l1_n - o1_n);
						}
						strcpy(l1_n, l4_n->dw0004);
						l1_n.u0 = l1_n + o0_n;
						i0_n += o0_n;
						goto l00011EB8;
					}
					++l4_n;
				}
				else
					++l4_n;
			}
			else
				++l4_n;
			if (l4_n->dw0000 == 0x00)
				break;
			l0_n = l4_n->dw0000;
		}
	}
	Eq_n o1_n;
	o1_n.u0 = line_buf.78.u0;
	Eq_n l0_n = l1_n - o1_n;
	ui32 o0_n;
	if (l0_n == line_buf_size.79.u0)
	{
		line_buf_size.79.u0 = (ptr32) (l0_n << 0x01);
		Eq_n o0_n = xrealloc(o1_n, l0_n << 0x01);
		line_buf.78.u0 = (int8 *) o0_n;
		l1_n.u0 = o0_n + l0_n;
		o0_n = (ui32) i0_n->t0000.u0;
	}
	else
		o0_n = (ui32) i0_n->t0000.u0;
	*l1_n.u0 = (byte) o0_n;
	++i0_n;
	l1_n.u0 = l1_n + (char *) 0x01;
l00011EB8:
	if ((int32) i0_n->t0000.u0 == 0x0A)
	{
l00011EC8:
		Eq_n o2_n;
		o2_n.u0 = line_buf.78.u0;
		Eq_n o1_n;
		o1_n.u0 = line_buf_size.79.u0;
		if (l1_n - ((word32) o2_n - 2) >= o1_n)
		{
			line_buf_size.79.u0 = (ptr32) (o1_n << 0x01);
			Eq_n o0_n = xrealloc(o2_n, o1_n << 0x01);
			line_buf.78.u0 = (int8 *) o0_n;
			l1_n.u0 = o0_n + (l1_n - o2_n);
		}
		*l1_n.u0 = 0x0A;
		size_t l1_n = (Eq_n) (l1_n + (char *) 0x01);
		if (i1_n == 0x00)
			*l1_n = (Eq_n) 0x00;
		else
		{
			*l1_n = (Eq_n) 0x00;
			Eq_n o0_n;
			o0_n.u0 = line_buf.78.u0;
			savestring(o0_n, l1_n - o0_n);
		}
		return;
	}
	o0_n = (char *) "struct _iobuf";
	goto l00011DA0;
}

// 00011F34: Register Eq_n abspath(Register Eq_n o0, Register Eq_n o1, Register out word32 l0Out, Register out (ptr32 Eq_n) l2Out, Register out (ptr32 Eq_n) l3Out, Register out (ptr32 Eq_n) l4Out, Register out (ptr32 Eq_n) l7Out, Register out word32 i1Out, Register out (ptr32 Eq_n) i6Out)
// Called from:
//      shortpath
//      referenced_file_is_newer
//      save_def_or_dec
//      main
Eq_n abspath(Eq_n o0, Eq_n o1, word32 & l0Out, struct Eq_n & l2Out, struct Eq_n & l3Out, struct Eq_n & l4Out, struct Eq_n & l7Out, word32 & i1Out, struct Eq_n & i6Out)
{
	ptr32 fp;
	Eq_n i0_n = o0;
	if (o0 == 0x00)
		i0_n.u0 = g_t2B270.u0;
	struct Eq_n * sp_n = fp + ~0x6F - ((strlen(i0_n) + strlen(o1)) + 0x09 & ~0x07);
	struct Eq_n * o2_n;
	if ((int32) *o1.u0 != 0x2F)
	{
		ui32 o1_n = (ui32) *i0_n.u0;
		sp_n->b0060 = (byte) o1_n;
		o2_n = (struct Eq_n *) &sp_n->b0061;
		if (o1_n << 0x18 != 0x00)
		{
			byte * i0_n = (word32) i0_n + 1;
			while (true)
			{
				ui32 o0_n = (ui32) *i0_n;
				o2_n->b0000 = (byte) o0_n;
				++i0_n;
				if (o0_n << 0x18 == 0x00)
					break;
				++o2_n;
			}
			++o2_n;
		}
		o2_n->bFFFFFFFF = 0x2F;
	}
	else
		o2_n = (struct Eq_n *) &sp_n->b0060;
	ui32 o0_n = (ui32) *o1.u0;
	o2_n->b0000 = (byte) o0_n;
	byte * i0_n = (word32) o1 + 1;
	byte * o2_n = (byte *) (o2_n + 1);
	if (o0_n << 0x18 != 0x00)
	{
		while (true)
		{
			ui32 o0_n = (ui32) *i0_n;
			*o2_n = (byte) o0_n;
			++i0_n;
			if (o0_n << 0x18 == 0x00)
				break;
			++o2_n;
		}
	}
	struct Eq_n * o2_n = (struct Eq_n *) &sp_n->b0061;
	if ((int32) sp_n->b0061 != 0x00)
	{
		struct Eq_n * o1_n = (struct Eq_n *) &sp_n->b0061;
		bool v36_n = (int32) sp_n->b0061 != 0x2F;
l00012024:
		bool v39_n;
		if (!v36_n)
		{
			ui32 o3_n = (ui32) o1_n->b0000;
			if ((int32) o2_n->bFFFFFFFF == 0x2F)
			{
				o1_n = (struct Eq_n *) &o1_n->b0001;
				goto l00012110;
			}
			v39_n = o3_n != 0x2E;
		}
		else
		{
			ui32 o3_n = (ui32) o1_n->b0000;
			v39_n = o3_n != 0x2E;
		}
		ui32 o0_n;
		if (v39_n)
		{
			o0_n = (ui32) o1_n->b0000;
			goto l00012104;
		}
		if ((int32) o2_n->bFFFFFFFF != 0x2F)
		{
			o0_n = (ui32) o1_n->b0000;
			goto l00012104;
		}
		int32 o0_n = (int32) o1_n->b0001;
		if (o0_n != 0x00)
		{
			if (o0_n == 0x2F)
			{
				o1_n = (struct Eq_n *) &o1_n->b0002;
				goto l00012110;
			}
			if (o0_n == 0x2E)
			{
				int32 o0_n = (int32) o1_n->b0002;
				if (o0_n == 0x00 || o0_n == 0x2F)
				{
					struct Eq_n * o0_n;
					if (o0_n == 0x2F)
						o0_n = o1_n + 1;
					else
						o0_n = (struct Eq_n *) &o1_n->b0002;
					int8 * o2_n = (int8 *) ((char *) o2_n - 2);
					o1_n = o0_n;
					while (o2_n >= &sp_n->b0060 && (int32) (*o2_n) != 0x2F)
						o2_n += -1;
					if (o2_n < &sp_n->b0060)
					{
						notice("%s: invalid file name: %s\n", g_t28150.u0, sp_n->dw0048);
						exit(33);
					}
					o2_n = (struct Eq_n *) (o2_n + 1);
					o2_n->b0000 = 0x00;
l00012110:
					int32 o0_n = (int32) o1_n->b0000;
					if (o0_n == 0x00)
						goto l00012120;
					v36_n = o0_n != 0x2F;
					goto l00012024;
				}
				o0_n = (ui32) o1_n->b0000;
			}
			else
				o0_n = (ui32) o1_n->b0000;
l00012104:
			o2_n->b0000 = (byte) o0_n;
			o1_n = (struct Eq_n *) &o1_n->b0001;
			++o2_n;
			goto l00012110;
		}
	}
l00012120:
	if ((int32) o2_n->bFFFFFFFF == 0x2F)
	{
		o2_n->b0000 = 0x00;
		o2_n = (struct Eq_n *) &o2_n->bFFFFFFFF;
		o2_n->b0000 = 0x00;
	}
	else
		o2_n->b0000 = 0x00;
	Eq_n o0_n = savestring(&sp_n->b0060, o2_n - &sp_n->b0060);
	word32 i1_n = sp_n->dw0004;
	struct Eq_n * i6_n = sp_n->ptr0018;
	struct Eq_n * l2_n = sp_n->ptr0028;
	struct Eq_n * l3_n = sp_n->ptr002C;
	struct Eq_n * l4_n = sp_n->ptr0030;
	struct Eq_n * l7_n = sp_n->ptr003C;
	l0Out = sp_n->dw0020;
	l2Out = l2_n;
	l3Out = l3_n;
	l4Out = l4_n;
	l7Out = l7_n;
	i1Out = i1_n;
	i6Out = i6_n;
	return o0_n;
}

// 0001214C: Register Eq_n shortpath(Register Eq_n o0, Register Eq_n o1)
// Called from:
//      safe_write
//      find_file
//      gen_aux_info_file
//      process_aux_info_file
//      declare_source_confusing
//      edit_formals_lists
//      edit_fn_definition
//      scan_for_missed_items
//      edit_file
//      main
Eq_n shortpath(Eq_n o0, Eq_n o1)
{
	word32 i6_n;
	Eq_n i1_n;
	word32 l7_n;
	word32 l4_n;
	Eq_n l3_n;
	ui32 l2_n;
	int8 * l0_n;
	strlen(o1);
	Eq_n i0_n = abspath(o0, o1, out l0_n, out l2_n, out l3_n, out l4_n, out l7_n, out i1_n, out i6_n);
	Eq_n o0_n = xmalloc(l3_n);
	int32 o1_n = (int32) *l0_n;
	int32 o0_n;
	while (o1_n != 0x00)
	{
		if (o1_n != (int32) (*i0_n.u0))
		{
			o0_n = (int32) *l0_n;
			goto l000121B8;
		}
		++l0_n;
		o1_n = (int32) *l0_n;
		i0_n.u0 = (word32) i0_n + 1;
	}
	o0_n = (int32) *l0_n;
l000121B8:
	Eq_n i0_n;
	bool v36_n;
	if (o0_n == 0x00)
	{
		ui32 o1_n = (ui32) *i0_n.u0;
		int32 o0_n = (int32) (byte) o1_n;
		if (o0_n == 0x00 || o0_n == 0x2F)
		{
			if (o0_n == 0x00)
				i0_n.u0 = 0x00017168;
			else
				i0_n.u0 = (word32) i0_n + 1;
			return i0_n;
		}
		v36_n = o1_n == 0x00;
	}
	else
	{
		ui32 o1_n = (ui32) *i0_n.u0;
		v36_n = o1_n == 0x00;
	}
	int32 o0_n;
	if (!v36_n)
	{
		while (true)
		{
			l0_n += -1;
			if ((int32) *l0_n == 0x2F)
				break;
			i0_n.u0 = (word32) i0_n - 1;
		}
		ptr32 i0_n = (word32) i0_n - 1;
		++l0_n;
		i0_n = i0_n + 0x01;
		l2_n = 0x01;
l00012238:
		o0_n = (int32) *l0_n;
	}
	else
		o0_n = (int32) *l0_n;
	Eq_n l1_n = o0_n;
	Mem159 = Mem35;
	if (o0_n == 0x00)
	{
		if ((word32) strlen(i0_n) + l2_n * 0x03 < l3_n)
		{
			ui32 l2_n = l2_n + ~0x00;
			Eq_n o3_n;
			if (l2_n == ~0x00)
			{
				o3_n.u0 = o0_n + l3_n;
l000122B8:
				while (o3_n > l1_n)
				{
					ui32 o0_n = (ui32) *i0_n.u0;
					*l1_n.u0 = (byte) o0_n;
					i0_n.u0 = (word32) i0_n + 1;
					if (o0_n << 0x18 == 0x00)
					{
						struct Eq_n * l1_n = (word32) l1_n + 1;
						if ((int32) l1_n->bFFFFFFFE == 0x2F)
							l1_n->bFFFFFFFE = 0x00;
						i0_n = o0_n;
						return i0_n;
					}
					l1_n.u0 = (word32) l1_n + 1;
				}
				i0_n = i1_n;
				return i0_n;
			}
			o3_n.u0 = o0_n + l3_n;
			while (o3_n > (word32) l1_n + 3)
			{
				l2_n += ~0x00;
				*l1_n.u0 = 0x2E;
				struct Eq_n * l1_n = (word32) l1_n + 1;
				l1_n->b0000 = 0x2E;
				l1_n->b0001 = 0x2F;
				if (l2_n == ~0x00)
				{
					l1_n.u0 = &l1_n->b0001 + 1;
					goto l000122B8;
				}
				l1_n.u0 = &l1_n->b0001 + 1;
			}
		}
		i0_n = i1_n;
		return i0_n;
	}
	ui32 o1_n = (ui32) *l0_n;
	if (o1_n == 0x2F)
	{
		++l0_n;
		++l2_n;
	}
	else
		++l0_n;
	goto l00012238;
}

// 00012304: Register Eq_n find_file(Register Eq_n o0, Register word32 o1, Register out word32 l2Out, Register out word32 l3Out, Register out (ptr32 char) i0Out, Register out word32 i1Out)
// Called from:
//      referenced_file_is_newer
//      save_def_or_dec
Eq_n find_file(Eq_n o0, word32 o1, word32 & l2Out, word32 & l3Out, char & i0Out, word32 & i1Out)
{
	word32 dwLoc98;
	ptr32 fp;
	struct Eq_n * o0_n = lookup(164416, o0);
	struct Eq_n * sp_n = fp + ~0xF7;
	Eq_n i0_n;
	i0_n.u0 = o0_n->t0008.u0;
	if (i0_n != 0x00)
	{
l000123C8:
		char * i0_n = sp_n->ptr0000;
		word32 i1_n = sp_n->dw0004;
		word32 l3_n = sp_n->dw002C;
		l2Out = sp_n->dw0028;
		l3Out = l3_n;
		i0Out = i0_n;
		i1Out = i1_n;
		return i0_n;
	}
	Eq_n o0_n = xmalloc(0x0C);
	int32 dwLoc58;
	if (o1 != 0x00)
		dwLoc58 = 0x00;
	else
	{
		int32 o0_n = stat(o0, &dwLoc98);
		if (o0_n != ~0x00)
		{
			o0_n->t0008.u0 = (int8 *) o0_n;
l000123B4:
			o0_n->u0 = o0_n;
			((word32) o0_n + 4)->u0 = 0x00;
			((word32) o0_n + 8)->u0 = dwLoc58;
			i0_n = o0_n;
			goto l000123C8;
		}
		char * l2_n = errno;
		Eq_n l3_n;
		l3_n.u0 = g_t28150.u0;
		shortpath(0x00, o0);
		xstrerror(l2_n);
		sp_n = (struct Eq_n *) <invalid>;
		notice("%s: %s: can't get status: %s\n", l3_n, sp_n->dw0048);
		dwLoc58 = o0_n;
	}
	o0_n->t0008.u0 = (int8 *) o0_n;
	goto l000123B4;
}

// 000123D0: void aux_info_corrupted()
// Called from:
//      check_aux_info
void aux_info_corrupted()
{
	word32 dwLoc28;
	notice("\n%s: fatal error: aux info file corrupted at line %d\n", g_t28150.u0, dwLoc28);
	exit(33);
}

// 000123F8: void check_aux_info(Register word32 o0)
// Called from:
//      referenced_file_is_newer
//      save_def_or_dec
void check_aux_info(word32 o0)
{
	if (o0 != 0x00)
		return;
	aux_info_corrupted();
}

// 00012418: Register Eq_n find_corresponding_lparen(Register Eq_n o0)
// Called from:
//      save_def_or_dec
Eq_n find_corresponding_lparen(Eq_n o0)
{
	int8 * o0_n = &o0.u1->bFFFFFFFF + -1;
	word32 g3_n = 0x01;
	int32 g2_n = (int32) o0.u1->bFFFFFFFF;
l00012424:
	if (g2_n != 0x28)
	{
		int32 g0_n = g2_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n = o0_n;
l00012448:
			if (g3_n == 0x00)
				return o0_n + 1;
			g2_n = (int32) *o0_n;
			goto l00012424;
		}
		++g3_n;
	}
	else
		g3_n += ~0x00;
	o0_n += -1;
	goto l00012448;
}

// 0001245C: void referenced_file_is_newer(Register (ptr32 Eq_n) o0)
void referenced_file_is_newer(struct Eq_n * o0)
{
	ptr32 fp;
	check_aux_info(0x01 - (word32) (((int32) o0->b0000 ^ 0x2F) > 0x00));
	check_aux_info(0x01 - (word32) (((int32) o0->b0001 ^ 0x2A) > 0x00));
	check_aux_info(0x01 - (word32) (((int32) o0->b0002 ^ 0x20) > 0x00));
	int8 * l1_n;
	if ((int32) o0->b0003 != 0x3A)
	{
		l1_n = (int8 *) (&o0->b0003 + 1);
		while ((int32) *l1_n != 0x3A)
			l1_n += (int8 *) 0x01;
	}
	else
		l1_n = &o0->b0003;
	int32 l1_n = l1_n - &o0->b0003;
	struct Eq_n * sp_n = fp + ~0x6F - (l1_n + 0x08 & ~0x07);
	strncpy(sp_n->a0060, &o0->b0003, l1_n);
	Eq_n o0_n;
	o0_n.u0 = g_t28190.u0;
	sp_n->a0060[l1_n] = 0x00;
	word32 l0_n;
	word32 l2_n;
	word32 l3_n;
	word32 l4_n;
	word32 l7_n;
	word32 i1_n;
	word32 i6_n;
	word32 l2_n;
	word32 l3_n;
	word32 i0_n;
	int32 i1_n;
	find_file(abspath(o0_n, sp_n->a0060, out l0_n, out l2_n, out l3_n, out l4_n, out l7_n, out i1_n, out i6_n), 0x00, out l2_n, out l3_n, out i0_n, out i1_n).u1->dw0008 > i1_n;
}

// 0001251C: void save_def_or_dec(Register Eq_n o0)
void save_def_or_dec(Eq_n o0)
{
	ptr32 fp;
	xmalloc(44);
	check_aux_info(0x01 - (word32) (((int32) (*o0.u1) ^ 0x2F) > 0x00));
	check_aux_info(0x01 - (word32) (((int32) (o0.u2)[1] ^ 0x2A) > 0x00));
	check_aux_info(0x01 - (word32) (((int32) (o0.u2)[2] ^ 0x20) > 0x00));
	Eq_n i0_n;
	i0_n.u0 = o0 + 0x03;
	if ((int32) o0.u2[3] != 0x3A)
	{
		i0_n.u0 = o0 + 0x04;
		while ((int32) *i0_n.u1 != 0x3A)
			i0_n.u0 = i0_n + 0x01;
	}
	int32 l1_n = i0_n - (o0 + (char *) 0x03);
	struct Eq_n * sp_n = fp + ~0x7F - (l1_n + 0x08 & ~0x07);
	strncpy(sp_n->a0060, o0 + (char *) 0x03, l1_n);
	Eq_n o0_n;
	o0_n.u0 = g_t28190.u0;
	sp_n->a0060[l1_n] = 0x00;
	struct Eq_n * l2_n;
	word32 l0_n;
	word32 l2_n;
	word32 l3_n;
	word32 l4_n;
	word32 l7_n;
	word32 i1_n;
	word32 i6_n;
	union Eq_n * l3_n;
	Eq_n i0_n;
	word32 i1_n;
	l2_n->t0004.u1 = (struct Eq_n *) find_file(abspath(o0_n, sp_n->a0060, out l0_n, out l2_n, out l3_n, out l4_n, out l7_n, out i1_n, out i6_n), i1_n, out l2_n, out l3_n, out i0_n, out i1_n);
	Eq_n i0_n;
	if ((int32) i0_n.u1->t0000.u1 != 0x3A)
	{
		i0_n.u1 = i0_n.u1 + 1;
		while ((int32) i0_n.u1->t0000.u1 != 0x3A)
			i0_n.u0 = i0_n + 0x01;
	}
	else
		i0_n = i0_n;
	int32 l0_n = i0_n - i0_n;
	strncpy(l3_n, i0_n, l0_n);
	(&l3_n->u0)[l0_n] = 0x00;
	l2_n->dw0008 = atoi(l3_n);
	struct Eq_n * i0_n = (struct Eq_n *) (i0_n.u1 + 1);
	ui32 o1_n = (ui32) i0_n->b0000;
	word32 o2_n;
	if ((o1_n + ~0x4D & 0xFF) > 0x01)
	{
		o2_n = 0x00;
		if (o1_n != 0x49)
		{
l00012648:
			check_aux_info(o2_n);
			l2_n->b0020 = 0x01 - (byte) (((int32) i0_n->b0000 ^ 0x4E) > 0x00);
			int32 o0_n = (int32) i0_n->b0001;
			word32 o2_n;
			if (o0_n != 0x43)
			{
				o2_n = 0x00;
				if (o0_n != 0x46)
				{
l00012688:
					check_aux_info(o2_n);
					if ((int32) i0_n->b0001 != 0x46 && i1_n == 0x00)
						l2_n->dw0014 = 0x00;
					else
						l2_n->dw0014 = 0x01;
					Eq_n i0_n;
					i0_n.u0 = i0_n + 0x03;
					check_aux_info(0x01 - (word32) (((int32) (*i0_n.u0) ^ 0x20) > 0x00));
					check_aux_info(0x01 - (word32) (((int32) (i0_n.u1)[1] ^ 0x2A) > 0x00));
					check_aux_info(0x01 - (word32) (((int32) (i0_n.u1)[2] ^ 0x2F) > 0x00));
					check_aux_info(0x01 - (word32) (((int32) (i0_n.u1)[3] ^ 0x20) > 0x00));
					word32 o0_n;
					if (strncmp(i0_n + 0x04, "static", 0x06) != 0x00 && strncmp(i0_n + (char *) 0x04, "extern", 0x06) != 0x00)
						o0_n = 0x00;
					else
						o0_n = 0x01;
					check_aux_info(o0_n);
					Eq_n i0_n;
					i0_n.u0 = i0_n + 11;
					while ((int32) i0_n.u1->t0000.u1 != 0x3B)
						i0_n.u0 = i0_n + 0x01;
					l2_n->ptr000C = dupnstr(i0_n + (char *) 0x04, i0_n - (i0_n + 0x03));
					Eq_n i0_n;
					i0_n.u0 = i0_n + ~0x00;
					int32 o0_n;
					while (i0_n != i0_n + (char *) 0x04)
					{
						int32 o0_n = (int32) i0_n.u1->bFFFFFFFF;
						if (o0_n != 0x20)
						{
							if (o0_n == 0x09)
							{
								i0_n.u0 = i0_n + ~0x00;
								continue;
							}
							else
							{
								o0_n = (int32) i0_n.u1->t0000.u1;
								goto l000127E4;
							}
						}
						i0_n.u0 = i0_n + ~0x00;
					}
					o0_n = (int32) i0_n.u1->t0000.u1;
l000127E4:
					if (o0_n != 0x29)
					{
l00012AC0:
						free_def_dec(l2_n);
					}
					l2_n->dw001C = 0x00;
					struct Eq_n * o0_n = find_corresponding_lparen(i0_n);
					++l2_n->dw001C;
					if ((int32) o0_n->bFFFFFFFE == 0x29)
						check_aux_info(0x01 - (word32) (((int32) o0_n->bFFFFFFFD ^ 0x29) > 0x00));
					int8 * i0_n = &o0_n->bFFFFFFFE;
					check_aux_info(0x01 - (word32) (((int32) o0_n->bFFFFFFFF ^ 0x20) > 0x00));
					while (is_id_char((int32) *i0_n) != 0x00)
						i0_n += -1;
					union Eq_n * i0_n = (union Eq_n *) (i0_n + 1);
					int32 l1_n = &o0_n->bFFFFFFFF - i0_n;
					struct Eq_n * sp_n = sp_n - (l1_n + 0x08 & ~0x07);
					strncpy(sp_n->a0060, i0_n, l1_n);
					sp_n->a0060[l1_n] = 0x00;
					struct Eq_n * o0_n = lookup(0x00029A40, sp_n->a0060);
					l2_n->ptr0010 = o0_n;
					Eq_n o2_n;
					o2_n.u0 = o0_n->t0008.u0;
					word32 o0_n;
					if (o2_n != 0x00)
					{
						int32 o1_n = l2_n->dw0008;
						while (true)
						{
							if (o1_n == *((word32) o2_n + 8))
							{
								if (l2_n->t0004.u1 == *((word32) o2_n + 4))
								{
									if (strcmp(l2_n->ptr000C, *((word32) o2_n + 0x0C)) != 0x00)
									{
										notice("%s:%d: declaration of function `%s' takes different forms\n", l2_n->t0004.u1->ptr0000->t0004.u0, sp_n->dw0048);
										exit(33);
									}
									goto l00012AC0;
								}
								o2_n = *((word32) o2_n + 24);
							}
							else
								o2_n = *((word32) o2_n + 24);
							if (o2_n == 0x00)
								break;
							o1_n = l2_n->dw0008;
						}
						o0_n = l2_n->dw0014;
					}
					else
						o0_n = l2_n->dw0014;
					l2_n->ptr0024 = null;
					int32 o0_n;
					if (o0_n != 0x00)
					{
						l2_n->dw0028 = 0x00;
						Eq_n i0_n;
						i0_n.u0 = i0_n + 0x01;
						check_aux_info(0x01 - (word32) (((int32) ((i0_n.u1)->t0000).u1 ^ 0x20) > 0x00));
						check_aux_info(0x01 - (word32) (((int32) (i0_n.u1)[1] ^ 0x2F) > 0x00));
						check_aux_info(0x01 - (word32) (((int32) (i0_n.u1)[2] ^ 0x2A) > 0x00));
						check_aux_info(0x01 - (word32) (((int32) (i0_n.u1)[3] ^ 0x20) > 0x00));
						check_aux_info(0x01 - (word32) (((int32) (i0_n.u1)[4] ^ 0x28) > 0x00));
						Eq_n i0_n;
						if ((int32) *(i0_n + 0x05) != 0x29)
						{
							Eq_n i0_n;
							i0_n.u0 = i0_n + 0x06;
							while ((int32) i0_n.u1->t0000.u1 != 0x29)
								i0_n.u0 = i0_n + (char *) 0x01;
							i0_n.u0 = i0_n + 0x01;
						}
						else
							i0_n.u0 = i0_n + 0x06;
						struct Eq_n * i0_n = (struct Eq_n *) &i0_n.u1->bFFFFFFFF;
						l2_n->ptr0024 = dupnstr(i0_n + (char *) 0x05, i0_n - (i0_n + (char *) 0x05));
						check_aux_info(0x01 - (word32) (((int32) i0_n->b0001 ^ 0x20) > 0x00));
						if ((int32) i0_n->b0002 != 0x2A)
						{
							struct Eq_n * i0_n = (struct Eq_n *) &i0_n->b0003;
							while (true)
							{
								while ((int32) i0_n->b0000 != 0x2A)
									++i0_n;
								if ((int32) i0_n[1] == 0x2F)
									break;
								++i0_n;
							}
							int8 * i0_n = (int8 *) ((char *) i0_n - 1);
							check_aux_info(0x01 - (word32) (((int32) (*i0_n) ^ 0x20) > 0x00));
							dupnstr(&i0_n->b0002, i0_n - &i0_n->b0002);
						}
						check_aux_info(0x01 - (word32) (((int32) i0_n->b0003 ^ 0x2F) > 0x00));
						l2_n->dw0028 = 94744;
						if ((int32) l2_n->b0020 != 0x00)
							return;
						if ((int32) l2_n->ptr0024->b0000 != 0x00)
						{
							o0_n = (int32) l2_n->b0020;
l00012AB4:
							if (o0_n != 0x00)
								return;
							goto l00012AC0;
						}
						l2_n->b0020 = 0x01;
					}
					else
						l2_n->dw0028 = 0x00;
					o0_n = (int32) l2_n->b0020;
					goto l00012AB4;
				}
			}
			o2_n = 0x01;
			goto l00012688;
		}
	}
	o2_n = 0x01;
	goto l00012648;
}

// 00012B64: Register word32 munge_compile_params(Register Eq_n o0, Register out word32 l6Out, Register out word32 l7Out, Register out Eq_n i0Out, Register out ptr32 i6Out)
// Called from:
//      gen_aux_info_file
//      main
word32 munge_compile_params(Eq_n o0, word32 & l6Out, word32 & l7Out, union Eq_n & i0Out, ptr32 & i6Out)
{
	ptr32 fp;
	struct Eq_n * sp_n = fp + ~0x6F - ((strlen(o0) << 0x02) + 0x27 & ~0x07);
	sp_n->a0060[0] = compiler_file_name;
	Eq_n i0_n = o0;
	ui32 l0_n = 0x01;
	int32 g2_n;
	ui32 o3_n;
	do
	{
		g2_n = l0_n << 0x02;
		if (((ui32) g_a2B411[(ui32) *i0_n.u0] & 0x08) != 0x00)
		{
			o3_n = l0_n + 0x01;
			i0_n.u0 = (word32) i0_n + 1;
			while (((ui32) g_a2B411[(ui32) *i0_n.u0] & 0x08) != 0x00)
				i0_n.u0 = (word32) i0_n + 1;
		}
		else
			o3_n = l0_n + 0x01;
		if ((int32) *i0_n.u0 == 0x00)
			goto l00012D00;
		struct Eq_n * o1_n = (ui32) *i0_n.u0;
		if (((ui32) o1_n->b2B411 & 0x08) == 0x00)
		{
			i0_n.u0 = (word32) i0_n + 1;
			while ((int32) *i0_n.u0 != 0x00)
			{
				struct Eq_n * o1_n = (ui32) *i0_n.u0;
				if (((ui32) o1_n->b2B411 & 0x08) != 0x00)
					break;
				i0_n.u0 = (word32) i0_n + 1;
			}
		}
		if ((int32) *i0_n.u0 == 0x2D && (int32) ((word32) (*((word32) i0_n + 1)) + 177) < 0x20)
		{
			word32 l6;
			l6Out = l6;
			word32 l7;
			l7Out = l7;
			i0Out = i0_n;
			i6Out = fp;
			return 0x0002B400;
		}
		sp_n->a0060[l0_n] = dupnstr(i0_n, i0_n - i0_n);
		++l0_n;
		g2_n = l0_n << 0x02;
	} while ((int32) *i0_n.u0 != 0x00);
	o3_n = l0_n + 0x01;
l00012D00:
	aux_info_file_name_index = o3_n;
	*((word32) &sp_n->a0060[0] + g2_n) = (word32[]) 0x00017220;
	ui32 l0_n = o3_n + 0x01;
	input_file_name_index = l0_n + 0x03;
	sp_n->a0060[o3_n] = 0x00;
	sp_n->a0060[l0_n] = 0x00017230;
	sp_n->a0060[l0_n + 0x01] = 94776;
	sp_n->a0060[l0_n + 0x02] = 94784;
	sp_n->a0060[l0_n + 0x03] = 0x00;
	sp_n->a0060[l0_n + 0x04] = 0x00;
	Eq_n o0_n = xmalloc(l0_n + 0x06 << 0x02);
	compile_params.u0 = (int8 *) o0_n;
	memcpy(o0_n, sp_n->a0060, l0_n + 0x05 << 0x02);
	Eq_n i0_n;
	i0_n.u0 = sp_n->t0000.u0;
	ptr32 i6_n = sp_n->ptr0018;
	word32 l2_n = sp_n->dw0028;
	word32 l7_n = sp_n->dw003C;
	l6Out = sp_n->dw0038;
	l7Out = l7_n;
	i0Out = i0_n;
	i6Out = i6_n;
	return l2_n;
}

// 00012E2C: Register Eq_n gen_aux_info_file(Register Eq_n o0, Register out word32 l2Out, Register out (ptr32 char) l4Out, Register out (ptr32 char) i0Out, Register out word32 i2Out, Register out ptr32 i6Out)
// Called from:
//      process_aux_info_file
Eq_n gen_aux_info_file(Eq_n o0, word32 & l2Out, char & l4Out, char & i0Out, word32 & i2Out, ptr32 & i6Out)
{
	struct Eq_n * fp;
	struct Eq_n * i6_n = fp;
	struct Eq_n * l2_n = &g_t27C00;
	Eq_n o1_n;
	if (input_file_name_index == 0x00)
	{
		word32 l6_n;
		word32 l7_n;
		Eq_n i0_n;
		l2_n = munge_compile_params(94744, out l6_n, out l7_n, out i0_n, out i6_n);
		o1_n = i0_n;
	}
	else
		o1_n = o0;
	Eq_n o0_n = shortpath(0x00, o1_n);
	compile_params.u0[l2_n->dw0344 * 0x04] = (int8) o0_n;
	word32 o0_n = savestring2(o0_n, strlen(o0_n), ".X", 0x02);
	word32 o1_n = quiet_flag;
	compile_params.u0[aux_info_file_name_index * 0x04] = (int8) o0_n;
	struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
	if (o1_n != 0x00)
	{
		word32 o0_n = choose_temp_base();
		Eq_n o1_n;
		o1_n.u0 = compile_params.u0;
		Eq_n o2_n;
		o2_n.u0 = g_t28150.u0;
		sp_n->dw005C = 0x07;
		if (pexecute(o1_n, o2_n, o0_n, &i6_n->ptrFFFFFFEC, (char *) i6_n - 24, 0x00027C00, sp_n->dw005C) != ~0x00)
		{
			int32 * o1_n = (int32 *) ((char *) i6_n - 28);
			pwait(o1_n);
		}
		else
		{
			char * l2_n = errno;
			fprintf(&g_t2B640, "%s: ", g_t28150.u0);
			fprintf(o0, i6_n->ptrFFFFFFEC, 0x00);
			fprintf(&g_t2B640, ": %s\n", xstrerror(l2_n));
			pwait(&g_dw17270);
			char * i0_n = sp_n->ptr0000;
			word32 i2_n = sp_n->dw0008;
			ptr32 i6_n = sp_n->ptr0018;
			char * l4_n = sp_n->ptr0030;
			l2Out = sp_n->dw0028;
			l4Out = l4_n;
			i0Out = i0_n;
			i2Out = i2_n;
			i6Out = i6_n;
			return 0x00;
		}
	}
	else
		notice("%s: compiling `%s'\n", g_t28150.u0, sp_n->dw0048);
}

// 00013034: Register word32 process_aux_info_file(Register Eq_n o0, Register word32 o2, Register out word32 l1Out)
// Called from:
//      do_processing
word32 process_aux_info_file(Eq_n o0, word32 o2, word32 & l1Out)
{
	struct Eq_n * fp;
	struct Eq_n * sp_n = (char *) fp - 0x00F8 - ((word32) strlen(o0) + 0x0A & ~0x07);
	strcpy(&sp_n->dw005C + 1, o0);
	strcat(&sp_n->dw005C + 1, ".X");
	Eq_n i0_n = o0;
	word32 i2_n = o2;
	struct Eq_n * i6_n = fp;
	Eq_n l4_n;
	l4_n.u0 = &sp_n->dw005C + 1;
	word32 l2_n = 0x00;
	while (true)
	{
		struct Eq_n * sp_n;
		char * o0_n;
		Eq_n o1_n;
		bool v36_n;
		if (access(l4_n, 0x04) == ~0x00)
		{
			char * l3_n = errno;
			if (l3_n != (char *) 0x02)
			{
				Eq_n l2_n;
				l2_n.u0 = g_t28150.u0;
				shortpath(0x00, l4_n);
				xstrerror(l3_n);
				sp_n = (struct Eq_n *) <invalid>;
				o0_n = (char *) "%s: can't read aux info file `%s': %s\n";
				o1_n = l2_n;
				goto l000131F0;
			}
			if (i2_n != 0x00)
			{
				Eq_n o1_n;
				o1_n.u0 = g_t28150.u0;
				notice("%s: warning: missing SYSCALLS file `%s'\n", o1_n, sp_n->dw0048);
				goto l000135B8;
			}
			v36_n = false;
		}
		else
			v36_n = l2_n == 0x00;
		char * l2_n;
		Eq_n l3_n;
		char * l0_n;
		Eq_n o1_n;
		struct stat * l1_n;
		if (!v36_n)
		{
			word32 l2_n;
			if (gen_aux_info_file(i0_n, out l2_n, out l4_n, out i0_n, out i2_n, out i6_n) == 0x00)
			{
				++errors;
				goto l000135B8;
			}
			if (access(l4_n, 0x04) == ~0x00)
			{
				l2_n = errno;
				l3_n.u0 = g_t28150.u0;
				l0_n = (char *) "%s: can't read aux info file `%s': %s\n";
				o1_n = l4_n;
				goto l000131D0;
			}
			l1_n = (struct stat *) ((char *) i6_n - 0x0098);
		}
		else
			l1_n = (struct stat *) ((char *) i6_n - 0x0098);
		if (stat(l4_n, l1_n) == ~0x00)
		{
			l2_n = errno;
			l3_n.u0 = g_t28150.u0;
			l0_n = (char *) "%s: can't get status of aux info file `%s': %s\n";
			o1_n = l4_n;
			goto l000131D0;
		}
		Eq_n l0_n;
		l0_n.u0 = i6_n->tFFFFFF98.u0;
		if (l0_n == 0x00)
			break;
		if (i2_n != 0x00)
		{
l00013218:
			Eq_n o0_n = open(l4_n, 0x00);
			if (o0_n == ~0x00)
			{
				char * l2_n = errno;
				Eq_n l3_n;
				l3_n.u0 = g_t28150.u0;
				shortpath(0x00, l4_n);
				xstrerror(l2_n);
				struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
				notice("%s: can't open aux info file `%s' for reading: %s\n", l3_n, sp_n->dw0048);
			}
			Eq_n o0_n = xmalloc((word32) l0_n + 1);
			*(o0_n + l0_n) = (word32) 0x00;
			char * l2_n;
			Eq_n l3_n;
			char * l0_n;
			if (safe_read(o0_n, o0_n, l0_n) != l0_n)
			{
				l2_n = errno;
				l3_n.u0 = g_t28150.u0;
				l0_n = (char *) "%s: error reading aux info file `%s': %s\n";
			}
			else
			{
				if (close(o0_n) == 0x00)
					break;
				l2_n = errno;
				l3_n.u0 = g_t28150.u0;
				l0_n = (char *) "%s: error closing aux info file `%s': %s\n";
			}
			shortpath(0x00, l4_n);
			xstrerror(l2_n);
			sp_n = (struct Eq_n *) <invalid>;
			notice(l0_n, l3_n, sp_n->dw0048);
			free(o0_n);
			close(o0_n);
			break;
		}
		int32 l7_n = i6_n->dwFFFFFFA8;
		if (stat(i0_n, l1_n) == ~0x00)
		{
			l2_n = errno;
			l3_n.u0 = g_t28150.u0;
			l0_n = (char *) "%s: can't get status of aux info file `%s': %s\n";
			o1_n = i0_n;
l000131D0:
			shortpath(0x00, o1_n);
			xstrerror(l2_n);
			sp_n = (struct Eq_n *) <invalid>;
			o0_n = l0_n;
			o1_n = l3_n;
l000131F0:
			notice(o0_n, o1_n, sp_n->dw0048);
		}
		int32 o0_n = i6_n->dwFFFFFFA8;
		if (o0_n <= l7_n)
			goto l00013218;
		l2_n = 0x01;
	}
l000135B8:
	word32 l0_n = sp_n->dw0020;
	l1Out = sp_n->dw0024;
	return l0_n;
}

// 000135C0: void reverse_def_dec_list(Register (ptr32 Eq_n) o0)
// Called from:
//      visit_each_hash_node
void reverse_def_dec_list(struct Eq_n * o0)
{
	struct Eq_n * o1_n = o0->ptr0008;
	struct Eq_n * g3_n = o1_n->ptr0004;
	if (g3_n != null)
	{
		struct Eq_n * o0_n = g3_n;
		struct Eq_n * g3_n = g3_n->ptr0000;
		if (g3_n != null)
		{
			g3_n->ptr0000 = null;
			struct Eq_n * g2_n = g3_n->ptr0000;
			while (true)
			{
				g3_n->ptr0000 = o0_n;
				o0_n = g3_n;
				g3_n = g2_n;
				if (g2_n == null)
					break;
				g2_n = g2_n->ptr0000;
			}
			o1_n->ptr0004 = g3_n;
		}
	}
}

// 0001360C: Register Eq_n identify_lineno(Register Eq_n o0)
// Called from:
//      declare_source_confusing
//      edit_formals_lists
//      edit_fn_definition
//      scan_for_missed_items
Eq_n identify_lineno(Eq_n o0)
{
	Eq_n g3_n;
	g3_n.u0 = g_t281C0.u0;
	Eq_n o0_n;
	if (g3_n < o0)
	{
		o0_n.u0 = 0x01;
		int32 g2_n = (int32) *g3_n.u0;
		while (true)
		{
			if (g2_n == 0x0A)
				o0_n.u0 = (word32) o0_n + 1;
			g3_n.u0 = (word32) g3_n + 1;
			if (g3_n > o0)
				break;
			g2_n = (int32) *g3_n.u0;
		}
	}
	else
		o0_n.u0 = (int8 *) 0x01;
	return o0_n;
}

// 0001364C: void declare_source_confusing(Register Eq_n o0)
// Called from:
//      check_source
void declare_source_confusing(Eq_n o0)
{
	if (quiet_flag == 0x00)
	{
		if (o0 == 0x00)
		{
			struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
			notice("%s: %d: warning: source too confusing\n", shortpath(0x00, g_t28180.u0), sp_n->dw0048);
		}
		else
		{
			Eq_n o0_n = shortpath(0x00, g_t28180.u0);
			identify_lineno(o0);
			struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
			notice("%s: %d: warning: source too confusing\n", o0_n, sp_n->dw0048);
		}
	}
	longjmp(&g_t2B240, 0x01);
}

// 000136E0: void check_source(Register ui32 o0, Register Eq_n o1)
// Called from:
//      seek_to_line
//      forward_to_next_token_char
//      edit_formals_lists
//      find_rightmost_formals_list
//      careful_find_l_paren
//      scan_for_missed_items
void check_source(ui32 o0, Eq_n o1)
{
	if (o0 != 0x00)
		return;
	declare_source_confusing(o1);
}

// 00013700: void seek_to_line(Register int32 o0)
void seek_to_line(int32 o0)
{
	int32 g0_n = o0 - g_dw28230;
	if (g0_n >= 0x00)
	{
		if (g0_n > 0x00)
		{
			int32 o1_n;
			while (true)
			{
				int8 * o0_n = g_ptr28220;
				int32 o1_n;
				if ((int32) *o0_n != 0x0A)
				{
					int8 * o2_n = g_ptr28220;
					while (true)
					{
						int8 * o2_n = o2_n + 1;
						Eq_n NZVC_n;
						NZVC_n.u1 = cond(o2_n - g_dw281D0);
						g_ptr28220 = o2_n;
						check_source(NZVC_n & 0x01, 0x00);
						if ((int32) *g_ptr28220 == 0x0A)
							break;
						o2_n = g_ptr28220;
					}
					o0_n = g_ptr28220;
					o1_n = g_dw28230;
				}
				else
					o1_n = g_dw28230;
				g_ptr28220 = o0_n + 1;
				o1_n = o1_n + 0x01;
				if (o0 <= o1_n)
					break;
				g_dw28230 = o1_n;
			}
			g_dw28230 = o1_n;
		}
	}
	else
		abort();
}

// 000137AC: Register Eq_n forward_to_next_token_char(Register Eq_n o0)
// Called from:
//      find_rightmost_formals_list
Eq_n forward_to_next_token_char(Eq_n o0)
{
	Eq_n i0_n;
	i0_n.u0 = (word32) o0 + 1;
	if (((ui32) g_a2B411[(ui32) *((word32) o0 + 1)] & 0x08) != 0x00)
	{
		up32 o0_n = g_dw281D0;
		while (true)
		{
			i0_n.u0 = (word32) i0_n + 1;
			check_source(cond(i0_n - o0_n) & 0x01, 0x00);
			if (((ui32) g_a2B411[(ui32) *i0_n.u0] & 0x08) == 0x00)
				break;
			o0_n = g_dw281D0;
		}
	}
	return i0_n;
}

// 00013808: void output_bytes(Register (ptr32 char) o0, Register Eq_n o1)
// Called from:
//      output_string
//      output_up_to
void output_bytes(char * o0, Eq_n o1)
{
	up32 l0_n = g_dw28200;
	if (g_dw28210 + ((word32) o1 + 1) >= l0_n)
	{
		Eq_n o0_n;
		o0_n.u0 = g_t281F0.u0;
		uint32 l0_n = l0_n - o0_n;
		Eq_n o0_n = xrealloc(o0_n, l0_n << 0x01);
		up32 o1_n = g_dw28210;
		Eq_n o2_n;
		o2_n.u0 = g_t281F0.u0;
		g_dw28200 = o0_n.u0 + (l0_n << 0x01);
		g_dw28210 = o0_n.u0 + (o1_n - o2_n);
		g_t281F0.u0 = (int8 *) o0_n;
	}
	memcpy(g_dw28210 + 0x01, o0, o1);
	g_dw28210 = (word32) o1 + g_dw28210;
}

// 0001388C: void output_string(Register (ptr32 char) o0)
// Called from:
//      edit_formals_lists
void output_string(char * o0)
{
	output_bytes(o0, strlen(o0));
}

// 000138AC: void output_up_to(Register Eq_n o0)
// Called from:
//      edit_formals_lists
//      edit_fn_definition
void output_up_to(Eq_n o0)
{
	Eq_n o2_n;
	o2_n.u0 = g_t281E0.u0;
	word32 o0_n = g_dw281A0 + (o2_n - g_t281C0.u0);
	Eq_n o1_n = o0 - o2_n;
	if (o1_n != 0x00)
	{
		output_bytes(o0_n + 0x01, o1_n);
		g_t281E0.u0 = (int8 *) o0;
	}
}

// 000138F0: Register (ptr32 int8) other_variable_style_function(Register (ptr32 int8) o0)
// Called from:
//      edit_fn_definition
int8 * other_variable_style_function(int8 * o0)
{
	return cond(0x00 - substr(o0, &g_b17468)) & 0x01;
}

// 00013914: void edit_fn_declaration(Register (ptr32 Eq_n) o0)
void edit_fn_declaration(struct Eq_n * o0)
{
	strlen(o0->ptr0010->ptr0004);
	save_pointers();
	if (setjmp(&g_t2B240) != 0x00)
	{
		restore_pointers();
		word32 dwLoc30;
		notice("%s: declaration of function `%s' not converted\n", g_t28150.u0, dwLoc30);
	}
}

// 00013B68: void edit_formals_lists(Register Eq_n o0, Register word32 o1, Register (ptr32 Eq_n) o2)
// Called from:
//      edit_formals_lists
void edit_formals_lists(Eq_n o0, word32 o1, struct Eq_n * o2)
{
	int8 * l1_n = (word32) o0 - 1 + ~0x00;
	word32 l0_n = 0x01;
	int32 o0_n = (int32) *((word32) o0 - 1);
l00013B7C:
	Eq_n o0_n;
	if (o0_n != 0x28)
	{
		int32 g0_n = o0_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n.u0 = g_t281E0.u0;
			l1_n = l1_n;
			goto l00013BAC;
		}
		++l0_n;
	}
	else
		l0_n += ~0x00;
	o0_n.u0 = g_t281E0.u0;
	l1_n += -1;
l00013BAC:
	check_source(cond(o0_n - l1_n) & 0x01, 0x00);
	if (l0_n == 0x00)
	{
		Eq_n l1_n;
		if (o1 != 0x01)
		{
			l1_n.u0 = l1_n + 1;
			check_source(cond(g_t281E0.u0 - ((word32) l1_n - 1)) & 0x01, 0x00);
			Eq_n l0_n;
			l0_n.u0 = (word32) l1_n - 1;
			int32 o0_n;
			if (((ui32) g_a2B411[(ui32) *((word32) l1_n - 1)] & 0x08) != 0x00)
			{
				Eq_n o0_n;
				o0_n.u0 = g_t281E0.u0;
				while (true)
				{
					l0_n.u0 = (word32) l0_n - 1;
					check_source(cond(o0_n - l0_n) & 0x01, 0x00);
					if (((ui32) g_a2B411[(ui32) *l0_n.u0] & 0x08) == 0x00)
						break;
					o0_n.u0 = g_t281E0.u0;
				}
				o0_n = (int32) *l0_n.u0;
			}
			else
				o0_n = (int32) *((word32) l1_n - 1);
			check_source(0x01 - (word32) ((o0_n ^ 0x29) > 0x00), l0_n);
			Eq_n l0_n;
			l0_n.u0 = (word32) l0_n - 1;
			check_source(cond(g_t281E0.u0 - l0_n) & 0x01, 0x00);
			check_source(0x01 - (word32) (((int32) (*l0_n.u0) ^ 0x29) > 0x00), l0_n);
			edit_formals_lists(l0_n, o1 + ~0x00, o2);
			if (l0_n != 0x00)
				return;
		}
		else
			l1_n.u0 = l1_n + 1;
		if (o1 == 0x01)
		{
			struct Eq_n * o1_n = o2->ptr0010;
			int8 * l0_n = (word32) l1_n - 1;
			char * l5_n;
			if (((ui32) g_a2B411[(ui32) *((word32) l1_n - 1)] & 0x08) != 0x00)
			{
				l5_n = o1_n->ptr0004;
				Eq_n o0_n;
				o0_n.u0 = g_t281E0.u0;
				while (true)
				{
					l0_n += -1;
					check_source(cond(o0_n - l0_n) & 0x01, 0x00);
					if (((ui32) g_a2B411[(ui32) *l0_n] & 0x08) == 0x00)
						break;
					o0_n.u0 = g_t281E0.u0;
				}
			}
			else
				l5_n = o1_n->ptr0004;
			int8 * l3_n = l0_n;
			Eq_n l0_n = l0_n + 1;
			while (is_id_char((int32) *l3_n) != 0x00)
			{
				Eq_n o0_n;
				o0_n.u0 = g_t281E0.u0;
				check_source(cond(o0_n - l3_n) & 0x01, 0x00);
				l3_n += -1;
			}
			Eq_n l3_n;
			l3_n.u0 = l3_n + 1;
			Eq_n l4_n = l0_n - l3_n;
			if (l4_n == 0x00)
				check_source(0x00, l3_n);
			struct Eq_n ** o0_n;
			if (l4_n != strlen(l5_n))
			{
				o0_n = o2->ptr0004;
				goto l00013D80;
			}
			if (strncmp(l3_n, l5_n, l4_n) != 0x00)
			{
				o0_n = o2->ptr0004;
l00013D80:
				Eq_n o0_n = shortpath(0x00, *((char *) *o0_n + 4));
				identify_lineno(l3_n);
				dupnstr(l3_n, l4_n);
				struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
				notice("%s: %d: warning: found `%s' but expected `%s'\n", o0_n, sp_n->dw0048);
				return;
			}
		}
		output_up_to(l1_n);
		if (o1 == 0x01)
			output_string(o2->ptr0024);
		g_t281E0.u0 = (word32) o0 - 1;
		return;
	}
	o0_n = (int32) *l1_n;
	goto l00013B7C;
}

// 00013E04: Register Eq_n find_rightmost_formals_list(Register Eq_n o0)
// Called from:
//      edit_fn_definition
Eq_n find_rightmost_formals_list(Eq_n o0)
{
	int8 * i0_n = (word32) o0 - 1;
	int32 o0_n = (int32) *o0.u0;
	while (o0_n != 0x0A)
	{
		++i0_n;
		o0_n = (int32) *i0_n;
	}
	Eq_n i0_n;
	i0_n.u0 = i0_n;
	if ((int32) *i0_n.u0 != 0x29)
	{
		struct Eq_n * o1_n = (ui32) *i0_n.u0;
		while (true)
		{
			int32 o0_n;
			if (((ui32) o1_n->b2B411 & 0x08) != 0x00)
			{
				Eq_n o0_n;
				o0_n.u0 = g_t281E0.u0;
				while (true)
				{
					i0_n.u0 = (word32) i0_n - 1;
					check_source(cond(o0_n - i0_n) & 0x01, 0x00);
					if (((ui32) g_a2B411[(ui32) *i0_n.u0] & 0x08) == 0x00)
						break;
					o0_n.u0 = g_t281E0.u0;
				}
				o0_n = (int32) *i0_n.u0;
			}
			else
			{
				i0_n.u0 = (word32) i0_n - 1;
				check_source(cond(g_t281E0.u0 - i0_n) & 0x01, 0x00);
				o0_n = (int32) *i0_n.u0;
			}
			if (o0_n == 0x29)
				break;
			o1_n = (ui32) *i0_n.u0;
		}
	}
	Eq_n o0_n = forward_to_next_token_char(i0_n);
	check_source(0x01 - (word32) (((int32) (*o0_n.u0) ^ 0x7B) > 0x00), o0_n);
	return i0_n;
}

// 00013EDC: void edit_fn_definition(Register (ptr32 Eq_n) o0, Register Eq_n o1)
void edit_fn_definition(struct Eq_n * o0, Eq_n o1)
{
	save_pointers();
	if (setjmp(&g_t2B240) != 0x00)
	{
		restore_pointers();
		word32 dwLoc30;
		notice("%s: definition of function `%s' not converted\n", g_t28150.u0, dwLoc30);
		output_up_to(o1);
	}
	else
	{
		Eq_n o0_n = find_rightmost_formals_list(o1);
		if (other_variable_style_function(o0->ptr000C) != 0x00)
		{
			if (quiet_flag != 0x00)
				output_up_to(o0_n);
			else
			{
				Eq_n o0_n = shortpath(0x00, *((char *) *o0->ptr0004 + 4));
				identify_lineno(o0_n);
				struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
				notice("%s: %d: warning: definition of %s not converted\n", o0_n, sp_n->dw0048);
			}
		}
	}
}

// 000140B4: void do_cleaning(Register (ptr32 byte) o0, Register (ptr32 byte) o1)
void do_cleaning(byte * o0, byte * o1)
{
	byte * i0_n = o0;
	if (o0 >= o1)
		return;
	ui32 o1_n = (ui32) *o0;
	while ((int32) ((byte) o1_n + ~0x07) >= 0x54)
	{
		++i0_n;
		if (i0_n >= o1)
			return;
		o1_n = (ui32) *i0_n;
	}
}

// 00014518: Register Eq_n careful_find_l_paren(Register Eq_n o0)
// Called from:
//      scan_for_missed_items
Eq_n careful_find_l_paren(Eq_n o0)
{
	Eq_n i0_n;
	i0_n.u0 = (word32) o0 - 1;
	word32 l0_n = 0x01;
	int32 o0_n = (int32) *((word32) o0 - 1);
l0001452C:
	Eq_n o0_n;
	if (o0_n != 0x28)
	{
		int32 g0_n = o0_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n.u0 = g_t281C0.u0;
l00014550:
			i0_n.u0 = (word32) i0_n - 1;
			check_source(0x01 - (word32) (i0_n < o0_n), 0x00);
			if (l0_n == 0x00)
				return (word32) i0_n + 1;
			o0_n = (int32) *i0_n.u0;
			goto l0001452C;
		}
		++l0_n;
	}
	else
		l0_n += ~0x00;
	o0_n.u0 = g_t281C0.u0;
	goto l00014550;
}

// 00014578: void scan_for_missed_items(Register (ptr32 Eq_n) o0)
void scan_for_missed_items(struct Eq_n * o0)
{
	ptr32 fp;
	Eq_n o1_n;
	o1_n.u0 = g_t281C0.u0;
	up32 o0_n = g_dw281D0;
	g_t28130.u0 = (word32) o1_n - 1;
	struct Eq_n * sp_n = fp + ~0x77;
	if (o1_n >= o0_n + ~0x02)
	{
		g_t28120.u0 = (int8 *) o1_n;
		return;
	}
	g_t28120.u0 = (int8 *) o1_n;
l000145B4:
	Eq_n o3_n;
	o3_n.u0 = g_t28120.u0;
	if ((int32) *o3_n.u0 == 0x29)
	{
		g_t28140.u0 = (int8 *) o3_n;
		Eq_n l0_n;
		if (((ui32) g_a2B411[(ui32) *((word32) o3_n + 1)] & 0x08) != 0x00)
		{
			l0_n.u0 = (word32) o3_n + 1;
			do
			{
				l0_n.u0 = (word32) l0_n + 1;
				check_source(cond(l0_n - (o0_n + ~0x02)) & 0x01, o0_n + ~0x02);
			} while (((ui32) g_a2B411[(ui32) *l0_n.u0] & 0x08) != 0x00);
		}
		else
			l0_n.u0 = (word32) o3_n + 1;
		g_t28120.u0 = (word32) l0_n - 1;
		struct Eq_n * o2_n = (ui32) *l0_n.u0;
		if (((ui32) o2_n->b2B411 & 0x03) == 0x00 && o2_n != (struct Eq_n *) 0x7B)
			goto l00014854;
		word32 o0_n = identify_lineno(l0_n);
		if (setjmp(&g_t2B240) != 0x00)
			goto l00014854;
		Eq_n o0_n;
		do
		{
			struct Eq_n * o0_n = careful_find_l_paren(g_t28140.u0);
			g_t28140.u0 = &o0_n->bFFFFFFFF;
			if (((ui32) g_a2B411[(ui32) o0_n->bFFFFFFFF] & 0x08) != 0x00)
			{
				Eq_n o2_n;
				o2_n.u0 = g_t28140.u0;
				while (true)
				{
					Eq_n o1_n;
					o1_n.u0 = g_t28130.u0;
					Eq_n o2_n;
					o2_n.u0 = (word32) o2_n - 1;
					g_t28140.u0 = (int8 *) o2_n;
					check_source(0x01 - (word32) (o2_n < o1_n), o1_n);
					if (((ui32) g_a2B411[(ui32) *g_t28140.u0] & 0x08) == 0x00)
						break;
					o2_n.u0 = g_t28140.u0;
				}
				o0_n.u0 = g_t28140.u0;
			}
			else
				o0_n.u0 = g_t28140.u0;
		} while ((int32) *o0_n.u0 == 0x29);
		if (is_id_char((int32) *g_t28140.u0) == 0x00)
		{
l00014850:
			goto l00014854;
		}
		Eq_n o0_n;
		o0_n.u0 = g_t28140.u0;
		if (is_id_char((int32) *o0_n.u0) != 0x00)
		{
			Eq_n o1_n;
			o1_n.u0 = g_t28130.u0;
			check_source(0x01 - (word32) ((word32) o0_n - 1 < o1_n), o1_n);
		}
		int32 l0_n = o0_n + 0x01 - (o0_n + 0x01);
		if (l0_n == 0x00)
		{
			g_t28130.u0 = o0_n + (char *) 0x01;
			goto l00014850;
		}
		g_t28130.u0 = o0_n + (char *) 0x01;
		sp_n -= l0_n + 0x6B & ~0x07;
		strncpy(sp_n->a0060, o0_n + (char *) 0x01, l0_n);
		char * o0_n = (char *) "if";
		sp_n->a0060[l0_n] = 0x00;
		if (o0_n != null)
		{
			word32 * l0_n = &g_ptr1753C;
			char * o1_n = (char *) "if";
			while (strcmp(sp_n->a0060, o1_n) != 0x00)
			{
				++l0_n;
				if (*l0_n == null)
					goto l000147BC;
				o1_n = *l0_n;
			}
			goto l00014850;
		}
l000147BC:
		struct Eq_n * o1_n = o0->ptr0004;
		if (o1_n == null)
		{
l00014804:
			Eq_n o0_n = shortpath(0x00, o0->ptr0000->t0004.u0);
			identify_lineno(o0_n + (char *) 0x01);
			struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
			notice("%s: %d: warning: `%s' excluded by preprocessing\n", o0_n, sp_n->dw0048);
			notice("%s: function definition not converted\n", g_t28150.u0, sp_n->dw0048);
		}
		word32 o0_n = o1_n->dw0014;
		while (o0_n == 0x00 || o1_n->dw0008 != o0_n)
		{
			o1_n = o1_n->ptr0000;
			if (o1_n == null)
				goto l00014804;
			o0_n = o1_n->dw0014;
		}
	}
l00014854:
	Eq_n o0_n;
	o0_n.u0 = g_t28120.u0;
	if ((word32) o0_n + 1 >= o0_n + ~0x02)
	{
		g_t28120.u0 = (word32) o0_n + 1;
		return;
	}
	g_t28120.u0 = (word32) o0_n + 1;
	goto l000145B4;
}

// 00014878: void edit_file(Register (ptr32 Eq_n) o0)
void edit_file(struct Eq_n * o0)
{
	struct Eq_n * i0_n = o0->ptr0008;
	if (needs_to_be_converted(i0_n) == 0x00)
		return;
	Eq_n o1_n;
	o1_n.u0 = i0_n->ptr0000->t0004.u0;
	g_t28180.u0 = (int8 *) o1_n;
	if (directory_specified_p(o1_n) == 0x00 || file_excluded_p(g_t28180.u0) != 0x00)
	{
		if (quiet_flag == 0x00 && in_system_include_dir(g_t28180.u0) == 0x00)
		{
			Eq_n l1_n;
			l1_n.u0 = g_t28150.u0;
			shortpath(0x00, g_t28180.u0);
			struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
			notice("%s: `%s' not converted\n", l1_n, sp_n->dw0048);
		}
	}
}

// 00014E24: void do_processing()
// Called from:
//      main
void do_processing()
{
	union Eq_n * l1_n;
	Eq_n o0_n;
	o0_n.u0 = g_t28160.u0;
	if (o0_n < o0_n.u0 + (n_base_source_files << 0x02))
	{
		Eq_n o0_n = *o0_n;
		while (true)
		{
			union Eq_n * l0_n = process_aux_info_file(o0_n, 0x00, out l1_n);
			if (l0_n >= l1_n)
				break;
			o0_n.u0 = l0_n->u0;
		}
	}
	visit_each_hash_node(&g_t28240);
	visit_each_hash_node(&g_t28240);
}

// 00014EA4: Register int32 main(Register int32 o0, Register (ptr32 Eq_n) o1)
// Called from:
//      _start
int32 main(int32 o0, struct Eq_n * o1)
{
	word32 i1_n;
	struct Eq_n * l4_n;
	struct Eq_n * l3_n;
	word32 l0_n;
	ptr32 fp;
	Eq_n o0_n = strrchr(o1->a0000[0].u0, '/');
	Eq_n o2_n;
	o2_n.u0 = (word32) o0_n + 1;
	if (o0_n == 0x00)
	{
		g_t28150.u0 = (int8 *) o0_n;
		o2_n.u0 = o1->a0000[0].u0;
	}
	else
		g_t28150.u0 = (int8 *) o0_n;
	g_t28150.u0 = (int8 *) o2_n;
	setlocale(0x05, "");
	Eq_n o0_n = getpwd();
	if (o0_n != 0x00)
	{
		g_t2B270.u0 = (int8 *) o0_n;
		directory_list = string_list_cons(o0_n, 0x00);
		word32 o0_n = getopt_long(o0, o1, &g_b17838, &g_t27F58, fp + ~0x13);
		if (o0_n != ~0x00)
		{
			uint32 o0_n;
			if (o0_n == 0x00)
			{
				ui32 dwLoc14;
				o0_n = (&g_t27F58.dw000C)[dwLoc14 * 4] + ~0x4D;
			}
			else
				o0_n = o0_n + ~0x4D;
			if (o0_n < 0x2A)
				return o0_n << 0x02;
			usage();
		}
		else
		{
			struct Eq_n * l6_n;
			struct Eq_n * l7_n;
			word32 i0_n;
			struct Eq_n * i6_n;
			munge_compile_params(94744, out l6_n, out l7_n, out i0_n, out i6_n);
			word32 o1_n = i6_n->dw0044 - l7_n->dw0068;
			l6_n->dw034C = o1_n;
			g_t28160.u0 = (int8 *) xmalloc(o1_n + 0x01 << 0x02);
			int32 o1_n = l7_n->dw0068;
			l6_n->dw034C = 0x00;
			if (o1_n < i6_n->dw0044)
			{
				struct Eq_n * l2_n;
				word32 o0_n;
				while (true)
				{
					Eq_n o0_n = abspath(0x00, i6_n->ptr0048[l7_n->dw0068].u0, out l0_n, out l2_n, out l3_n, out l4_n, out l7_n, out i1_n, out i6_n);
					Eq_n o1_n = (Eq_n) (strlen(o0_n) + o0_n);
					if ((int32) o1_n->tFFFFFFFF.b0000 == 99 && (int32) o1_n->bFFFFFFFE == 0x2E)
					{
						ui32 o0_n = l4_n->dw034C;
						g_t28160.u0[o0_n * 0x04] = (int8) o0_n;
						l4_n->dw034C = o0_n + 0x01;
					}
					else
					{
						Eq_n l0_n;
						l0_n.u0 = g_t28150.u0;
						shortpath(0x00, o0_n);
						struct Eq_n * sp_n = (struct Eq_n *) <invalid>;
						notice("%s: input file names must have .c suffixes: %s\n", l0_n, sp_n->dw0048);
						++l3_n->dw0320;
					}
					o0_n = l2_n->dw0068;
					if (o0_n + 0x01 >= i6_n->dw0044)
						break;
					l2_n->dw0068 = o0_n + 0x01;
				}
				l2_n->dw0068 = o0_n + 0x01;
			}
			if (errors == 0x00)
			{
				if (version_flag == 0x00)
				{
					do_processing();
					int32 o1_n;
					if (errors != 0x00)
						o1_n = 33;
					else
						o1_n = 0x00;
					exit(o1_n);
				}
				else
					fprintf(&g_t2B640, "%s: %s\n", g_t28150.u0, version_string);
			}
			else
				usage();
		}
	}
	else
	{
		g_t2B270.u0 = (int8 *) o0_n;
		Eq_n l1_n;
		l1_n.u0 = g_t28150.u0;
		xstrerror(errno);
		word32 dwLoc30;
		notice("%s: cannot get working directory: %s\n", l1_n, dwLoc30);
		exit(33);
	}
}

// 000152B8: Register Eq_n getpwd()
// Called from:
//      main
Eq_n getpwd()
{
	Eq_n i0_n;
	i0_n.u0 = g_t2B2A0.u0;
	if (i0_n != 0x00)
		return i0_n;
	char * o2_n = g_ptr2B2B0;
	if (o2_n != null)
	{
		errno = o2_n;
		return i0_n;
	}
	else
	{
		errno = o2_n;
		Eq_n o0_n = getenv("PWD");
		i0_n = o0_n;
		Eq_n l1_n;
		if (o0_n != 0x00)
		{
			l1_n.u0 = 100;
			if ((int32) *o0_n.u0 == 0x2F)
			{
				word32 dwLoc0120;
				if (stat(o0_n, &dwLoc0120) == 0x00)
				{
					word32 dwLoc98;
					if (stat(".", &dwLoc98) == 0x00)
					{
						word32 dwLoc88;
						word32 dwLoc0110;
						if (dwLoc88 == dwLoc0110)
						{
							if (dwLoc98 == dwLoc0120)
							{
								g_t2B2A0.u0 = (int8 *) o0_n;
								return i0_n;
							}
							l1_n.u0 = 100;
						}
						else
							l1_n.u0 = 100;
					}
					else
						l1_n.u0 = 100;
				}
				else
					l1_n.u0 = 100;
			}
		}
		else
			l1_n.u0 = (<unknown>*) 100;
		while (true)
		{
			Eq_n o0_n = xmalloc(l1_n);
			i0_n = o0_n;
			if (getcwd(o0_n, l1_n) != null)
				break;
			char * l0_n = errno;
			free(o0_n);
			if (l0_n != (char *) 0x22)
			{
				i0_n.u0 = 0x00;
				errno = l0_n;
				g_ptr2B2B0 = l0_n;
				break;
			}
			l1_n <<= 0x01;
		}
		g_t2B2A0.u0 = (int8 *) i0_n;
		return i0_n;
	}
}

// 000153C4: void _obstack_begin(Register (ptr32 Eq_n) o0, Register (ptr32 Eq_n) o1, Register word32 o2, Register (ptr32 code) o3, Register word32 o4, Register word32 o5)
void _obstack_begin(struct Eq_n * o0, struct Eq_n * o1, word32 o2, <anonymous> * o3, word32 o4, word32 o5)
{
	struct Eq_n * i1_n = o1;
	word32 i2_n = o2;
	if (o2 == 0x00)
		i2_n = 0x08;
	if (o1 == null)
		i1_n = (struct Eq_n *) 0x0FE8;
	ui32 o0_n = o0->dw0028;
	o0->dw0020 = o4;
	word32 o2_n = i2_n + ~0x00;
	o0->dw0018 = o2_n;
	o0->ptr001C = o3;
	o0->ptr0000 = i1_n;
	struct Eq_n * i1_n;
	if ((o0_n & 0x7FFFFFFF) < 0x00)
	{
		o0->dw0028 = o0_n & 0x7FFFFFFF;
		o3();
		i1_n = o0->ptr0024;
	}
	else
	{
		o0->dw0028 = o0_n & 0x7FFFFFFF;
		o3();
		i1_n = i1_n;
	}
	if (i1_n != null)
	{
		o0->ptr0004 = i1_n;
		struct Eq_n * o0_n = o0->ptr0000;
		word32 o1_n = &i1_n->dw0004 + 1;
		o0->dw000C = o1_n;
		o0->dw0008 = o1_n;
		word32 o0_n = i1_n + o0_n;
		i1_n->dw0000 = o0_n;
		o0->dw0010 = o0_n;
		i1_n->dw0004 = 0x00;
		o0->dw0028 &= ~0x60000000;
	}
	else
	{
		o0->ptr0004 = i1_n;
		<anonymous> * o1_n = obstack_alloc_failed_handler;
		o1_n();
	}
}

// 00015488: void _obstack_begin_n(Register (ptr32 Eq_n) o0, Register (ptr32 Eq_n) o1, Register word32 o2, Register (ptr32 code) o3, Register word32 o4, Register (ptr32 Eq_n) o5)
void _obstack_begin_n(struct Eq_n * o0, struct Eq_n * o1, word32 o2, <anonymous> * o3, word32 o4, struct Eq_n * o5)
{
	struct Eq_n * i1_n = o1;
	word32 i2_n = o2;
	if (o2 == 0x00)
		i2_n = 0x08;
	if (o1 == null)
		i1_n = (struct Eq_n *) 0x0FE8;
	ui32 o0_n = o0->dw0028;
	o0->dw0020 = o4;
	word32 o2_n = i2_n + ~0x00;
	o0->dw0018 = o2_n;
	o0->ptr001C = o3;
	o0->ptr0000 = i1_n;
	o0->ptr0024 = o5;
	struct Eq_n * i1_n;
	if ((o0_n | 0x80000000) < 0x00)
	{
		o0->dw0028 = o0_n | 0x80000000;
		o3();
		i1_n = o5;
	}
	else
	{
		o0->dw0028 = o0_n | 0x80000000;
		o3();
		i1_n = i1_n;
	}
	if (i1_n != null)
	{
		o0->ptr0004 = i1_n;
		struct Eq_n * o0_n = o0->ptr0000;
		word32 o1_n = &i1_n->dw0004 + 1;
		o0->dw000C = o1_n;
		o0->dw0008 = o1_n;
		word32 o0_n = i1_n + o0_n;
		i1_n->dw0000 = o0_n;
		o0->dw0010 = o0_n;
		i1_n->dw0004 = 0x00;
		o0->dw0028 &= ~0x60000000;
	}
	else
	{
		o0->ptr0004 = i1_n;
		<anonymous> * o1_n = obstack_alloc_failed_handler;
		o1_n();
	}
}

// 00015550: void _obstack_newchunk(Register (ptr32 Eq_n) o0, Register word32 o1, Register word32 o3, Register word32 o4, Register word32 o5)
void _obstack_newchunk(struct Eq_n * o0, word32 o1, word32 o3, word32 o4, word32 o5)
{
	Eq_n l2_n = o0->ptr000C - o0->ptr0008;
	word32 i1_n = (word32) l2_n + o1 + (l2_n >> 0x03);
	struct Eq_n * o2_n = o0->ptr0000;
	struct Eq_n * i1_n = i1_n + 100;
	struct Eq_n * l1_n;
	if (i1_n + 100 < o2_n)
	{
		l1_n = o0->ptr0004;
		i1_n = o2_n;
	}
	else
		l1_n = o0->ptr0004;
	struct Eq_n * l0_n;
	if (o0->t0028.u0 < 0x00)
	{
		<anonymous> * o2_n = o0->ptr001C;
		o2_n();
		l0_n = o0->ptr0024;
	}
	else
	{
		<anonymous> * o1_n = o0->ptr001C;
		o1_n();
		l0_n = i1_n;
	}
	if (l0_n == null)
	{
		<anonymous> * o1_n = obstack_alloc_failed_handler;
		o1_n();
		o0->ptr0004 = l0_n;
	}
	else
		o0->ptr0004 = l0_n;
	l0_n->ptr0004 = l1_n;
	ptr32 o1_n = l0_n + i1_n;
	o0->ptr0010 = o1_n;
	l0_n->ptr0000 = o1_n;
	struct Eq_n * i1_n;
	struct Eq_n * g2_n;
	struct Eq_n * o2_n;
	Eq_n o0_n;
	if (o0->dw0018 > 0x06)
	{
		uint32 o5_n = l2_n >> 0x02;
		i1_n = (struct Eq_n *) ((char *) &l0_n->ptr0004 + 4);
		Eq_n o3_n = (l2_n >> 0x02) + ~0x00;
		if (o3_n >= 0x00)
		{
			g2_n = (struct Eq_n *) ((char *) &l1_n->ptr0004 + 4);
			word32 * o4_n = (word32 *) ((char *) &l0_n->ptr0000 + ((o3_n << 0x02) + 0x08));
			while (true)
			{
				o2_n = (struct Eq_n *) o0->ptr0008[o3_n * 0x04];
				*o4_n = o2_n;
				o3_n = (word32) o3_n - 1;
				if (o3_n < 0x00)
					break;
				o4_n += -1;
			}
			ptr32 o4_n = o4_n + -1;
		}
		else
			g2_n = (struct Eq_n *) ((char *) &l1_n->ptr0004 + 4);
		o0_n = __align(l2_n, 4);
	}
	else
	{
		o0_n.u0 = 0x00;
		i1_n = (struct Eq_n *) ((char *) &l0_n->ptr0004 + 4);
		g2_n = (struct Eq_n *) ((char *) &l1_n->ptr0004 + 4);
	}
	Eq_n o3_n = o0_n;
	struct Eq_n * o0_n;
	if (o0_n < l2_n)
	{
		struct Eq_n * o0_n = o0->ptr0008;
		o2_n = i1_n;
		while (true)
		{
			*(i1_n + o3_n) = *(o0_n + o3_n);
			o3_n = (word32) o3_n.u0 + 1;
			if (o3_n >= l2_n)
				break;
			o0_n = o0->ptr0008;
		}
		o0_n = o0->ptr0008;
	}
	else
		o0_n = o0->ptr0008;
	Eq_n o0_n;
	if (o0_n == g2_n)
	{
		Eq_n o0_n;
		o0_n.u0 = o0->t0028.u0;
		if ((o0_n >> 0x1E & 0x01) == 0x00)
		{
			l0_n->ptr0004 = l1_n->ptr0004;
			if (o0->t0028.u0 >= 0x00)
			{
				<anonymous> * o1_n = o0->ptr0020;
				o1_n();
				o0_n.u0 = o0->t0028.u0;
			}
			else
			{
				<anonymous> * o2_n = o0->ptr0020;
				o2_n();
				o0_n.u0 = o0->t0028.u0;
			}
		}
		else
			o0_n.u0 = o0->t0028.u0;
	}
	else
		o0_n.u0 = o0->t0028.u0;
	o0->t0028.u0 = (int32) (o0_n & ~0x40000000);
	o0->ptr000C = i1_n + l2_n;
	o0->ptr0008 = i1_n;
}

// 000156F0: void _obstack_allocated_p(Register (ptr32 Eq_n) o0, Register up32 o1)
void _obstack_allocated_p(struct Eq_n * o0, up32 o1)
{
	struct Eq_n * g3_n;
	for (g3_n = o0->ptr0004; g3_n != null; g3_n = g3_n->ptr0004)
	{
		up32 g0_n = g3_n - o1;
		if (g0_n < 0x00)
		{
			if (g3_n->dw0000 >= o1)
				return;
			g3_n = g3_n->ptr0004;
			continue;
		}
	}
}

// 00015724: void _obstack_free(Register (ptr32 Eq_n) o0, Register up32 o1, Register word32 o2, Register word32 o4, Register word32 o5)
void _obstack_free(struct Eq_n * o0, up32 o1, word32 o2, word32 o4, word32 o5)
{
	struct Eq_n * o3_n = o0->ptr0004;
	while (o3_n != null)
	{
		up32 g0_n = o3_n - o1;
		int32 o0_n;
		if (g0_n < 0x00)
		{
			if (o3_n->dw0000 >= o1)
				break;
			o0_n = o0->dw0028;
		}
		else
			o0_n = o0->dw0028;
		struct Eq_n * l0_n;
		int32 o1_n;
		if (o0_n < 0x00)
		{
			l0_n = o3_n->ptr0004;
			<anonymous> * o2_n = o0->ptr0020;
			o2_n();
			o1_n = o0->dw0028;
		}
		else
		{
			l0_n = o3_n->ptr0004;
			<anonymous> * o1_n = o0->ptr0020;
			o1_n();
			o1_n = o0->dw0028;
		}
		o0->dw0028 = o1_n | 0x40000000;
		o3_n = l0_n;
	}
	if (o3_n == null)
	{
		if (o1 == 0x00)
			return;
		abort();
	}
	else
	{
		o0->dw0008 = o1;
		o0->dw000C = o1;
		up32 o0_n = o3_n->dw0000;
		o0->ptr0004 = o3_n;
		o0->dw0010 = o0_n;
	}
}

// 000157D4: void obstack_free(Register (ptr32 Eq_n) o0, Register up32 o1, Register word32 o2, Register word32 o4, Register word32 o5)
void obstack_free(struct Eq_n * o0, up32 o1, word32 o2, word32 o4, word32 o5)
{
	struct Eq_n * o3_n = o0->ptr0004;
	while (o3_n != null)
	{
		up32 g0_n = o3_n - o1;
		int32 o0_n;
		if (g0_n < 0x00)
		{
			if (o3_n->dw0000 >= o1)
				break;
			o0_n = o0->dw0028;
		}
		else
			o0_n = o0->dw0028;
		struct Eq_n * l0_n;
		int32 o1_n;
		if (o0_n < 0x00)
		{
			l0_n = o3_n->ptr0004;
			<anonymous> * o2_n = o0->ptr0020;
			o2_n();
			o1_n = o0->dw0028;
		}
		else
		{
			l0_n = o3_n->ptr0004;
			<anonymous> * o1_n = o0->ptr0020;
			o1_n();
			o1_n = o0->dw0028;
		}
		o0->dw0028 = o1_n | 0x40000000;
		o3_n = l0_n;
	}
	if (o3_n == null)
	{
		if (o1 == 0x00)
			return;
		abort();
	}
	else
	{
		o0->dw0008 = o1;
		o0->dw000C = o1;
		up32 o0_n = o3_n->dw0000;
		o0->ptr0004 = o3_n;
		o0->dw0010 = o0_n;
	}
}

// 00015884: void _obstack_memory_used(Register (ptr32 Eq_n) o0)
void _obstack_memory_used(struct Eq_n * o0)
{
	struct Eq_n * g3_n;
	for (g3_n = o0->ptr0004; g3_n != null; g3_n = g3_n->ptr0004)
		;
}

// 000158B4: void print_and_abort()
void print_and_abort()
{
	fputs("memory exhausted\n", &g_t2B640);
	exit(obstack_exit_failure);
}

// 000158D8: Register (ptr32 char) try(Register (ptr32 char) o0, Register (ptr32 char) o1)
// Called from:
//      choose_temp_base
//      make_temp_file
char * try(char * o0, char * o1)
{
	char * i0_n = o0;
	if (o1 != null)
		i0_n = o1;
	else if (o0 == null || access(o0, 0x07) != 0x00)
		i0_n = null;
	return i0_n;
}

// 00015918: Register Eq_n choose_temp_base()
// Called from:
//      gen_aux_info_file
Eq_n choose_temp_base()
{
	char * o0_n = try(&g_b28038, try(&g_b28040, try("/var/tmp/", try(getenv("TEMP"), try(getenv("TMP"), try(getenv("TMPDIR"), null))))));
	char * l0_n = o0_n;
	if (o0_n == null)
		l0_n = (char *) ".";
	Eq_n o0_n = strlen(l0_n);
	Eq_n o0_n = xmalloc((word32) o0_n + 0x0A);
	strcpy(o0_n, l0_n);
	Eq_n l1_n = o0_n;
	ui32 o0_n;
	if (o0_n != 0x00)
	{
		if ((int32) *((word32) (o0_n + o0_n) - 1) == 0x2F)
		{
			o0_n = (ui32) g_b17918;
l00015A04:
			*(o0_n + l1_n) = (word32) (byte) o0_n;
			struct Eq_n * o4_n = o0_n + l1_n;
			o4_n->b0001 = g_b17919;
			o4_n->b0002 = g_b1791A;
			o4_n->b0003 = g_b1791B;
			o4_n->b0004 = g_b1791C;
			o4_n->b0005 = g_b1791D;
			o4_n->b0006 = g_b1791E;
			o4_n->b0007 = g_b1791F;
			o4_n->b0008 = g_b17920;
			mktemp(o0_n);
			if (strlen(o0_n) != 0x00)
				return o0_n;
			abort();
		}
		*(o0_n + o0_n) = (word32) 0x2F;
		l1_n = o0_n + (union <anonymous> *) 0x01;
	}
	o0_n = (ui32) g_b17918;
	goto l00015A04;
}

// 00015A7C: void make_temp_file(Register (ptr32 char) o0)
void make_temp_file(char * o0)
{
	char * o0_n = try(&g_b28050, try(&g_b28058, try("/var/tmp/", try(getenv("TEMP"), try(getenv("TMP"), try(getenv("TMPDIR"), null))))));
	char * l0_n = o0_n;
	if (o0_n == null)
		l0_n = (char *) ".";
	Eq_n o0_n = strlen(l0_n);
	Eq_n l2_n;
	if (o0 != null)
		l2_n = strlen(o0);
	else
		l2_n.u0 = 0x00;
	Eq_n o0_n = xmalloc(o0_n + l2_n + 0x0A);
	strcpy(o0_n, l0_n);
	Eq_n l1_n = o0_n;
	if (o0_n != 0x00)
	{
		Eq_n o0_n = (Eq_n) (o0_n + o0_n);
		if ((int32) o0_n->bFFFFFFFF != 0x2F)
		{
			*(o0_n + o0_n) = (word32) 0x2F;
			l1_n = (word32) o0_n + 1;
		}
	}
	*(o0_n + l1_n) = (word32) g_b17918;
	struct Eq_n * o3_n = o0_n + l1_n;
	o3_n->b0001 = g_b17919;
	o3_n->b0002 = g_b1791A;
	o3_n->b0003 = g_b1791B;
	o3_n->b0004 = g_b1791C;
	o3_n->b0005 = g_b1791D;
	o3_n->b0006 = g_b1791E;
	o3_n->b0007 = g_b1791F;
	ui32 o1_n = (ui32) g_b17920;
	if (o0 == null)
	{
		o3_n->b0008 = (byte) o1_n;
		int32 o0_n = mkstemps(o0_n, l2_n);
		if (o0_n != ~0x00)
		{
			if (close(o0_n) == 0x00)
				return;
			abort();
		}
		else
			abort();
	}
	else
	{
		o3_n->b0008 = (byte) o1_n;
		strcat(o0_n, o0);
	}
}

// 00015C24: Register (ptr32 int8) my_index(Register (ptr32 int8) o0, Register int32 o1)
// Called from:
//      _getopt_internal
int8 * my_index(int8 * o0, int32 o1)
{
	int32 g2_n = (int32) *o0;
	while (g2_n != 0x00)
	{
		ui32 g3_n = (ui32) *o0;
		if ((int32) (byte) g3_n == o1)
			return o0;
		++o0;
		g2_n = (int32) *o0;
	}
	o0 = null;
	return o0;
}

// 00015C60: void exchange(Register (ptr32 Eq_n) o0)
// Called from:
//      _getopt_internal
void exchange(struct Eq_n * o0)
{
	int32 g1_n = g_dw2B300;
	int32 i5_n = optind;
	int32 i4_n = g_dw2B2F0;
	int32 g2_n;
	if (i5_n <= g1_n)
	{
l00015D40:
		g2_n = optind;
		goto l00015D44;
	}
	if (g1_n <= i4_n)
	{
		g2_n = optind;
l00015D44:
		g_dw2B2F0 += g2_n - g_dw2B300;
		g_dw2B300 = g2_n;
		return;
	}
	int32 g3_n = i5_n - g1_n;
l00015CA4:
	int32 g2_n = g1_n - i4_n;
	bool v37_n;
	if (g3_n > g2_n)
	{
		if (g2_n > 0x00)
		{
			i5_n -= g2_n;
			int32 i3_n = g2_n;
			Eq_n (* i1_n)[] = i5_n << 0x02;
			struct Eq_n * g3_n = i4_n << 0x02;
			while (true)
			{
				word32 i2_n = *(g3_n + o0);
				*(g3_n + o0) = *(i1_n + o0);
				*(i1_n + o0) = i2_n;
				i3_n += ~0x00;
				i1_n = (Eq_n (*)[]) &(i1_n + 1)->u0;
				if (i3_n == 0x00)
					break;
				g3_n += (struct Eq_n *) 0x04;
			}
			v37_n = i5_n <= g1_n;
l00015D30:
			if (v37_n)
				goto l00015D40;
			int32 g0_n = g1_n - i4_n;
			if (g0_n <= 0x00)
				goto l00015D40;
			g3_n = i5_n - g1_n;
			goto l00015CA4;
		}
		i5_n -= g2_n;
	}
	else
	{
		int32 g4_n;
		if (g3_n > 0x00)
		{
			g4_n = i4_n + g3_n;
			int32 i3_n = g3_n;
			int32 i1_n = i4_n << 0x02;
			int32 g3_n = g1_n << 0x02;
			while (true)
			{
				word32 i2_n = *((char *) &o0->a0000[0].u0 + i1_n);
				*((char *) &o0->a0000[0].u0 + i1_n) = *((char *) &o0->a0000[0].u0 + g3_n);
				*((char *) &o0->a0000[0].u0 + g3_n) = i2_n;
				i3_n += ~0x00;
				g3_n += 0x04;
				if (i3_n == 0x00)
					break;
				i1_n += 0x04;
			}
		}
		else
			g4_n = i4_n + g3_n;
		i4_n = g4_n;
	}
	v37_n = i5_n <= g1_n;
	goto l00015D30;
}

// 00015D64: Register (ptr32 int8) _getopt_initialize(Register (ptr32 int8) o2)
// Called from:
//      _getopt_internal
int8 * _getopt_initialize(int8 * o2)
{
	int32 o2_n = optind;
	g_dw2B2F0 = o2_n;
	g_dw2B300 = o2_n;
	g_t2B2C0.u0 = 0x00;
	char * o0_n = getenv("POSIXLY_CORRECT");
	g_ptr2B2E0 = o0_n;
	int8 * i0_n = o2;
	int32 o0_n = (int32) *o2;
	switch (o0_n)
	{
	case 0x2D:
		g_dw2B2D0 = 0x02;
		i0_n = o2 + 1;
		break;
	case 0x2B:
		g_dw2B2D0 = 0x00;
		i0_n = o2 + 1;
		break;
	default:
		if (o0_n != null)
			g_dw2B2D0 = 0x00;
		else
			g_dw2B2D0 = 0x01;
		break;
	}
	return i0_n;
}

// 00015E04: Register int32 _getopt_internal(Register int32 o0, Register (ptr32 Eq_n) o1, Register (ptr32 int8) o2, Register (ptr32 Eq_n) o3, Register (ptr32 word32) o4, Register word32 o5)
// Called from:
//      getopt
//      getopt_long
//      getopt_long_only
int32 _getopt_internal(int32 o0, struct Eq_n * o1, int8 * o2, struct Eq_n * o3, word32 * o4, word32 o5)
{
	int32 o2_n = optind;
	optarg.u0 = 0x00;
	int8 * i2_n = o2;
	if (o2_n == 0x00 || __getopt_initialized == 0x00)
	{
		if (o2_n == 0x00)
			optind = 0x01;
		int8 * o0_n = _getopt_initialize(o2);
		__getopt_initialized = 0x01;
		i2_n = o0_n;
	}
	Eq_n o0_n;
	o0_n.u0 = g_t2B2C0.u0;
	int32 i0_n;
	if (o0_n != 0x00 && (int32) (*o0_n.u0) != 0x00)
	{
l000160C0:
		Eq_n o1_n;
		if (o3 == null)
		{
			o1_n.u0 = g_t2B2C0.u0;
			goto l000164A0;
		}
		int32 o0_n = optind;
		Eq_n o0_n;
		o0_n.u0 = o1[o0_n];
		int32 o1_n = (int32) *((word32) o0_n + 1);
		Eq_n l2_n;
		if (o1_n != 0x2D)
		{
			if (o5 == 0x00)
			{
				o1_n.u0 = g_t2B2C0.u0;
				goto l000164A0;
			}
			if ((int32) *((word32) o0_n + 2) != 0x00)
			{
				l2_n.u0 = g_t2B2C0.u0;
l00016114:
				struct Eq_n * l3_n = null;
				word32 i3_n = 0x00;
				int32 o0_n = (int32) *l2_n.u0;
				word32 i0_n = 0x00;
				word32 o1_n = o3->dw0000;
				word32 l7_n = ~0x00;
				while (o0_n != 0x00)
				{
					int32 g0_n = o0_n - 0x3D;
					if (g0_n == 0x00)
						break;
					l2_n.u0 = (word32) l2_n + 1;
					o0_n = (int32) *l2_n.u0;
				}
				struct Eq_n * l1_n = o3;
				if (o1_n != 0x00)
				{
					word32 l4_n = 0x00;
l0001615C:
					Eq_n o1_n;
					o1_n.u0 = g_t2B2C0.u0;
					if (strncmp(l1_n->dw0000, o1_n, l2_n - o1_n) != 0x00)
					{
						++l1_n;
						goto l000161A8;
					}
					if (l2_n - g_t2B2C0.u0 != strlen(l1_n->dw0000))
					{
						if (l3_n == null)
						{
							l3_n = l1_n;
							l7_n = l4_n;
						}
						else
							i0_n = 0x01;
						++l1_n;
l000161A8:
						if (l1_n->dw0000 == 0x00)
							goto l000161B8;
						++l4_n;
						goto l0001615C;
					}
					l3_n = l1_n;
					l7_n = l4_n;
					i3_n = 0x01;
				}
l000161B8:
				bool v47_n;
				if (i0_n != 0x00)
				{
					if (i3_n == 0x00)
					{
						if (opterr == 0x00)
						{
							Eq_n o0_n = strlen(g_t2B2C0.u0);
							int32 o2_n = optind;
							g_t2B2C0.u0 += o0_n;
							optind = o2_n + 0x01;
							optopt = 0x00;
							i0_n = 0x3F;
							return i0_n;
						}
						else
						{
							int32 o1_n = optind;
							fprintf(&g_t2B640, "%s: option `%s' is ambiguous\n", o1->a0000[0].u0, o1[o1_n]);
						}
					}
					v47_n = l3_n == null;
				}
				else
					v47_n = l3_n == null;
				int32 * o1_n;
				int32 o0_n;
				int32 o0_n;
				if (!v47_n)
				{
					int32 o2_n = optind;
					optind = o2_n + 0x01;
					if ((int32) *l2_n.u0 != 0x00)
					{
						word32 o0_n = l3_n->dw0004;
						if (o0_n != 0x00)
						{
							Eq_n o0_n;
							o0_n.u0 = (word32) l2_n + 1;
							optarg.u0 = (int8 *) o0_n;
						}
						else if (opterr != 0x00)
						{
							struct Eq_n * o3_n = (struct Eq_n *) *((char *) (o1 + (o2_n + 0x01)) - 4);
							Eq_n o0_n;
							if ((int32) o3_n->b0001 == 0x2D)
							{
								fprintf(&g_t2B640, "%s: option `--%s' doesn't allow an argument\n", o1->a0000[0].u0, l3_n->dw0000);
								o0_n.u0 = g_t2B2C0.u0;
							}
							else
							{
								fprintf(&g_t2B640, "%s: option `%c%s' doesn't allow an argument\n", o1->a0000[0].u0, o3_n->t0000.u1, l3_n->dw0000);
								o0_n.u0 = g_t2B2C0.u0;
							}
							Eq_n o0_n = strlen(o0_n);
							int32 o2_n = l3_n->dw000C;
							g_t2B2C0.u0 += o0_n;
							optopt = o2_n;
							i0_n = 0x3F;
							return i0_n;
						}
l00016398:
						Eq_n o1_n;
						o1_n.u0 = g_t2B2C0.u0 + strlen(g_t2B2C0.u0);
						if (o4 != null)
						{
							g_t2B2C0.u0 = (int8 *) o1_n;
							*o4 = l7_n;
						}
						else
							g_t2B2C0.u0 = (int8 *) o1_n;
						o1_n = l3_n->ptr0008;
						if (o1_n == null)
						{
							i0_n = l3_n->dw000C;
							return i0_n;
						}
						o0_n = l3_n->dw000C;
						goto l00016874;
					}
					word32 o0_n = l3_n->dw0004;
					if (o0_n != 0x01)
						goto l00016398;
					if (o2_n + 0x01 < o0)
					{
						optarg.u0 = (int8 *) o1[o2_n + 0x01];
						optind = o2_n + 0x02;
						goto l00016398;
					}
					if (opterr != 0x00)
						fprintf(&g_t2B640, "%s: option `%s' requires an argument\n", o1->a0000[0].u0, *((char *) (o1 + (o2_n + 0x01)) - 4));
					Eq_n o0_n = strlen(g_t2B2C0.u0);
					int32 o2_n = l3_n->dw000C;
					g_t2B2C0.u0 += o0_n;
					optopt = o2_n;
					o0_n = (int32) *i2_n;
l00016388:
					i0_n = 0x3F;
					if (o0_n != 0x3A)
						strlen(g_t2B2C0.u0);
					else
						i0_n = 0x3A;
					return i0_n;
				}
				if (o5 == 0x00)
				{
l0001640C:
					int32 o0_n;
					if (opterr != 0x00)
					{
						int32 o0_n = optind;
						Eq_n o3_n;
						o3_n.u0 = o1[o0_n];
						if ((int32) *((word32) o3_n + 1) != 0x2D)
							fprintf(&g_t2B640, "%s: unrecognized option `%c%s'\n", o1->a0000[0].u0, *o3_n.u0, g_t2B2C0.u0);
						fprintf(&g_t2B640, "%s: unrecognized option `--%s'\n", o1->a0000[0].u0, g_t2B2C0.u0);
						o0_n = optind;
					}
					else
						o0_n = optind;
					g_t2B2C0.u0 = 96808;
					optind = o0_n + 0x01;
					optopt = 0x00;
					i0_n = 0x3F;
					return i0_n;
				}
				int32 o0_n = optind;
				if ((int32) *((word32) &o1[o0_n].a0000[0] + 1) == 0x2D)
					goto l0001640C;
				Eq_n o2_n;
				o2_n.u0 = g_t2B2C0.u0;
				if (my_index(i2_n, (int32) *o2_n.u0) == null)
					goto l0001640C;
				o1_n.u0 = g_t2B2C0.u0;
l000164A0:
				ui32 i0_n = (ui32) *o1_n.u0;
				g_t2B2C0.u0 = (word32) o1_n + 1;
				int32 l0_n = (int32) (byte) i0_n;
				struct Eq_n * o0_n = my_index(i2_n, l0_n);
				Eq_n o3_n;
				o3_n.u0 = g_t2B2C0.u0;
				if ((int32) *o3_n.u0 == 0x00)
					++optind;
				if (o0_n == null || l0_n == 0x3A)
				{
					if (opterr != 0x00)
					{
						if (g_ptr2B2E0 == null)
							fprintf(&g_t2B640, "%s: invalid option -- %c\n", o1->a0000[0].u0, (char) l0_n);
						fprintf(&g_t2B640, "%s: illegal option -- %c\n", o1->a0000[0].u0, (char) l0_n);
					}
					optopt = (int32) (byte) i0_n;
					i0_n = 0x3F;
					return i0_n;
				}
				int32 o0_n = (int32) o0_n->b0000;
				int32 i0_n;
				int32 o0_n;
				if (o0_n == 0x57)
				{
					ui32 o1_n = (ui32) o0_n->b0001;
					if (o1_n == 0x3B)
					{
						struct Eq_n * l3_n = null;
						word32 i0_n = 0x00;
						word32 l4_n = 0x00;
						if ((int32) *o3_n.u0 != 0x00)
						{
							int32 o0_n = optind;
							optarg.u0 = (int8 *) o3_n;
							optind = o0_n + 0x01;
							goto l0001663C;
						}
						int32 o2_n = optind;
						if (o2_n != o0)
						{
							optarg.u0 = (int8 *) o1[o2_n];
							optind = o2_n + 0x01;
l0001663C:
							Eq_n l1_n;
							l1_n.u0 = optarg.u0;
							g_t2B2C0.u0 = (int8 *) l1_n;
							word32 l7_n = 0x00;
							while (true)
							{
								int32 o0_n = (int32) *l1_n.u0;
								if (o0_n == 0x00 || o0_n == 0x3D)
									break;
								l1_n.u0 = (word32) l1_n + 1;
							}
							struct Eq_n * i3_n = o3;
							if (o3->dw0000 != 0x00)
							{
								word32 l2_n = 0x00;
l00016670:
								Eq_n o1_n;
								o1_n.u0 = g_t2B2C0.u0;
								if (strncmp(i3_n->dw0000, o1_n, l1_n - o1_n) != 0x00)
								{
									++i3_n;
									goto l000166BC;
								}
								if (l1_n - g_t2B2C0.u0 != strlen(i3_n->dw0000))
								{
									if (l3_n == null)
									{
										l3_n = i3_n;
										l7_n = l2_n;
									}
									else
										l4_n = 0x01;
									++i3_n;
l000166BC:
									if (i3_n->dw0000 == 0x00)
										goto l000166CC;
									++l2_n;
									goto l00016670;
								}
								l3_n = i3_n;
								l7_n = l2_n;
								i0_n = 0x01;
							}
l000166CC:
							bool v53_n;
							if (l4_n != 0x00)
							{
								if (i0_n == 0x00)
								{
									if (opterr == 0x00)
									{
										Eq_n o0_n = strlen(g_t2B2C0.u0);
										int32 o2_n = optind;
										g_t2B2C0.u0 += o0_n;
										optind = o2_n + 0x01;
										i0_n = 0x3F;
										return i0_n;
									}
									else
									{
										int32 o1_n = optind;
										fprintf(&g_t2B640, "%s: option `-W %s' is ambiguous\n", o1->a0000[0].u0, o1[o1_n]);
									}
								}
								v53_n = l3_n == null;
							}
							else
								v53_n = l3_n == null;
							if (v53_n)
							{
								g_t2B2C0.u0 = 0x00;
								i0_n = 0x57;
								return i0_n;
							}
							if ((int32) *l1_n.u0 != 0x00)
							{
								word32 o0_n = l3_n->dw0004;
								if (o0_n == 0x00)
								{
									if (opterr == 0x00)
									{
										g_t2B2C0.u0 += strlen(g_t2B2C0.u0);
										i0_n = 0x3F;
										return i0_n;
									}
									else
										fprintf(&g_t2B640, "%s: option `-W %s' doesn't allow an argument\n", o1->a0000[0].u0, l3_n->dw0000);
								}
								Eq_n o0_n;
								o0_n.u0 = (word32) l1_n + 1;
								optarg.u0 = (int8 *) o0_n;
							}
							else
							{
								word32 o0_n = l3_n->dw0004;
								if (o0_n == 0x01)
								{
									int32 o2_n = optind;
									if (o2_n >= o0)
									{
										if (opterr != 0x00)
											fprintf(&g_t2B640, "%s: option `%s' requires an argument\n", o1->a0000[0].u0, *((char *) (o1 + o2_n) - 4));
										g_t2B2C0.u0 += strlen(g_t2B2C0.u0);
										o0_n = (int32) *i2_n;
										goto l00016388;
									}
									optarg.u0 = (int8 *) o1[o2_n];
									optind = o2_n + 0x01;
								}
							}
							Eq_n o1_n;
							o1_n.u0 = g_t2B2C0.u0 + strlen(g_t2B2C0.u0);
							if (o4 != null)
							{
								g_t2B2C0.u0 = (int8 *) o1_n;
								*o4 = l7_n;
							}
							else
								g_t2B2C0.u0 = (int8 *) o1_n;
							o1_n = l3_n->ptr0008;
							if (o1_n == null)
							{
								i0_n = l3_n->dw000C;
								return i0_n;
							}
							o0_n = l3_n->dw000C;
l00016874:
							*o1_n = o0_n;
							i0_n = 0x00;
							return i0_n;
						}
						if (opterr != 0x00)
							fprintf(&g_t2B640, "%s: option requires an argument -- %c\n", o1->a0000[0].u0, (char) l0_n);
						optopt = l0_n;
						if ((int32) *i2_n == 0x3A)
							i0_n = 0x3A;
						else
							i0_n = 0x3F;
l00016970:
						i0_n = i0_n << 0x18;
l00016974:
						i0_n = i0_n >> 0x18;
						return i0_n;
					}
					o0_n = o1_n << 0x18;
				}
				else
				{
					ui32 o1_n = (ui32) o0_n->b0001;
					o0_n = o1_n << 0x18;
				}
				if (o0_n >> 0x18 != 0x3A)
				{
					i0_n = i0_n << 0x18;
					goto l00016974;
				}
				Eq_n o1_n;
				int32 o0_n;
				if ((int32) o0_n->b0002 == 0x3A)
				{
					o1_n.u0 = g_t2B2C0.u0;
					if ((int32) *o1_n.u0 == 0x00)
					{
						optarg.u0 = 0x00;
						goto l0001696C;
					}
					o0_n = optind;
				}
				else
				{
					o1_n.u0 = g_t2B2C0.u0;
					if ((int32) *o1_n.u0 == 0x00)
					{
						int32 o2_n = optind;
						if (o2_n == o0)
						{
							if (opterr != 0x00)
								fprintf(&g_t2B640, "%s: option requires an argument -- %c\n", o1->a0000[0].u0, (byte) i0_n);
							optopt = (int32) (byte) i0_n;
							if ((int32) *i2_n == 0x3A)
								i0_n = 0x3A;
							else
								i0_n = 0x3F;
						}
						else
						{
							optarg.u0 = (int8 *) o1[o2_n];
							optind = o2_n + 0x01;
						}
l0001696C:
						g_t2B2C0.u0 = 0x00;
						goto l00016970;
					}
					o0_n = optind;
				}
				optarg.u0 = (int8 *) o1_n;
				optind = o0_n + 0x01;
				goto l0001696C;
			}
			if (my_index(i2_n, o1_n) != null)
			{
				o1_n.u0 = g_t2B2C0.u0;
				goto l000164A0;
			}
		}
		l2_n.u0 = g_t2B2C0.u0;
		goto l00016114;
	}
	int32 o2_n = optind;
	if (g_dw2B300 > o2_n)
		g_dw2B300 = o2_n;
	if (g_dw2B2F0 > o2_n)
		g_dw2B2F0 = o2_n;
	if (g_dw2B2D0 != 0x01)
	{
l00015F78:
		int32 o1_n = optind;
		int32 o2_n;
		if (o1_n == o0)
		{
l00016008:
			o2_n = optind;
			goto l0001600C;
		}
		if (strcmp(o1[o1_n], "--") != 0x00)
		{
			o2_n = optind;
l0001600C:
			if (o2_n == o0)
			{
				int32 o1_n = g_dw2B2F0;
				if (o1_n == g_dw2B300)
				{
					i0_n = ~0x00;
					return i0_n;
				}
				optind = o1_n;
			}
			else
			{
				Eq_n o3_n;
				o3_n.u0 = o1[o2_n];
				word32 o0_n;
				if ((int32) *o3_n.u0 == 0x2D)
				{
					int32 o0_n = (int32) *((word32) o3_n + 1);
					if (o0_n != 0x00)
					{
						word32 o1_n;
						if (o3 != null)
							o1_n = 0x01 - (word32) ((o0_n ^ 0x2D) > 0x00);
						else
							o1_n = 0x00;
						g_t2B2C0.u0 = o3_n.u0 + (o1_n + 0x01);
						goto l000160C0;
					}
					o0_n = g_dw2B2D0;
				}
				else
					o0_n = g_dw2B2D0;
				if (o0_n != 0x00)
				{
					int32 o0_n = o2_n + 0x01;
					optarg.u0 = (int8 *) o3_n;
					optind = o0_n;
					i0_n = 0x01;
					return i0_n;
				}
			}
			i0_n = ~0x00;
			return i0_n;
		}
		int32 o2_n = g_dw2B300;
		int32 o0_n = optind;
		int32 o1_n;
		if (g_dw2B2F0 != o2_n)
		{
			optind = o0_n + 0x01;
			if (o2_n != o0_n + 0x01)
			{
				exchange(o1);
l00016000:
				g_dw2B300 = o0;
				optind = o0;
				goto l00016008;
			}
			o1_n = g_dw2B2F0;
		}
		else
		{
			optind = o0_n + 0x01;
			o1_n = g_dw2B2F0;
		}
		if (o1_n == g_dw2B300)
			g_dw2B2F0 = optind;
		goto l00016000;
	}
	int32 o1_n = g_dw2B300;
	int32 o0_n;
	if (g_dw2B2F0 != o1_n)
	{
		word32 g0_n = o1_n - o2_n;
		if (g0_n != 0x00)
		{
			exchange(o1);
			goto l00015F24;
		}
		o0_n = g_dw2B300;
	}
	else
		o0_n = g_dw2B300;
	int32 o1_n = optind;
	if (o0_n != o1_n)
		g_dw2B2F0 = o1_n;
l00015F24:
	int32 o2_n = optind;
	bool v44_n = o2_n >= o0;
	while (!v44_n)
	{
		Eq_n o0_n;
		o0_n.u0 = o1[o2_n];
		int32 o0_n;
		if ((int32) *o0_n.u0 == 0x2D)
		{
			if ((int32) *((word32) o0_n + 1) != 0x00)
				break;
			o0_n = optind;
		}
		else
			o0_n = optind;
		int32 o0_n = o0_n + 0x01;
		optind = o0_n;
		o2_n = o0_n;
		v44_n = o0_n >= o0;
	}
	g_dw2B300 = o2_n;
	goto l00015F78;
}

// 00016980: void getopt(Register int32 o0, Register (ptr32 Eq_n) o1, Register (ptr32 int8) o2)
void getopt(int32 o0, struct Eq_n * o1, int8 * o2)
{
	_getopt_internal(o0, o1, o2, null, null, 0x00);
}

// 000169A8: Register int32 getopt_long(Register int32 o0, Register (ptr32 Eq_n) o1, Register (ptr32 int8) o2, Register (ptr32 Eq_n) o3, Register (ptr32 word32) o4)
// Called from:
//      main
int32 getopt_long(int32 o0, struct Eq_n * o1, int8 * o2, struct Eq_n * o3, word32 * o4)
{
	return _getopt_internal(o0, o1, o2, o3, o4, 0x00);
}

// 000169D0: void getopt_long_only(Register int32 o0, Register (ptr32 Eq_n) o1, Register (ptr32 int8) o2, Register (ptr32 Eq_n) o3, Register (ptr32 word32) o4)
void getopt_long_only(int32 o0, struct Eq_n * o1, int8 * o2, struct Eq_n * o3, word32 * o4)
{
	_getopt_internal(o0, o1, o2, o3, o4, 0x01);
}

// 000169F8: Register Eq_n pexecute(Register Eq_n o1, Register Eq_n o2, Register word32 o3, Register (ptr32 word32) o4, Register (ptr32 word32) o5, Register Eq_n l1, Stack ui32 dwArg5C)
// Called from:
//      gen_aux_info_file
Eq_n pexecute(Eq_n o1, Eq_n o2, word32 o3, word32 * o4, word32 * o5, Eq_n l1, ui32 dwArg5C)
{
	<anonymous> * o0_n;
	if ((dwArg5C & 0x04) != 0x00)
		o0_n = (<anonymous> *) &execvp_GOT;
	else
		o0_n = (<anonymous> *) &execv_GOT;
	if ((dwArg5C & 0x01) != 0x00)
		g_dw2B310 = 0x00;
	int32 o0_n = g_dw2B310;
	word32 o0_n;
	int32 dwLoc24_n;
	if ((dwArg5C & 0x02) == 0x00)
	{
		int32 dwLoc18;
		if (pipe(&dwLoc18) < 0x00)
		{
			o0_n = 0x00017B18;
			goto l00016B10;
		}
		int32 o0_n = dwLoc18;
		g_dw2B310 = o0_n;
		int32 dwLoc14;
		dwLoc24_n = dwLoc14;
	}
	else
	{
		g_dw2B310 = 0x00;
		dwLoc24_n = 0x01;
	}
	uint32 dwLoc2C_n = 0x01;
	int32 dwLoc28_n;
	bool v34_n;
	for (dwLoc28_n = 0x00; dwLoc28_n <= 0x03; ++dwLoc28_n)
	{
		Eq_n o0_n = vfork();
		l1 = o0_n;
		if (o0_n >= 0x00)
		{
			v34_n = o0_n == ~0x00;
			goto l00016AEC;
		}
		sleep(dwLoc2C_n);
		dwLoc2C_n <<= 0x01;
	}
	v34_n = l1 == ~0x00;
l00016AEC:
	Eq_n i0_n;
	if (!v34_n)
	{
		if (l1 == 0x00)
		{
			if (o0_n != 0x00)
			{
				close(0x00);
				dup(o0_n);
				close(o0_n);
			}
			if (dwLoc24_n != 0x01)
			{
				close(0x01);
				dup(dwLoc24_n);
				close(dwLoc24_n);
			}
			int32 o0_n = g_dw2B310;
			if (o0_n != 0x00)
				close(o0_n);
			o0_n();
			fprintf(&g_t2B640, "%s: ", o2);
			Eq_n o0;
			fprintf(o0, install_error_msg, 0x00);
			fprintf(&g_t2B640, ": %s\n", xstrerror(errno));
			exit(~0x00);
		}
		else
		{
			if (o0_n != 0x00)
				close(o0_n);
			if (dwLoc24_n != 0x01)
			{
				close(dwLoc24_n);
				i0_n = l1;
			}
			else
				i0_n = l1;
			return i0_n;
		}
	}
	o0_n = 0x00017B20;
l00016B10:
	*o4 = o0_n;
	*o5 = 0x00;
	i0_n = ~0x00;
	return i0_n;
}

// 00016C2C: void pwait(Register (ptr32 int32) o1)
// Called from:
//      gen_aux_info_file
void pwait(int32 * o1)
{
	wait(o1);
}

// 00016C40: Register Eq_n mkstemps(Register Eq_n o0, Register Eq_n o1)
// Called from:
//      make_temp_file
Eq_n mkstemps(Eq_n o0, Eq_n o1)
{
	Eq_n dwLoc14;
	Eq_n o0_n = strlen(o0);
	Eq_n i0_n;
	if (o0_n >= (word32) o1 + 6)
	{
		Eq_n o0_n = o0_n - ((word32) o1 + 6);
		struct Eq_n * i1_n = o0 + o0_n;
		if (strncmp(i1_n, "XXXXXX", 0x06) != 0x00)
			i0_n.u0 = ~0x00;
		else
		{
			word32 dwLoc18;
			gettimeofday(&dwLoc18, null);
			Eq_n o0_n = getpid();
			uint64 o0_o1_n = g_qw2B400;
			int32 o7_n = dwLoc18;
			up32 o1_n = (word32) o0_o1_n + ((dwLoc14 << 0x10 ^ o7_n) ^ o0_n);
			g_qw2B400 = SEQ(SLICE(o0_o1_n, word32, 32) + (((dwLoc14 >> 0x10 | (dwLoc14 >> 0x1F) << 0x10) ^ o7_n >> 0x1F) ^ o0_n >> 0x1F) + (word32) (o1_n < 0x00), o1_n);
			int32 l3_n = 0x00;
			Eq_n o0_n;
			while (true)
			{
				uint64 l0_l1_n = g_qw2B400;
				i1_n->b0000 = ((word32) __urem64(l0_l1_n, 0x3E))->b17B38;
				uint64 o0_o1_n = __udiv64(l0_l1_n, 0x3E);
				i1_n->b0001 = ((word32) __urem64(o0_o1_n, 0x3E))->b17B38;
				uint64 o0_o1_n = __udiv64(o0_o1_n, 0x3E);
				i1_n->b0002 = ((word32) __urem64(o0_o1_n, 0x3E))->b17B38;
				uint64 o0_o1_n = __udiv64(o0_o1_n, 0x3E);
				i1_n->b0003 = ((word32) __urem64(o0_o1_n, 0x3E))->b17B38;
				uint64 o0_o1_n = __udiv64(o0_o1_n, 0x3E);
				i1_n->b0004 = ((word32) __urem64(o0_o1_n, 0x3E))->b17B38;
				i1_n->b0005 = ((word32) __urem64(__udiv64(o0_o1_n, 0x3E), 0x3E))->b17B38;
				o0_n = open(o0, 0x0502);
				if (o0_n >= 0x00)
					break;
				uint64 o2_o3_n = g_qw2B400;
				up32 o3_n = (word32) o2_o3_n;
				word32 o2_n = SLICE(o2_o3_n, word32, 32);
				word32 o2_n = o2_n + (word32) (o3_n < ~0x1E60);
				++l3_n;
				if (l3_n > 17575)
				{
					g_qw2B400 = SEQ(o2_n, o3_n + 7777);
					*o0.u0 = 0x00;
					goto l00016E58;
				}
				g_qw2B400 = SEQ(o2_n, o3_n + 7777);
			}
			i0_n = o0_n;
		}
	}
	else
	{
l00016E58:
		i0_n.u0 = ~0x00;
	}
	return i0_n;
}

// 00016E64: Register word32 fn00016E64(Register word32 o7, Register word32 l7)
// Called from:
//      __do_global_ctors_aux
word32 fn00016E64(word32 o7, word32 l7)
{
	return o7 + l7;
}

// 00016E6C: void __do_global_ctors_aux(Register word32 o3, Register word32 o4, Register word32 o5, Register word32 o7)
// Called from:
//      _init
void __do_global_ctors_aux(word32 o3, word32 o4, word32 o5, word32 o7)
{
	struct Eq_n * o1_n = fn00016E64(o7, 0x00010D08)->ptr0014;
	word32 o2_n = o1_n->dwFFFFFFFC;
	if (o2_n != ~0x00)
	{
		<anonymous> ** l0_n = &o1_n->dwFFFFFFFC;
		do
		{
			(*l0_n)();
			l0_n = (<anonymous> **) ((char *) l0_n - 4);
		} while (*l0_n != (<anonymous> *) ~0x00);
	}
}

// 00016EBC: void init_dummy()
void init_dummy()
{
}

