// hello_text_n.c
// Generated by decompiling hello.wasm
// using Reko decompiler version 0.12.2.0.

#include "hello.h"

// 000D0000: Stack Eq_n stackAlloc(Stack Eq_n arg0)
Eq_n stackAlloc(Eq_n arg0)
{
	g_t140030.u2 += arg0;
	g_t140030.u2 = (int8 *) (g_t140030.u2 + 0x0F & ~0x0F);
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(arg0);
	return <invalid>;
}

// 000D0028: Stack Eq_n stackSave()
Eq_n stackSave()
{
	return <invalid>;
}

// 000D002C: void stackRestore(Stack Eq_n arg0)
void stackRestore(Eq_n arg0)
{
	g_t140030.u2 = (int8 *) arg0;
}

// 000D0031: void establishStackSpace(Stack Eq_n arg0, Stack Eq_n arg1)
void establishStackSpace(Eq_n arg0, Eq_n arg1)
{
	g_t140030.u2 = (int8 *) arg0;
	g_t140034.u2 = (int8 *) arg1;
}

// 000D003D: void setThrew(Stack Eq_n arg0, Stack Eq_n arg1)
void setThrew(Eq_n arg0, Eq_n arg1)
{
	if (g_t140048.u2 == 0x00)
	{
		g_t140048.u2 = (int8 *) arg0;
		g_t14004C.u2 = (int8 *) arg1;
	}
}

// 000D004E: void setTempRet0(Stack Eq_n arg0)
void setTempRet0(Eq_n arg0)
{
	g_t140094.u2 = (int8 *) arg0;
}

// 000D0053: Stack Eq_n getTempRet0()
Eq_n getTempRet0()
{
	return <invalid>;
}

// 000D0057: Stack Eq_n fn000D0057()
// Called from:
//      fn000D0082
Eq_n fn000D0057()
{
	Eq_n v7_n;
	v7_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	g_t140030.u2 = (int8 *) v7_n;
	return <invalid>;
}

// 000D0082: void fn000D0082()
// Called from:
//      __GLOBAL__sub_I_hello_cpp
void fn000D0082()
{
	*(union Eq_n *) 0x4620 = fn000D0057();
}

// 000D0098: Stack Eq_n _main()
Eq_n _main()
{
	Eq_n v13_n;
	v13_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	fn000E6E2A(fn000D00FD(0x4908, 0x2A44), *(union Eq_n *) 0x4620);
	g_t140030.u2 = (int8 *) v13_n;
	return <invalid>;
}

// 000D00FD: Stack Eq_n fn000D00FD(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      _main
Eq_n fn000D00FD(Eq_n arg0, Eq_n arg1)
{
	Eq_n v12_n;
	v12_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	Eq_n v12_n = fn000D0290(arg0, arg1, fn000D0843(arg1));
	g_t140030.u2 = (int8 *) v12_n;
	return <invalid>;
}

// 000D0143: Stack Eq_n fn000D0143(Stack Eq_n arg0)
Eq_n fn000D0143(Eq_n arg0)
{
	Eq_n v45_n;
	v45_n.u2 = g_t140030.u2;
	g_t140030.u2 += 32;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x20);
	v45_n.u17[3] = (struct Eq_n) fn000E64CA(arg0.u2 + *((word32) (*arg0.u3) - 0x0C));
	g_t140048.u2 = (int8 *) 0x00;
	struct Eq_n ** v45_n = invoke_iii(0x0164, v45_n.u15 + 6, 0x4C70);
	Eq_n v45_n;
	v45_n.u2 = g_t140048.u2;
	g_t140048.u2 = (int8 *) 0x00;
	if ((v45_n & 0x01) == 0x00)
	{
		word32 v45_n = *((char *) *v45_n + 28);
		g_t140048.u2 = (int8 *) 0x00;
		Eq_n v45_n = invoke_iii(v45_n, v45_n, 0x0A);
		Eq_n v45_n;
		v45_n.u2 = g_t140048.u2;
		g_t140048.u2 = (int8 *) 0x00;
		if ((v45_n & 0x01) == 0x00)
		{
			fn0011B3FB(v45_n.u15 + 6);
			fn000E71A1(arg0, v45_n);
			fn000E6583(arg0);
			g_t140030.u2 = (int8 *) v45_n;
			return arg0;
		}
	}
	word32 v45_n = ___cxa_find_matching_catch_n();
	g_t140048.u2 = (int8 *) 0x00;
	invoke_vi(0x0165, v45_n.u15 + 6);
	Eq_n v45_n;
	v45_n.u2 = g_t140048.u2;
	g_t140048.u2 = (int8 *) 0x00;
	if (v45_n & 0x01)
		fn000D0E65(___cxa_find_matching_catch_n(0x00));
	else
		___resumeException(v45_n);
	return 0x00;
}

// 000D0290: Stack Eq_n fn000D0290(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000D00FD
Eq_n fn000D0290(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v164_n;
	v164_n.u2 = g_t140030.u2;
	g_t140030.u2 += 0x0080;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x80);
	g_t140048.u2 = (int8 *) 0x00;
	invoke_vii(0x0166, v164_n.u15 + 8, arg0);
	Eq_n v164_n;
	v164_n.u2 = g_t140048.u2;
	g_t140048.u2 = (int8 *) 0x00;
	word32 loc162;
	if (v164_n & 0x01)
	{
l000D0782:
		loc162 = 0x0F;
		goto l000D0783;
	}
	ui32 v164_n = (word32) v164_n.u17[4];
	if (!(v164_n & 0x01))
	{
l000D0750:
		goto l000D0750;
	}
	v164_n.u15[2] = (struct Eq_n) (arg0.u2 + *((word32) (*arg0.u3) - 0x0C))[24];
	Eq_n v164_n;
	v164_n.u2 = arg1 + arg2;
	Eq_n v164_n;
	if (((arg0.u2 + *((word32) (*arg0.u3) - 0x0C))[4] & 0xB0) == 0x20)
		v164_n = v164_n;
	else
		v164_n = arg1;
	ptr32 v164_n = arg0.u2 + *((word32) (*arg0.u3) - 0x0C);
	struct Eq_n * v164_n = (struct Eq_n *) (arg0.u2 + *((word32) (*arg0.u3) - 0x0C));
	word32 v164_n = arg1 + arg2;
	Eq_n v164_n = fn000D0E75(fn000D0EAE(), v164_n->t004C.u2);
	if (v164_n)
	{
		g_t140048.u2 = (int8 *) 0x00;
		Eq_n v164_n = invoke_ii(0x0167, v164_n);
		Eq_n v164_n;
		v164_n.u2 = g_t140048.u2;
		g_t140048.u2 = (int8 *) 0x00;
		if (v164_n & 0x01)
			loc162 = 0x10;
		else
		{
			*((word32) v164_n + 92) = v164_n;
			g_t140048.u2 = (int8 *) 0x00;
			struct Eq_n ** v164_n = invoke_iii(0x0164, (word32) v164_n + 92, 0x4C70);
			Eq_n v164_n;
			v164_n.u2 = g_t140048.u2;
			g_t140048.u2 = (int8 *) 0x00;
			word32 loc4;
			if ((v164_n & 0x01) == 0x00)
			{
				word32 v164_n = *((char *) *v164_n + 28);
				g_t140048.u2 = (int8 *) 0x00;
				word32 v164_n = invoke_iii(v164_n, v164_n, 0x20);
				Eq_n v164_n;
				v164_n.u2 = g_t140048.u2;
				g_t140048.u2 = (int8 *) 0x00;
				if ((v164_n & 0x01) == 0x00)
				{
					g_t140048.u2 = (int8 *) 0x00;
					invoke_vi(0x0165, (word32) v164_n + 92);
					Eq_n v164_n;
					v164_n.u2 = g_t140048.u2;
					g_t140048.u2 = (int8 *) 0x00;
					if (v164_n & 0x01)
						loc162 = 0x10;
					else
					{
						v164_n->t004C.u2 = (int32) (byte) v164_n;
						loc162 = 0x0C;
					}
l000D05FB:
					if (loc162 == 0x0C)
					{
						Eq_n v164_n;
						v164_n.u2 = v164_n->t004C.u2;
						g_t140048.u2 = (int8 *) 0x00;
						v164_n.u15[54] = v164_n.u15[2];
						word32 v164_n = invoke_iiiiiii(0x0168, v164_n.u15 + 54, arg1, v164_n, v164_n, v164_n, v164_n & 0xFF);
						Eq_n v164_n;
						v164_n.u2 = g_t140048.u2;
						g_t140048.u2 = (int8 *) 0x00;
						if (!(v164_n & 0x01))
						{
							*v164_n.u3 = v164_n;
							if (*v164_n.u3 == 0x00 == 0x00)
								goto l000D0750;
							struct Eq_n * v164_n = (struct Eq_n *) (arg0.u2 + *((word32) (*arg0.u3) - 0x0C));
							ui32 v164_n = v164_n->dw0010;
							g_t140048.u2 = (int8 *) 0x00;
							invoke_vii(0x0169, v164_n, v164_n | 0x05);
							Eq_n v164_n;
							v164_n.u2 = g_t140048.u2;
							g_t140048.u2 = (int8 *) 0x00;
							if (!(v164_n & 0x01))
							{
l000D0750:
								g_t140048.u2 = (int8 *) 0x00;
								invoke_vi(0x016A, v164_n.u15 + 8);
								Eq_n v164_n;
								v164_n.u2 = g_t140048.u2;
								g_t140048.u2 = (int8 *) 0x00;
								if (!(v164_n & 0x01))
								{
									g_t140030.u2 = (int8 *) v164_n;
									return arg0;
								}
								goto l000D0782;
							}
						}
						loc162 = 0x10;
					}
					if (loc162 == 0x10)
						loc4 = ___cxa_find_matching_catch_n(0x00);
					g_t140048.u2 = (int8 *) 0x00;
					invoke_vi(0x016A, v164_n.u15 + 8);
					Eq_n v164_n;
					v164_n.u2 = g_t140048.u2;
					g_t140048.u2 = (int8 *) 0x00;
					word32 loc82 = loc4;
					if ((v164_n & 0x01) == 0x00)
					{
l000D0783:
						if (loc162 == 0x0F)
							loc82 = ___cxa_find_matching_catch_n(0x00);
						___cxa_begin_catch(loc82);
						ptr32 v164_n = arg0.u2 + *((word32) (*arg0.u3) - 0x0C);
						g_t140048.u2 = (int8 *) 0x00;
						invoke_vi(363, v164_n);
						Eq_n v164_n;
						v164_n.u2 = g_t140048.u2;
						g_t140048.u2 = (int8 *) 0x00;
						if ((v164_n & 0x01) != 0x00)
						{
							word32 v164_n = ___cxa_find_matching_catch_n();
							g_t140048.u2 = (int8 *) 0x00;
							invoke_v(0x016C);
							Eq_n v164_n;
							v164_n.u2 = g_t140048.u2;
							g_t140048.u2 = (int8 *) 0x00;
							if (v164_n & 0x01)
								fn000D0E65(___cxa_find_matching_catch_n(0x00));
							else
								___resumeException(v164_n);
							return 0x00;
						}
						else
						{
							___cxa_end_catch();
							g_t140030.u2 = (int8 *) v164_n;
							return arg0;
						}
					}
					fn000D0E65(___cxa_find_matching_catch_n(0x00));
					goto l000D0750;
				}
			}
			word32 v164_n = ___cxa_find_matching_catch_n(0x00);
			g_t140048.u2 = (int8 *) 0x00;
			invoke_vi(0x0165, (word32) v164_n + 92);
			Eq_n v164_n;
			v164_n.u2 = g_t140048.u2;
			g_t140048.u2 = (int8 *) 0x00;
			if (!(v164_n & 0x01))
			{
				loc4 = v164_n;
				goto l000D05FB;
			}
			fn000D0E65(___cxa_find_matching_catch_n(0x00, 0x00));
		}
	}
	else
		loc162 = 0x0C;
	goto l000D05FB;
}

// 000D0843: Stack Eq_n fn000D0843(Stack Eq_n arg0)
// Called from:
//      fn000D00FD
Eq_n fn000D0843(Eq_n arg0)
{
	Eq_n v8_n;
	v8_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	Eq_n v8_n = fn000DAF30(arg0);
	g_t140030.u2 = (int8 *) v8_n;
	return <invalid>;
}

// 000D0874: Stack Eq_n fn000D0874(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3, Stack Eq_n arg4, Stack Eq_n arg5)
// Called from:
//      fn000F98EA
//      fn000F9A50
//      fn000F9BA0
//      fn000F9D06
//      fn000FA7EA
Eq_n fn000D0874(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3, Eq_n arg4, Eq_n arg5)
{
	Eq_n v194_n;
	v194_n.u2 = g_t140030.u2;
	g_t140030.u2 += 272;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x0110);
	Eq_n v194_n;
	v194_n.u2 = *arg0.u3;
	((word32) v194_n + 72)->u0 = 0x00;
	v194_n.u15[24] = (struct Eq_n) *((word32) v194_n + 72);
	if (v194_n != 0x00)
	{
		Eq_n v194_n = arg3 - arg1;
		Eq_n v194_n;
		v194_n.u2 = arg4.u17[3];
		Eq_n loc154_n;
		if (v194_n > v194_n)
			loc154_n = v194_n - v194_n;
		else
			loc154_n.u0 = 0x00;
		int32 v194_n = arg2 - arg1;
		if (v194_n <= 0x00 || (*((word32) (*(*arg0.u3)) + 48) & 0x01FF) + 0x0F20 == v194_n)
		{
			if (loc154_n > 0x00)
			{
				v194_n.u15[0x0A] = (struct Eq_n) 0x00;
				v194_n.u18->dw001C = (ui32) 0x00;
				fn0011BA32(v194_n.u15 + 0x0A, loc154_n, arg5);
				Eq_n v194_n;
				v194_n.u2 = *arg0.u3;
				Eq_n loc52_n;
				if (((word32) v194_n.u14[31] & 0x80) != 0x00)
					loc52_n.u2 = v194_n.u15[0x0A];
				else
					loc52_n.u15 = v194_n.u15 + 0x0A;
				word32 v194_n = *((word32) *v194_n.u3 + 48);
				g_t140048.u2 = (int8 *) 0x00;
				Eq_n v194_n = invoke_iiii(v194_n, v194_n, loc52_n, loc154_n);
				Eq_n v194_n;
				v194_n.u2 = g_t140048.u2;
				g_t140048.u2 = (int8 *) 0x00;
				if (v194_n & 0x01)
				{
					word32 v194_n = ___cxa_find_matching_catch_n();
					g_t140048.u2 = (int8 *) 0x00;
					invoke_vi(0x016D, v194_n.u15 + 0x0A);
					Eq_n v194_n;
					v194_n.u2 = g_t140048.u2;
					g_t140048.u2 = (int8 *) 0x00;
					if (v194_n & 0x01)
						fn000D0E65(___cxa_find_matching_catch_n(0x00));
					else
						___resumeException(v194_n);
				}
				up32 loc162_n;
				if (v194_n != loc154_n)
				{
					((word32) v194_n + 0x0088)->u0 = 0x00;
					v194_n.u15[4] = (struct Eq_n) *((word32) v194_n + 0x0088);
					*arg0.u3 = (int32) 0x00;
					((word32) v194_n + 0x0044)->u2 = *arg0.u3;
					loc162_n = 0x01;
				}
				else
					loc162_n = 0x00;
				fn0011BAF7(v194_n.u15 + 0x0A);
				if (loc162_n < 0x01 == 0x00)
				{
					Eq_n v194_n = *((word32) v194_n + 0x0044);
					g_t140030.u2 = (int8 *) v194_n;
					return v194_n;
				}
			}
			int32 v194_n = arg3 - arg2;
			if (v194_n <= 0x00 || (*((word32) (*(*arg0.u3)) + 48) & 0x01FF) + 0x0F20 == v194_n)
			{
				arg4.u17[3] = (struct Eq_n) 0x00;
				((word32) v194_n + 0x0044)->u2 = *arg0.u3;
				Eq_n v194_n = *((word32) v194_n + 0x0044);
				g_t140030.u2 = (int8 *) v194_n;
				return v194_n;
			}
			else
			{
				v194_n.u15[52] = (struct Eq_n) 0x00;
				*v194_n.u3 = (int32) v194_n.u15[52];
				*arg0.u3 = (int32) 0x00;
				((word32) v194_n + 0x0044)->u2 = *arg0.u3;
				Eq_n v198_n = *((word32) v194_n + 0x0044);
				g_t140030.u2 = (int8 *) v194_n;
				return v198_n;
			}
		}
		else
		{
			((word32) v194_n + 0x00AC)->u0 = 0x00;
			v194_n.u15[16] = (struct Eq_n) *((word32) v194_n + 0x00AC);
			*arg0.u3 = (int32) 0x00;
			((word32) v194_n + 0x0044)->u2 = *arg0.u3;
			Eq_n v198_n = *((word32) v194_n + 0x0044);
			g_t140030.u2 = (int8 *) v194_n;
			return v198_n;
		}
	}
	else
	{
		((word32) v194_n + 0x0044)->u2 = *arg0.u3;
		Eq_n v194_n = *((word32) v194_n + 0x0044);
		g_t140030.u2 = (int8 *) v194_n;
		return v194_n;
	}
}

// 000D0E65: void fn000D0E65(Stack Eq_n arg0)
// Called from:
//      fn000D0143
//      fn000D0290
//      fn000D0874
//      fn000E5823
//      fn000E6583
//      fn000E680D
//      fn000E69FB
//      fn000E6C85
//      fn000E6E2A
//      fn000E71A1
//      fn000E7931
//      fn000EAD98
//      fn000FA95B
//      fn000FADDC
//      fn00106868
//      fn00106A39
//      fn001071CE
//      fn001078B8
//      fn00107E62
//      fn0010B494
//      fn0010BEC2
//      fn0010C004
//      fn0010C171
//      fn0010C889
//      fn0010CE53
//      fn00110427
//      fn00110E8A
//      fn00111F27
//      fn00114190
//      fn00116E5E
//      fn0011742D
//      fn001179EC
//      fn00117B7D
//      fn00117D2C
//      fn00117EC5
//      fn00117F62
//      fn00119770
//      fn001197B3
//      fn001197F6
//      fn0011B395
//      fn0011B49F
//      fn0011E21F
//      fn0011E2BD
void fn000D0E65(Eq_n arg0)
{
	___cxa_begin_catch(arg0);
	fn0011E21F();
}

// 000D0E75: Stack Eq_n fn000D0E75(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000D0290
Eq_n fn000D0E75(Eq_n arg0, Eq_n arg1)
{
	Eq_n v10_n;
	v10_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	g_t140030.u2 = (int8 *) v10_n;
	return <invalid>;
}

// 000D0EAE: Stack Eq_n fn000D0EAE()
// Called from:
//      fn000D0290
Eq_n fn000D0EAE()
{
	return <invalid>;
}

// 000D0EB9: void __GLOBAL__sub_I_hello_cpp()
void __GLOBAL__sub_I_hello_cpp()
{
	fn000D0082();
}

// 000D0EC4: Stack Eq_n fn000D0EC4(Stack Eq_n arg0)
Eq_n fn000D0EC4(Eq_n arg0)
{
	Eq_n v10_n;
	v10_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	*v10_n.u3 = (int32) *((word32) arg0 + 60);
	Eq_n v10_n = fn000D12B7(___syscall6(0x06, v10_n));
	g_t140030.u2 = (int8 *) v10_n;
	return <invalid>;
}

// 000D0F0D: Stack Eq_n fn000D0F0D(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000D15A4
Eq_n fn000D0F0D(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v72_n;
	v72_n.u2 = g_t140030.u2;
	g_t140030.u2 += 48;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x30);
	Eq_n v72_n;
	v72_n.u2 = arg0.u18->dw001C;
	v72_n.u15[16] = (struct Eq_n) v72_n;
	Eq_n v72_n = arg0.u15[0x0A] - v72_n;
	v72_n.u15[18] = (struct Eq_n) v72_n;
	v72_n.u15[20] = (struct Eq_n) arg1;
	v72_n.u15[22] = (struct Eq_n) arg2;
	Eq_n loc4_n;
	loc4_n.u0 = 0x02;
	Eq_n loc5_n;
	loc5_n.u2 = v72_n + arg2;
	Eq_n loc6_n;
	loc6_n.u15 = v72_n.u15 + 16;
	word32 loc70_n;
	while (true)
	{
		Eq_n loc3_n;
		if (*(word32 *) 0x4624 == 0x00)
		{
			v72_n.u17[4] = (struct Eq_n) *((word32) arg0 + 60);
			v72_n.u15[0x0A] = (struct Eq_n) loc6_n;
			v72_n.u15[0x0C] = (struct Eq_n) loc4_n;
			loc3_n = fn000D12B7(___syscall146(0x92, v72_n.u15 + 8));
		}
		else
		{
			_pthread_cleanup_push(366, arg0);
			*v72_n.u3 = (int32) *((word32) arg0 + 60);
			v72_n.u15[2] = (struct Eq_n) loc6_n;
			v72_n.u15[4] = (struct Eq_n) loc4_n;
			Eq_n v72_n = fn000D12B7(___syscall146(0x92, v72_n));
			_pthread_cleanup_pop(0x00);
			loc3_n = v72_n;
		}
		if (loc5_n == loc3_n)
			break;
		if (loc3_n < 0x00)
		{
			loc70_n = 0x08;
			goto l000D1154;
		}
		Eq_n v72_n;
		v72_n.u2 = loc6_n.u15[2];
		Eq_n v72_n = loc5_n - loc3_n;
		Eq_n loc8_n;
		Eq_n loc9_n;
		Eq_n loc10_n;
		Eq_n loc59_n;
		if (loc3_n > v72_n)
		{
			Eq_n v72_n;
			v72_n.u2 = arg0.u15[22];
			arg0.u18->dw001C = (ui32) v72_n;
			arg0.u15[0x0A] = (struct Eq_n) v72_n;
			loc8_n = loc3_n - v72_n;
			loc9_n.u2 = &loc4_n.u15->bFFFFFFFF;
			loc10_n.u15 = loc6_n.u15 + 4;
			loc59_n.u2 = loc6_n.u17[3];
		}
		else
		{
			if (loc4_n == 0x02)
			{
				arg0.u18->dw001C = loc3_n.u2 + (arg0.u18)->dw001C;
				loc9_n.u0 = 0x02;
			}
			else
				loc9_n = loc4_n;
			loc59_n = v72_n;
			loc8_n = loc3_n;
			loc10_n = loc6_n;
		}
		*loc10_n.u3 = loc8_n.u2 + *loc10_n.u3;
		loc10_n.u15[2] = (struct Eq_n) (loc59_n - loc8_n);
		loc4_n = loc9_n;
		loc5_n = v72_n;
		loc6_n = loc10_n;
	}
	loc70_n = 0x06;
l000D1154:
	switch (loc70_n)
	{
	case 0x06:
		Eq_n v72_n;
		v72_n.u2 = arg0.u15[22];
		arg0.u17[4] = (struct Eq_n) (v72_n + (arg0.u15)[24]);
		arg0.u18->dw001C = (ui32) v72_n;
		arg0.u15[0x0A] = (struct Eq_n) v72_n;
		break;
	case 0x08:
		arg0.u17[4] = (struct Eq_n) 0x00;
		arg0.u18->dw001C = (ui32) 0x00;
		arg0.u15[0x0A] = (struct Eq_n) 0x00;
		*arg0.u3 = (int32) (*arg0.u3 | 0x20);
		break;
	}
	g_t140030.u2 = (int8 *) v72_n;
	return <invalid>;
}

// 000D120B: Stack Eq_n fn000D120B(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
Eq_n fn000D120B(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v18_n;
	v18_n.u2 = g_t140030.u2;
	g_t140030.u2 += 32;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x20);
	*v18_n.u3 = (int32) *((word32) arg0 + 60);
	v18_n.u15[2] = (struct Eq_n) 0x00;
	v18_n.u15[4] = (struct Eq_n) arg1;
	v18_n.u17[3] = (struct Eq_n) (v18_n.u15 + 0x0A);
	v18_n.u17[4] = (struct Eq_n) arg2;
	if (fn000D12B7(___syscall140(0x8C, v18_n)) < 0x00)
		v18_n.u15[0x0A] = (struct Eq_n) ~0x00;
	g_t140030.u2 = (int8 *) v18_n;
	return <invalid>;
}

// 000D12B7: Stack Eq_n fn000D12B7(Stack Eq_n arg0)
// Called from:
//      fn000D0EC4
//      fn000D0F0D
//      fn000D120B
//      fn000D135A
Eq_n fn000D12B7(Eq_n arg0)
{
	if (arg0 > ~0x0FFF)
		*___errno_location().u3 = 0x00 - arg0;
	return <invalid>;
}

// 000D12EA: Stack Eq_n ___errno_location()
// Called from:
//      fn000D12B7
//      fn000D1804
//      fn000D29A3
//      fn000D2E2C
//      fn000D779F
//      fn000D7B90
//      fn000DB07F
//      fn000DB4B6
//      fn000DD983
//      _malloc
//      fn000E3E00
//      fn000EBF56
//      fn000ECB14
//      fn000ED4F8
//      fn000EE0A5
//      fn000EEA53
//      fn000EF41F
//      fn000EFDEB
//      fn000F07BB
//      fn000F1165
Eq_n ___errno_location()
{
	if (*(word32 *) 0x4624 != 0x00)
		_pthread_self();
	return <invalid>;
}

// 000D1329: void fn000D1329(Stack Eq_n arg0)
void fn000D1329(Eq_n arg0)
{
	if (*((word32) arg0 + 0x0044) == 0x00)
		fn000D1351(arg0);
}

// 000D1351: void fn000D1351(Stack Eq_n arg0)
// Called from:
//      fn000D1329
//      fn000D157C
//      fn000D2BD4
//      _fflush
//      fn000DBA9B
//      fn000DEB18
//      fn000DEC35
//      fn000DEDA6
void fn000D1351(Eq_n arg0)
{
}

// 000D135A: Stack Eq_n fn000D135A(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
Eq_n fn000D135A(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v55_n;
	v55_n.u2 = g_t140030.u2;
	g_t140030.u2 += 48;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x30);
	v55_n.u15[16] = (struct Eq_n) arg1;
	Eq_n v55_n;
	v55_n.u2 = arg0.u15[24];
	v55_n.u15[18] = (struct Eq_n) (arg2 - (v55_n != 0x00 & 0x01));
	v55_n.u15[20] = arg0.u15[22];
	v55_n.u15[22] = (struct Eq_n) v55_n;
	Eq_n loc3_n;
	if (*(word32 *) 0x4624 == 0x00)
	{
		v55_n.u17[4] = (struct Eq_n) *((word32) arg0 + 60);
		v55_n.u15[0x0A] = (struct Eq_n) (v55_n.u15 + 16);
		v55_n.u15[0x0C] = (struct Eq_n) 0x02;
		loc3_n = fn000D12B7(___syscall145(0x91, v55_n.u15 + 8));
	}
	else
	{
		_pthread_cleanup_push(0x016F, arg0);
		*v55_n.u3 = (int32) *((word32) arg0 + 60);
		v55_n.u15[2] = (struct Eq_n) (v55_n.u15 + 16);
		v55_n.u15[4] = (struct Eq_n) 0x02;
		Eq_n v55_n = fn000D12B7(___syscall145(0x91, v55_n));
		_pthread_cleanup_pop(0x00);
		loc3_n = v55_n;
	}
	if (loc3_n < 0x01)
	{
		*arg0.u3 = (int32) (*arg0.u3 | loc3_n & 0x30 ^ 0x10);
		arg0.u15[4] = (struct Eq_n) 0x00;
		arg0.u15[2] = (struct Eq_n) 0x00;
	}
	else
	{
		Eq_n v55_n;
		v55_n.u2 = v55_n.u15[18];
		if (loc3_n > v55_n)
		{
			Eq_n v55_n;
			v55_n.u2 = arg0.u15[22];
			arg0.u15[2] = (struct Eq_n) v55_n;
			arg0.u15[4] = (struct Eq_n) (v55_n + (loc3_n - v55_n));
			if (arg0.u15[24] != 0x00)
			{
				arg0.u15[2] = (struct Eq_n) (v55_n.u14 + 1);
				*(arg1 + &(arg2.u15)->bFFFFFFFF) = (word32) *v55_n.u2;
			}
		}
	}
	g_t140030.u2 = (int8 *) v55_n;
	return <invalid>;
}

// 000D157C: void fn000D157C(Stack Eq_n arg0)
void fn000D157C(Eq_n arg0)
{
	if (*((word32) arg0 + 0x0044) == 0x00)
		fn000D1351(arg0);
}

// 000D15A4: Stack Eq_n fn000D15A4(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
Eq_n fn000D15A4(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v19_n;
	v19_n.u2 = g_t140030.u2;
	g_t140030.u2 += 80;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x50);
	arg0.u15[18] = (struct Eq_n) 0x02;
	if ((*arg0.u3 & 0x40) == 0x00)
	{
		*v19_n.u3 = (int32) *((word32) arg0 + 60);
		v19_n.u15[2] = (struct Eq_n) 0x5401;
		v19_n.u15[4] = (struct Eq_n) (v19_n.u15 + 6);
		if (___syscall54(0x36, v19_n) == 0x00 == 0x00)
			arg0.u15->b004B = ~0x00;
	}
	Eq_n v19_n = fn000D0F0D(arg0, arg1, arg2);
	g_t140030.u2 = (int8 *) v19_n;
	return <invalid>;
}

// 000D165D: Stack word64 fn000D165D(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3)
// Called from:
//      fn000EE0A5
//      fn000EEA53
//      fn000EF41F
//      fn000EFDEB
word64 fn000D165D(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3)
{
	return <invalid>;
}

// 000D1672: Stack word64 fn000D1672(Stack word32 arg0, Stack word32 arg1, Stack word32 arg2)
// Called from:
//      fn000D165D
word64 fn000D1672(word32 arg0, word32 arg1, word32 arg2)
{
	return <invalid>;
}

// 000D1689: Stack word64 fn000D1689(Stack Eq_n arg0, Stack (ptr32 int32) arg1, Stack (ptr32 int32) arg2, Stack Eq_n arg3)
// Called from:
//      fn000D1672
//      fn000D2872
word64 fn000D1689(Eq_n arg0, int32 * arg1, int32 * arg2, Eq_n arg3)
{
	Eq_n v22_n;
	v22_n.u2 = g_t140030.u2;
	g_t140030.u2 += 112;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x70);
	*v22_n.u3 = 0x00;
	v22_n.u15[2] = (struct Eq_n) arg0;
	v22_n.u15[22] = (struct Eq_n) arg0;
	Eq_n v22_n;
	if (arg0 < 0x00)
		v22_n.u0 = ~0x00;
	else
		v22_n.u2 = (word32) arg0 + 0x7FFFFFFF;
	v22_n.u15[4] = (struct Eq_n) v22_n;
	v22_n.u15[38] = (struct Eq_n) ~0x00;
	fn000D1767(v22_n, 0x00);
	Eq_n v27_n = fn000D1804(v22_n, arg2, &g_dw0001, arg3);
	if (arg1 == null == 0x00)
		*arg1 = arg0.u2 + (((v22_n.u15)[2] + (v22_n.u15)[54]) - (v22_n.u15)[4]);
	g_t140030.u2 = (int8 *) v22_n;
	return <invalid>;
}

// 000D1767: void fn000D1767(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000D1689
//      fn000D1804
//      fn000D7B90
//      fn000DBA9B
//      fn000DEF2C
void fn000D1767(Eq_n arg0, Eq_n arg1)
{
	arg0.u15[52] = (struct Eq_n) arg1;
	Eq_n v19_n;
	v19_n.u2 = arg0.u15[4];
	Eq_n v19_n;
	v19_n.u2 = arg0.u15[2];
	Eq_n v19_n = v19_n - v19_n;
	arg0.u15[54] = (struct Eq_n) v19_n;
	if (arg1 != 0x00 & v19_n > arg1)
		arg0.u15[50] = (struct Eq_n) (v19_n + arg1);
	else
		arg0.u15[50] = (struct Eq_n) v19_n;
}

// 000D17F5: Stack word64 fn000D17F5(Stack Eq_n arg0, Stack uint64 arg1)
// Called from:
//      fn000D1804
//      fn000D2E2C
//      fn000D68BF
//      fn000D7B90
word64 fn000D17F5(Eq_n arg0, uint64 arg1)
{
	return <invalid>;
}

// 000D1804: Stack word64 fn000D1804(Stack Eq_n arg0, Stack (ptr32 int32) arg1, Stack (ptr32 int32) arg2, Stack Eq_n arg3)
// Called from:
//      fn000D1689
//      fn000DBA9B
word64 fn000D1804(Eq_n arg0, int32 * arg1, int32 * arg2, Eq_n arg3)
{
	if (arg1 > (char *) (&g_t001F) + 5)
	{
		*___errno_location().u3 = 22;
		return <invalid>;
	}
	Eq_n loc82_n;
	do
	{
		Eq_n v278_n;
		v278_n.u2 = arg0.u15[2];
		if (v278_n < (arg0.u15)[50])
		{
			arg0.u15[2] = (struct Eq_n) (v278_n.u14 + 1);
			loc82_n = (word32) *v278_n.u2 & 0xFF;
		}
		else
			loc82_n = fn000D2493(arg0);
	} while (fn000D2665(loc82_n) != 0x00);
	Eq_n loc7_n;
	switch (loc82_n)
	{
	case 0x2B:
		goto l000D18C7;
	case 44:
l000D18C7:
		Eq_n v278_n;
		v278_n.u2 = arg0.u15[2];
		if (v278_n < (arg0.u15)[50])
		{
			arg0.u15[2] = (struct Eq_n) (v278_n.u14 + 1);
			loc7_n = (word32) *v278_n.u2 & 0xFF;
		}
		else
			loc7_n = fn000D2493(arg0);
		break;
	case 0x2D:
		Mem172 = Mem90;
		loc7_n = loc82_n;
		break;
	}
	ui32 v278_n = (arg1 | 0x10) == 0x10 & loc7_n == 0x30;
	word32 loc243_n;
	Eq_n loc10;
	int32 * loc12;
	if (v278_n)
	{
		Eq_n v278_n;
		v278_n.u2 = arg0.u15[2];
		Eq_n loc175_n;
		if (v278_n < (arg0.u15)[50])
		{
			arg0.u15[2] = (struct Eq_n) (v278_n.u14 + 1);
			loc175_n = (word32) *v278_n.u2 & 0xFF;
		}
		else
			loc175_n = fn000D2493(arg0);
		Eq_n loc11;
		int32 * loc14;
		if ((loc175_n | 0x20) == 0x78 == 0x00)
		{
			if (arg1 == null)
			{
				loc11 = loc175_n;
				loc14 = (int32 *) &g_t0008;
				loc243_n = 0x2E;
			}
			else
			{
				loc10 = loc175_n;
				loc12 = arg1;
				loc243_n = 0x20;
			}
l000D1BBE:
			int32 loc9;
			Eq_n loc254;
			int32 * loc13;
			Eq_n loc253;
			Eq_n loc29;
			if (loc243_n == 0x20)
			{
				if (loc12 == &g_dw000A)
				{
					Eq_n v278_n = (word32) loc10 - 48;
					Eq_n loc248_n;
					Eq_n loc18_n;
					if (v278_n < 0x0A)
					{
						uint32 loc4_n = 0x00;
						Eq_n loc213_n = v278_n;
						uint32 v278_n;
						Eq_n loc17_n;
						while (true)
						{
							Eq_n v278_n;
							v278_n.u2 = arg0.u15[2];
							v278_n = (word32) loc213_n + loc4_n * 0x0A;
							if (v278_n < (arg0.u15)[50])
							{
								arg0.u15[2] = (struct Eq_n) (v278_n.u14 + 1);
								loc17_n = (word32) *v278_n.u2 & 0xFF;
							}
							else
								loc17_n = fn000D2493(arg0);
							Eq_n v278_n = (word32) loc17_n - 48;
							if (!(v278_n < 0x0A & v278_n < 0x19999999))
								break;
							loc4_n = v278_n;
							loc213_n = v278_n;
						}
						loc248_n.u2 = (uint64) v278_n;
						loc18_n = loc17_n;
					}
					else
					{
						loc248_n.u0 = 0x00;
						loc18_n = loc10;
					}
					Eq_n v278_n = (word32) loc18_n - 48;
					if (v278_n < 0x0A)
					{
						Eq_n loc247_n = loc248_n;
						Eq_n loc21_n = loc18_n;
						Eq_n loc228_n = v278_n;
						Eq_n loc246_n;
						Eq_n loc20_n;
						Eq_n loc31_n;
						while (true)
						{
							int64 v291_n = (int64) loc228_n;
							Eq_n v281_n = loc247_n *64 0x0A;
							if (v281_n > ~v291_n)
								break;
							Eq_n v278_n;
							v278_n.u2 = arg0.u15[2];
							Eq_n v281_n;
							v281_n.u2 = (word64) v281_n.u1 + v291_n;
							Eq_n loc19_n;
							if (v278_n < (arg0.u15)[50])
							{
								arg0.u15[2] = (struct Eq_n) (v278_n.u14 + 1);
								loc19_n = (word32) *v278_n.u2 & 0xFF;
							}
							else
								loc19_n = fn000D2493(arg0);
							Eq_n v278_n = (word32) loc19_n - 48;
							if (!(v278_n < 0x0A & v281_n < 0x9999999A))
							{
								loc246_n = v281_n;
								loc20_n = loc19_n;
								loc31_n = v278_n;
								goto l000D1DD4;
							}
							loc247_n = v281_n;
							loc21_n = loc19_n;
							loc228_n = v278_n;
						}
						loc246_n = loc247_n;
						loc20_n = loc21_n;
						loc31_n = loc228_n;
l000D1DD4:
						if (loc31_n > 0x09)
						{
							loc9 = 0;
							loc254 = loc246_n;
						}
						else
						{
							loc13 = &g_dw000A;
							loc253 = loc246_n;
							loc29 = loc20_n;
							loc243_n = 0x48;
						}
					}
					else
					{
						loc9 = 0;
						loc254 = loc248_n;
					}
				}
				else
				{
					loc11 = loc10;
					loc14 = loc12;
					loc243_n = 0x2E;
				}
			}
			if (loc243_n == 0x2E)
			{
				if ((loc14 + (int32 *) ~0x00 & loc14) == 0x00)
				{
					ui32 v278_n = (word32) loc11.u14[0x00002A5A];
					int32 v278_n = (int32) (loc14 * 0x17 >> 0x05 & 0x07)->b2B5A;
					Eq_n loc249_n;
					Eq_n loc23_n;
					ui32 loc75_n;
					if ((v278_n & 0xFF) < loc14)
					{
						uint32 loc8_n = 0x00;
						ui32 loc58_n = v278_n & 0xFF;
						uint32 v278_n;
						Eq_n loc22_n;
						ui32 v278_n;
						while (true)
						{
							Eq_n v278_n;
							v278_n.u2 = arg0.u15[2];
							v278_n = loc58_n | loc8_n << v278_n;
							if (v278_n < (arg0.u15)[50])
							{
								arg0.u15[2] = (struct Eq_n) (v278_n.u14 + 1);
								loc22_n = (word32) *v278_n.u2 & 0xFF;
							}
							else
								loc22_n = fn000D2493(arg0);
							v278_n = (word32) loc22_n.u14[0x00002A5A];
							if (!(v278_n < 0x08000000 & (v278_n & 0xFF) < loc14))
								break;
							loc8_n = v278_n;
							loc58_n = v278_n & 0xFF;
						}
						loc249_n.u2 = (uint64) v278_n;
						loc23_n = loc22_n;
						loc75_n = v278_n;
					}
					else
					{
						loc249_n.u0 = 0x00;
						loc23_n = loc11;
						loc75_n = v278_n;
					}
					uint64 v289_n = (uint64) v278_n;
					Eq_n v281_n = ~0x00 >> v289_n;
					if ((loc75_n & 0xFF) >= loc14 | loc249_n > v281_n)
					{
						loc13 = loc14;
						loc253 = loc249_n;
						loc29 = loc23_n;
						loc243_n = 0x48;
					}
					else
					{
						Eq_n loc250_n = loc249_n;
						ui32 loc78_n = loc75_n;
						Eq_n v281_n;
						Eq_n loc24_n;
						while (true)
						{
							Eq_n v278_n;
							v278_n.u2 = arg0.u15[2];
							v281_n = (uint64) (loc78_n & 0xFF) | loc250_n << v289_n;
							if (v278_n < (arg0.u15)[50])
							{
								arg0.u15[2] = (struct Eq_n) (v278_n.u14 + 1);
								loc24_n = (word32) *v278_n.u2 & 0xFF;
							}
							else
								loc24_n = fn000D2493(arg0);
							ui32 v278_n = (word32) loc24_n.u14[0x00002A5A];
							if ((v278_n & 0xFF) >= loc14 | v281_n > v281_n)
								break;
							loc250_n = v281_n;
							loc78_n = v278_n;
						}
						loc13 = loc14;
						loc253 = v281_n;
						loc29 = loc24_n;
						loc243_n = 0x48;
					}
					goto l000D22B7;
				}
				ui32 v278_n = (word32) loc11.u14[0x00002A5A];
				Eq_n loc251_n;
				Eq_n loc26_n;
				ui32 loc111_n;
				if ((v278_n & 0xFF) < loc14)
				{
					uint32 loc16_n = 0x00;
					ui32 loc95_n = v278_n & 0xFF;
					uint32 v278_n;
					Eq_n loc25_n;
					ui32 v278_n;
					while (true)
					{
						Eq_n v278_n;
						v278_n.u2 = arg0.u15[2];
						v278_n = loc95_n + loc16_n * loc14;
						if (v278_n < (arg0.u15)[50])
						{
							arg0.u15[2] = (struct Eq_n) (v278_n.u14 + 1);
							loc25_n = (word32) *v278_n.u2 & 0xFF;
						}
						else
							loc25_n = fn000D2493(arg0);
						v278_n = (word32) loc25_n.u14[0x00002A5A];
						if (!(v278_n < 0x071C71C7 & (v278_n & 0xFF) < loc14))
							break;
						loc16_n = v278_n;
						loc95_n = v278_n & 0xFF;
					}
					loc251_n.u2 = (uint64) v278_n;
					loc26_n = loc25_n;
					loc111_n = v278_n;
				}
				else
				{
					loc251_n.u0 = 0x00;
					loc26_n = loc11;
					loc111_n = v278_n;
				}
				uint64 v289_n = (uint64) loc14;
				if ((loc111_n & 0xFF) < loc14)
				{
					Eq_n v281_n = fn000D17F5(~0x00, v289_n);
					Eq_n loc252_n = loc251_n;
					Eq_n loc28_n = loc26_n;
					ui32 loc115_n = loc111_n;
					while (loc252_n <= v281_n)
					{
						uint64 v289_n = (uint64) (loc115_n & 0xFF);
						uint64 v281_n = loc252_n *64 v289_n;
						if (v281_n > ~v289_n)
						{
							loc13 = loc14;
							loc253 = loc252_n;
							loc29 = loc28_n;
							loc243_n = 0x48;
							goto l000D22B7;
						}
						Eq_n v278_n;
						v278_n.u2 = arg0.u15[2];
						Eq_n v281_n = v289_n + v281_n;
						Eq_n loc27_n;
						if (v278_n < (arg0.u15)[50])
						{
							arg0.u15[2] = (struct Eq_n) (v278_n.u14 + 1);
							loc27_n = (word32) *v278_n.u2 & 0xFF;
						}
						else
							loc27_n = fn000D2493(arg0);
						ui32 v278_n = (word32) loc27_n.u14[0x00002A5A];
						if ((v278_n & 0xFF) >= loc14)
						{
							loc253 = v281_n;
							loc29 = loc27_n;
							goto l000D22B5;
						}
						loc252_n = v281_n;
						loc28_n = loc27_n;
						loc115_n = v278_n;
					}
					loc13 = loc14;
					loc253 = loc252_n;
					loc29 = loc28_n;
					loc243_n = 0x48;
l000D22B7:
					if (loc243_n == 0x48)
					{
						if (((word32) loc29.u14[0x00002A5A] & 0xFF) < loc13)
						{
							Eq_n loc30_n;
							do
							{
								Eq_n v278_n;
								v278_n.u2 = arg0.u15[2];
								if (v278_n < (arg0.u15)[50])
								{
									arg0.u15[2] = (struct Eq_n) (v278_n.u14 + 1);
									loc30_n = (word32) *v278_n.u2 & 0xFF;
								}
								else
									loc30_n = fn000D2493(arg0);
							} while (((word32) loc30_n.u14[0x00002A5A] & 0xFF) < loc13 != 0x00);
							*___errno_location().u3 = 0x22;
							loc254 = arg3;
						}
						else
							loc254 = loc253;
						loc9 = 0;
					}
					if (arg0.u15[50] == 0x00 == 0x00)
						arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
					if (loc254 < arg3 != 0x00)
						return <invalid>;
					if (((arg3 & 0x01) != 0x00 | loc9 != 0x00) != 0x00)
					{
						if (loc254 <= arg3)
							return <invalid>;
						*___errno_location().u3 = 0x22;
						return <invalid>;
					}
					else
					{
						*___errno_location().u3 = 0x22;
						return <invalid>;
					}
				}
				loc253 = loc251_n;
				loc29 = loc26_n;
l000D22B5:
				loc13 = loc14;
				loc243_n = 0x48;
			}
			goto l000D22B7;
		}
		Mem275 = Mem754;
		Eq_n v278_n;
		v278_n.u2 = arg0.u15[2];
		Eq_n loc186_n;
		if (v278_n < (arg0.u15)[50])
		{
			arg0.u15[2] = (struct Eq_n) (v278_n.u14 + 1);
			loc186_n = (word32) *v278_n.u2 & 0xFF;
		}
		else
			loc186_n = fn000D2493(arg0);
		if (((word32) loc186_n.u14[0x00002A5A] & 0xFF) > 0x0F)
		{
			Eq_n v278_n;
			v278_n.u2 = arg0.u15[50];
			if (v278_n == 0x00 == 0x00)
				arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
			if (arg2 == null)
				fn000D1767(arg0, 0x00);
			else if (v278_n != 0x00)
				arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
			return <invalid>;
		}
		loc11 = loc186_n;
		loc14 = &g_dw0010;
		loc243_n = 0x2E;
	}
	else
	{
		int32 * v278_n;
		if (arg1 == null)
			v278_n = &g_dw000A;
		else
			v278_n = arg1;
		if (((word32) loc7_n.u14[0x00002A5A] & 0xFF) >= v278_n)
		{
			if (arg0.u15[50] == 0x00 == 0x00)
				arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
			fn000D1767(arg0, 0x00);
			*___errno_location().u3 = 22;
			return <invalid>;
		}
		loc10 = loc7_n;
		loc12 = v278_n;
		loc243_n = 0x20;
	}
	goto l000D1BBE;
}

// 000D2493: Stack Eq_n fn000D2493(Stack Eq_n arg0)
// Called from:
//      fn000D1804
//      fn000D7B90
//      fn000DA625
//      fn000DBA9B
Eq_n fn000D2493(Eq_n arg0)
{
	Eq_n v52_n;
	v52_n.u2 = arg0.u15[52];
	word32 loc48_n;
	if (v52_n == 0x00)
		loc48_n = 0x03;
	else if (arg0.u15[54] < v52_n)
		loc48_n = 0x03;
	else
		loc48_n = 0x04;
	if (loc48_n == 0x03)
	{
		Eq_n v52_n = fn000D2693(arg0);
		if (v52_n < 0x00)
			loc48_n = 0x04;
		else
		{
			Eq_n v52_n;
			v52_n.u2 = arg0.u15[52];
			Eq_n v52_n;
			v52_n.u2 = arg0.u15[4];
			Eq_n loc42;
			Eq_n loc25;
			if (v52_n == 0x00)
			{
				loc42 = v52_n;
				loc48_n = 0x09;
			}
			else
			{
				Eq_n v52_n;
				v52_n.u2 = arg0.u15[2];
				int32 v52_n = v52_n - (arg0.u15)[54];
				if (v52_n - v52_n < v52_n)
				{
					loc42 = v52_n;
					loc48_n = 0x09;
				}
				else
				{
					arg0.u15[50] = (struct Eq_n) (v52_n.u2 + (v52_n + ~0x00));
					loc25 = v52_n;
				}
			}
			if (loc48_n == 0x09)
			{
				arg0.u15[50] = (struct Eq_n) v52_n;
				loc25 = loc42;
			}
			Eq_n loc36_n;
			if (loc25 == 0x00)
				loc36_n.u2 = arg0.u15[2];
			else
			{
				Eq_n v52_n;
				v52_n.u2 = arg0.u15[2];
				arg0.u15[54] = (struct Eq_n) (arg0.u15[54].a0000.u2.u2 + ((loc25.u14 + 1) - v52_n));
				loc36_n = v52_n;
			}
			int8 * v52_n = &loc36_n.u15->bFFFFFFFF;
			if (((word32) *v52_n & 0xFF) != v52_n)
				*v52_n = (byte) v52_n;
		}
	}
	if (loc48_n == 0x04)
		arg0.u15[50] = (struct Eq_n) 0x00;
	return <invalid>;
}

// 000D2665: Stack Eq_n fn000D2665(Stack Eq_n arg0)
// Called from:
//      fn000D1804
//      fn000D7B90
//      fn000DBA9B
Eq_n fn000D2665(Eq_n arg0)
{
	return <invalid>;
}

// 000D2693: Stack Eq_n fn000D2693(Stack Eq_n arg0)
// Called from:
//      fn000D2493
//      fn000DEE2E
Eq_n fn000D2693(Eq_n arg0)
{
	Eq_n v18_n;
	v18_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	word32 loc14;
	if (arg0.u15[4] == 0x00)
	{
		if (fn000D2742(arg0) == 0x00)
			loc14 = 0x03;
	}
	else
		loc14 = 0x03;
	g_t140030.u2 = (int8 *) v18_n;
	return <invalid>;
}

// 000D2742: Stack Eq_n fn000D2742(Stack Eq_n arg0)
// Called from:
//      fn000D2693
//      fn000DEB18
Eq_n fn000D2742(Eq_n arg0)
{
	int32 v30_n = (int32) arg0.u14[74];
	arg0.u14[74] = (struct Eq_n) ((byte) v30_n + ~0x00 | (byte) v30_n);
	arg0.u17[4] = (struct Eq_n) 0x00;
	arg0.u18->dw001C = (ui32) 0x00;
	arg0.u15[0x0A] = (struct Eq_n) 0x00;
	Eq_n v30_n;
	v30_n.u2 = *arg0.u3;
	if ((v30_n & 0x14) == 0x00)
	{
		Eq_n v30_n;
		v30_n.u2 = arg0.u15[22];
		arg0.u15[4] = (struct Eq_n) v30_n;
		arg0.u15[2] = (struct Eq_n) v30_n;
	}
	else if ((v30_n & 0x04) != 0x00)
		*arg0.u3 = (int32) (v30_n | 0x20);
	return <invalid>;
}

// 000D285D: Stack word64 fn000D285D(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3)
// Called from:
//      fn000F07BB
//      fn000F1165
word64 fn000D285D(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3)
{
	return <invalid>;
}

// 000D2872: Stack word64 fn000D2872(Stack word32 arg0, Stack word32 arg1, Stack word32 arg2)
// Called from:
//      fn000D285D
word64 fn000D2872(word32 arg0, word32 arg1, word32 arg2)
{
	return <invalid>;
}

// 000D2892: Stack Eq_n fn000D2892(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000DAAEE
Eq_n fn000D2892(Eq_n arg0, Eq_n arg1)
{
	return <invalid>;
}

// 000D28D3: Stack Eq_n fn000D28D3(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000DB328
Eq_n fn000D28D3(Eq_n arg0, Eq_n arg1)
{
	Eq_n v25_n;
	v25_n.u0 = *arg0.u2;
	if (!((int32) v25_n == 0x00 | (int32) v25_n != (int32) (*arg1.u2)))
	{
		Eq_n loc2_n = arg1;
		Eq_n loc3_n = arg0;
		while (true)
		{
			Eq_n v24_n;
			v24_n.u14 = loc3_n.u14 + 1;
			Eq_n v24_n;
			v24_n.u14 = loc2_n.u14 + 1;
			Eq_n v30_n;
			v30_n.u0 = *v24_n.u2;
			if ((int32) v30_n == 0x00 | (int32) v30_n != (int32) (*v24_n.u2))
				break;
			loc2_n = v24_n;
			loc3_n = v24_n;
		}
	}
	return <invalid>;
}

// 000D29A3: Stack Eq_n fn000D29A3(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3)
// Called from:
//      fn000DB3DF
//      fn000DEA30
//      fn000FA95B
Eq_n fn000D29A3(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3)
{
	Eq_n v31_n;
	v31_n.u2 = g_t140030.u2;
	g_t140030.u2 += 0x0080;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x80);
	*v31_n.u4 = g_qw0C74;
	v31_n.u15[4] = (struct Eq_n) g_t0C7C.u15;
	v31_n.u17[4] = (struct Eq_n) g_t0C84.u15;
	v31_n.u15[0x0C] = (struct Eq_n) g_t0C8C.u15;
	v31_n.u15[16] = (struct Eq_n) g_t0C94.u15;
	v31_n.u15[20] = (struct Eq_n) g_t0C9C.u15;
	v31_n.u15[24] = (struct Eq_n) g_t0CA4.u15;
	v31_n.u15[28] = (struct Eq_n) g_t0CAC.u15;
	v31_n.u15[32] = (struct Eq_n) g_t0CB4.u15;
	((word32) v31_n + 72)->u15 = g_t0CBC.u15;
	((word32) v31_n + 80)->u15 = g_t0CC4.u15;
	((word32) v31_n + 88)->u15 = g_t0CCC.u15;
	((word32) v31_n + 96)->u15 = g_t0CD4.u15;
	v31_n.u15[52] = (struct Eq_n) g_t0CDC.u15;
	Eq_n loc6;
	Eq_n loc7;
	word32 loc30;
	if (arg1 > 0x7FFFFFFF)
	{
		if (arg1 == 0x00)
		{
			loc6.u2 = (word32) v31_n + 112;
			loc7.u0 = 0x01;
			loc30 = 0x04;
		}
		else
			*___errno_location().u3 = 0x4B;
	}
	else
	{
		loc6 = arg0;
		loc7 = arg1;
		loc30 = 0x04;
	}
	if (loc30 == 0x04)
	{
		Eq_n v31_n = ~0x01 - loc6;
		Eq_n v31_n;
		if (loc7 > v31_n)
			v31_n = v31_n;
		else
			v31_n = loc7;
		v31_n.u15[24] = (struct Eq_n) v31_n;
		v31_n.u15[0x0A] = (struct Eq_n) loc6;
		v31_n.u15[22] = (struct Eq_n) loc6;
		Eq_n v31_n;
		v31_n.u2 = loc6 + v31_n;
		v31_n.u17[4] = (struct Eq_n) v31_n;
		v31_n.u18->dw001C = (ui32) v31_n;
		fn000D2BD4(v31_n, arg2, arg3);
		if (v31_n != 0x00)
			v31_n.u15[0x0A].a0000[0].u2.u2 = (int8 *) 0x00;
	}
	g_t140030.u2 = (int8 *) v31_n;
	return <invalid>;
}

// 000D2BD4: Stack Eq_n fn000D2BD4(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000D29A3
//      fn0011D654
Eq_n fn000D2BD4(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v48_n;
	v48_n.u2 = g_t140030.u2;
	g_t140030.u2 += 224;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0xE0);
	((word32) v48_n + 80)->u0 = 0x00;
	((word32) v48_n + 88)->u0 = 0x00;
	((word32) v48_n + 96)->u0 = 0x00;
	v48_n.u15[52] = (struct Eq_n) 0x00;
	((word32) v48_n + 112)->u0 = 0x00;
	((word32) v48_n + 0x0078)->u2 = *arg2.u3;
	if (fn000D2E2C(0x00, arg1, (word32) v48_n + 0x0078, v48_n, v48_n.u14 + 80) >= 0x00)
	{
		Eq_n loc39_n;
		if (arg0.u15[38] > ~0x00)
			loc39_n = fn000D61F1(arg0);
		else
			loc39_n.u0 = 0x00;
		Eq_n v48_n;
		v48_n.u2 = *arg0.u3;
		if ((int32) arg0.u14[74] < 0x01)
			*arg0.u3 = (int32) (v48_n & ~0x20);
		if (arg0.u15[24] == 0x00)
		{
			Eq_n v48_n;
			v48_n.u2 = arg0.u15[22];
			arg0.u15[22] = (struct Eq_n) ((word32) v48_n + 0x0088);
			arg0.u18->dw001C = (word32) v48_n + 0x0088;
			arg0.u15[0x0A] = (struct Eq_n) ((word32) v48_n + 0x0088);
			arg0.u15[24] = (struct Eq_n) 0x50;
			arg0.u17[4] = (struct Eq_n) ((word32) v48_n + 0x00D8);
			fn000D2E2C(arg0, arg1, (word32) v48_n + 0x0078, v48_n, v48_n.u14 + 80);
			if (v48_n != 0x00)
			{
				arg0.u15[22] = (struct Eq_n) v48_n;
				arg0.u15[24] = (struct Eq_n) 0x00;
				arg0.u17[4] = (struct Eq_n) 0x00;
				arg0.u18->dw001C = (ui32) 0x00;
				arg0.u15[0x0A] = (struct Eq_n) 0x00;
			}
		}
		else
			fn000D2E2C(arg0, arg1, (word32) v48_n + 0x0078, v48_n, v48_n.u14 + 80);
		Eq_n v48_n;
		v48_n.u2 = *arg0.u3;
		*arg0.u3 = (int32) (v48_n | v48_n & 0x20);
		if (loc39_n == 0x00 == 0x00)
			fn000D1351(arg0);
	}
	g_t140030.u2 = (int8 *) v48_n;
	return <invalid>;
}

// 000D2E1D: Stack word64 fn000D2E1D(Stack Eq_n arg0, Stack uint64 arg1)
// Called from:
//      fn000D2E2C
//      fn000D68BF
//      fn000D7B90
word64 fn000D2E1D(Eq_n arg0, uint64 arg1)
{
	return <invalid>;
}

// 000D2E2C: Stack Eq_n fn000D2E2C(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3, Stack Eq_n arg4)
// Called from:
//      fn000D2BD4
Eq_n fn000D2E2C(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3, Eq_n arg4)
{
	Eq_n v967_n;
	v967_n.u2 = g_t140030.u2;
	g_t140030.u2 += 624;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x0270);
	Eq_n v967_n = 0x00 - (v967_n + 588);
	word32 v967_n = v967_n + 588 - (v967_n + &g_t024C);
	Eq_n v967_n = ~0x01 - (v967_n + &g_t024C);
	Eq_n loc29_n;
	loc29_n.u0 = 0x00;
	int32 loc30_n = 0x00;
	word32 loc40_n = 0x00;
	Eq_n loc42_n = arg1;
l000D2F31:
	bool v969_n = loc30_n > ~0x00;
	int32 loc79_n;
	if (v969_n)
	{
		if (loc29_n > 0x7FFFFFFF - loc30_n)
		{
			*___errno_location().u3 = 0x4B;
			loc79_n = ~0x00;
		}
		else
			loc79_n = loc29_n.u2 + loc30_n;
	}
	else
	{
		loc79_n = loc30_n;
		Mem154 = Mem153;
	}
	int8 v970_n = *loc42_n.u2;
	word32 v967_n = (word32) v970_n;
	word32 loc898;
	if ((int32) v970_n == 0x00)
	{
		loc898 = 0xF3;
		goto l000D60EB;
	}
	Eq_n loc86_n = loc42_n;
	word32 loc453_n = v967_n;
l000D2FBA:
	Eq_n loc32;
	Eq_n loc117;
	Eq_n loc31;
	Eq_n loc116;
	switch ((int32) (byte) loc453_n)
	{
	case 0:
		loc32 = loc86_n;
		loc117 = loc86_n;
		loc898 = 0x09;
		break;
	case 1:
		loc31 = loc86_n;
		loc116 = loc86_n;
		break;
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 0x0A:
	case 11:
	case 0x0C:
	case 0x0D:
	case 0x0E:
	case 0x0F:
	case 16:
	case 0x0011:
	case 18:
	case 19:
	case 20:
	case 21:
	case 22:
	case 23:
	case 24:
	case 25:
	case 26:
	case 27:
	case 28:
	case 29:
	case 30:
	case 31:
	case 32:
	case 33:
	case 0x0022:
	case 35:
	case 36:
	case 37:
		Mem185 = Mem152;
		Eq_n v967_n;
		v967_n.u14 = loc86_n.u14 + 1;
		loc86_n = v967_n;
		loc453_n = (word32) *v967_n.u2;
		goto l000D2FBA;
	}
	Mem315 = Mem152;
	if (loc898 == 0x09)
	{
		while (true)
		{
			loc898 = 0x00;
			if ((int32) loc117.u14[1] == 0x25 == 0x00)
				break;
			Eq_n v967_n;
			v967_n.u14 = loc117.u14 + 2;
			Eq_n v967_n;
			v967_n.u14 = loc32.u14 + 1;
			if ((int32) *v967_n.u2 != 0x25)
			{
				loc31 = v967_n;
				loc116 = v967_n;
				goto l000D30D4;
			}
			loc32 = v967_n;
			loc117 = v967_n;
		}
		loc31 = loc32;
		loc116 = loc117;
	}
	else
	{
l000D30D4:
	}
	Eq_n v967_n = loc31 - loc42_n;
	if (arg0 != 0x00)
	{
		if ((*arg0.u3 & 0x20) == 0x00)
			fn000D61FC(loc42_n, v967_n, arg0);
	}
	if (v967_n == 0x00 == 0x00)
	{
		loc29_n = v967_n;
		loc30_n = loc79_n;
		loc42_n = loc116;
		goto l000D2F31;
	}
	Eq_n v967_n;
	v967_n.u14 = loc116.u14 + 1;
	int8 v975_n = *v967_n.u2;
	word32 v967_n = (word32) v975_n;
	Eq_n v967_n;
	v967_n.u0 = (int32) v975_n;
	Eq_n loc34_n;
	word32 loc85_n;
	word32 loc703_n;
	Eq_n loc892_n;
	if (v967_n < 0x3A)
	{
		int32 v967_n = (int32) loc116.u14[2];
		Eq_n v967_n;
		v967_n.u14 = loc116.u14 + 3;
		Eq_n v967_n;
		if (v967_n == 0x24)
			v967_n = v967_n;
		else
			v967_n = v967_n;
		word32 v967_n;
		if (v967_n == 0x24)
			v967_n = 0x01;
		else
			v967_n = loc40_n;
		Eq_n v967_n;
		if (v967_n == 0x24)
			v967_n = (word32) v967_n - 48;
		else
			v967_n.u0 = ~0x00;
		loc34_n = v967_n;
		loc85_n = v967_n;
		loc703_n = (word32) *v967_n.u2;
		loc892_n = v967_n;
	}
	else
	{
		loc34_n.u0 = ~0x00;
		loc85_n = loc40_n;
		loc703_n = v967_n;
		loc892_n = v967_n;
	}
	Eq_n v967_n = (int32) (byte) loc703_n + ~0x1F;
	Eq_n loc38_n;
	word32 loc819_n;
	Eq_n loc893_n;
	if (v967_n < 0x20)
	{
		Eq_n loc39_n;
		loc39_n.u0 = 0x00;
		Eq_n loc745_n = v967_n;
		word32 loc789_n = loc703_n;
		Eq_n loc894_n = loc892_n;
		while ((0x01 << loc745_n & 0x00012889) != 0x00)
		{
			Eq_n v967_n;
			v967_n.u14 = loc894_n.u14 + 1;
			int8 v978_n = *v967_n.u2;
			Eq_n v967_n = 0x01 << (int32) ((byte) loc789_n) + ~0x1F | loc39_n;
			word32 v967_n = (word32) v978_n;
			Eq_n v967_n;
			v967_n.u0 = (int32) v978_n;
			if (v967_n >= 0x40)
			{
				loc38_n = v967_n;
				loc819_n = v967_n;
				loc893_n = v967_n;
				goto l000D330E;
			}
			loc39_n = v967_n;
			loc745_n = (word32) v967_n - 32;
			loc789_n = v967_n;
			loc894_n = v967_n;
		}
		loc38_n = loc39_n;
		loc819_n = loc789_n;
		loc893_n = loc894_n;
	}
	else
	{
		loc38_n.u0 = 0x00;
		loc819_n = loc703_n;
		loc893_n = loc892_n;
l000D330E:
	}
	bool v969_n = (int32) (byte) loc819_n == 0x2A;
	Eq_n loc82_n;
	Eq_n loc83_n;
	word32 loc131_n;
	Eq_n loc144_n;
	word32 loc179_n;
	if (v969_n)
	{
		Eq_n v967_n;
		v967_n.u14 = loc893_n.u14 + 1;
		int8 v979_n = *v967_n.u2;
		word32 v967_n = (word32) v979_n;
		Eq_n v967_n;
		v967_n.u0 = (int32) v979_n;
		Eq_n loc37;
		word32 loc115;
		Eq_n loc895;
		if (v967_n < 0x3A)
		{
			if ((int32) loc893_n.u14[2] == 0x24)
			{
				arg4.u3[(word32) v967_n - 48] = (int32) 0x0A;
				loc37.u2 = arg3.u4[(int32) *v967_n.u2 + ~0x2F];
				loc115 = 0x01;
				loc895.u14 = loc893_n.u14 + 3;
			}
			else
				loc898 = 0x18;
		}
		else
			loc898 = 0x18;
		if (loc898 == 0x18)
		{
			loc898 = 0x00;
			if (loc85_n == 0x00 == 0x00)
				goto l000D60EB;
			if (arg0 != 0x00 == 0x00)
			{
				loc82_n.u0 = 0x00;
				loc83_n = loc38_n;
				loc131_n = 0x00;
				loc144_n = v967_n;
				loc179_n = v967_n;
				goto l000D35FE;
			}
			union Eq_n * v967_n = *arg2.u3 + 0x03 & ~0x03;
			Eq_n v967_n;
			v967_n.u2 = v967_n->u2;
			*arg2.u3 = (char *) v967_n + 4;
			loc37 = v967_n;
			loc115 = 0x00;
			loc895 = v967_n;
		}
		bool v969_n = loc37 < 0x00;
		Eq_n v967_n = loc38_n | 0x2000;
		Eq_n v967_n = 0x00 - loc37;
		Eq_n v967_n;
		if (v969_n)
			v967_n = v967_n;
		else
			v967_n = loc38_n;
		Eq_n v967_n;
		if (v969_n)
			v967_n = v967_n;
		else
			v967_n = loc37;
		loc82_n = v967_n;
		loc83_n = v967_n;
		loc131_n = loc115;
		loc144_n = loc895;
		loc179_n = (word32) *loc895.u2;
	}
	else
	{
		Eq_n v967_n = (int32) (byte) loc819_n + ~0x2F;
		if (v967_n < 0x0A)
		{
			Eq_n loc69_n;
			loc69_n.u0 = 0x00;
			Eq_n loc199_n = loc893_n;
			Eq_n loc875_n = v967_n;
			Eq_n v967_n;
			Eq_n v967_n;
			word32 v967_n;
			while (true)
			{
				v967_n.u14 = loc199_n.u14 + 1;
				int8 v984_n = *v967_n.u2;
				v967_n.u2 = (word32) loc875_n + loc69_n * 0x0A;
				v967_n = (word32) v984_n;
				Eq_n v967_n;
				v967_n.u0 = (int32) v984_n;
				if (v967_n >= 0x3A)
					break;
				loc69_n = v967_n;
				loc199_n = v967_n;
				loc875_n = (word32) v967_n - 48;
			}
			if (v967_n < 0x00)
				goto l000D60EB;
			loc82_n = v967_n;
			loc144_n = v967_n;
			loc179_n = v967_n;
		}
		else
		{
			loc82_n.u0 = 0x00;
			loc144_n = loc893_n;
			loc179_n = loc819_n;
		}
		loc83_n = loc38_n;
		loc131_n = loc85_n;
	}
l000D35FE:
	bool v969_n = (int32) (byte) loc179_n == 0x2E;
	Eq_n loc35_n;
	Eq_n loc164_n;
	if (v969_n)
	{
		Eq_n v967_n;
		v967_n.u14 = loc144_n.u14 + 1;
		int8 v985_n = *v967_n.u2;
		if ((int32) v985_n == 0x2A == 0x00)
		{
			Eq_n v967_n;
			v967_n.u0 = (int32) v985_n;
			if (v967_n < 0x3A)
			{
				Eq_n loc70_n;
				loc70_n.u0 = 0x00;
				Eq_n loc233_n = v967_n;
				Eq_n loc876_n = (word32) v967_n - 48;
				Eq_n v967_n;
				Eq_n v967_n;
				while (true)
				{
					v967_n.u14 = loc233_n.u14 + 1;
					v967_n.u2 = (word32) loc876_n + loc70_n * 0x0A;
					Eq_n v967_n;
					v967_n.u0 = (int32) *v967_n.u2;
					if (v967_n >= 0x3A)
						break;
					loc70_n = v967_n;
					loc233_n = v967_n;
					loc876_n = (word32) v967_n - 48;
				}
				loc35_n = v967_n;
				loc164_n = v967_n;
			}
			else
			{
				loc35_n.u0 = 0x00;
				loc164_n = v967_n;
			}
l000D3862:
			ui32 loc33_n = 0x00;
			Eq_n loc168_n = loc164_n;
			int8 v991_n;
			ui32 v967_n;
			Eq_n v967_n;
			while (true)
			{
				Eq_n v967_n;
				v967_n.u0 = (int32) *loc168_n.u2;
				if (v967_n > 122)
					goto l000D60EB;
				v991_n = (int8) *((word32) (loc33_n * 0x3A + 11107) + ((word32) v967_n - 65));
				v967_n = (word32) v991_n;
				v967_n.u14 = loc168_n.u14 + 1;
				if ((v967_n & 0xFF) >= 0x09)
					break;
				loc33_n = v967_n & 0xFF;
				loc168_n = v967_n;
			}
			if ((int32) v991_n == 0x00)
			{
l000D60EB:
				if (loc898 == 0xF3)
				{
					if (arg0 == 0x00)
					{
						if (loc40_n != 0x00)
						{
							int32 loc109_n = 0x01;
							while (true)
							{
								Eq_n v967_n;
								v967_n.u2 = arg4.u3[loc109_n];
								if (v967_n == 0x00)
									break;
								fn000D63BF(arg3.u2 + (loc109_n << 0x03), v967_n, arg2);
								int32 v967_n = loc109_n + 0x01;
								if (v967_n >= 0x0A)
									goto l000D61E6;
								loc109_n = v967_n;
							}
							int32 loc135_n = loc109_n;
							while (true)
							{
								int32 v967_n = loc135_n + 0x01;
								if (arg4.u3[loc135_n] == 0x00 == 0x00)
									break;
								if (v967_n >= 0x0A)
									goto l000D61DE;
								loc135_n = v967_n;
							}
l000D61E6:
							g_t140030.u2 = (int8 *) v967_n;
							return <invalid>;
						}
l000D61DE:
					}
				}
				goto l000D61E6;
			}
			int32 v967_n = (int32) v991_n;
			bool v969_n = loc34_n > ~0x00;
			if (v967_n == 0x13)
			{
				if (v969_n)
					goto l000D60EB;
				loc898 = 0x33;
			}
			else
			{
				if (v969_n)
				{
					arg4.u3[loc34_n] = (int32) (v967_n & 0xFF);
					*v967_n.u4 = arg3.u4[loc34_n];
					loc898 = 0x33;
					goto l000D399F;
				}
				if (arg0 != 0x00 == 0x00)
					goto l000D60EB;
				fn000D63BF(v967_n, v967_n & 0xFF, arg2);
			}
l000D399F:
			if (loc898 == 0x33)
			{
				loc898 = 0x00;
				if (arg0 != 0x00 == 0x00)
				{
					loc29_n.u0 = 0x00;
					loc30_n = loc79_n;
					loc40_n = loc131_n;
					loc42_n = v967_n;
					goto l000D2F31;
				}
			}
			int32 v967_n = (int32) *loc168_n.u2;
			int32 v967_n;
			if (loc33_n != 0x00 & (v967_n & 0x0F) == 0x03)
				v967_n = v967_n & ~0x20;
			else
				v967_n = v967_n;
			Eq_n v967_n = loc83_n & ~0x00010000;
			Eq_n v967_n;
			if ((loc83_n & 0x2000) == 0x00)
				v967_n = loc83_n;
			else
				v967_n = v967_n;
			switch (v967_n)
			{
			case 0x41:
				ui32 v967_n = loc33_n & 0xFF;
				switch ((int32) (byte) v967_n)
				{
				case 0:
					**v967_n.u3 = loc79_n;
					loc29_n.u0 = 0x00;
					loc30_n = loc79_n;
					loc40_n = loc131_n;
					loc42_n = v967_n;
					break;
				case 1:
					**v967_n.u3 = loc79_n;
					loc29_n.u0 = 0x00;
					loc30_n = loc79_n;
					loc40_n = loc131_n;
					loc42_n = v967_n;
					break;
				case 2:
					**v967_n.u3 = (int32) (int64) loc79_n;
					loc29_n.u0 = 0x00;
					loc30_n = loc79_n;
					loc40_n = loc131_n;
					loc42_n = v967_n;
					break;
				case 3:
					**v967_n.u3 = (int32) (word16) loc79_n;
					loc29_n.u0 = 0x00;
					loc30_n = loc79_n;
					loc40_n = loc131_n;
					loc42_n = v967_n;
					break;
				case 4:
					**v967_n.u3 = (int32) (byte) loc79_n;
					loc29_n.u0 = 0x00;
					loc30_n = loc79_n;
					loc40_n = loc131_n;
					loc42_n = v967_n;
					break;
				case 5:
					**v967_n.u3 = loc79_n;
					loc29_n.u0 = 0x00;
					loc30_n = loc79_n;
					loc40_n = loc131_n;
					loc42_n = v967_n;
					break;
				case 6:
					**v967_n.u3 = (int32) (int64) loc79_n;
					loc29_n.u0 = 0x00;
					loc30_n = loc79_n;
					loc40_n = loc131_n;
					loc42_n = v967_n;
					break;
				case 7:
					Mem9160 = Mem1481;
					loc29_n.u0 = 0x00;
					loc30_n = loc79_n;
					loc40_n = loc131_n;
					loc42_n = v967_n;
					break;
				}
				goto l000D2F31;
			case 66:
				Mem6997 = Mem1481;
				Eq_n v967_n;
				if (loc35_n > 0x08)
					v967_n = loc35_n;
				else
					v967_n.u0 = 0x08;
				int32 loc75 = 0x78;
				Eq_n loc81 = v967_n;
				Eq_n loc130 = v967_n | 0x08;
				loc898 = 0x3F;
				goto l000D5AF9;
			case 0x43:
l000D3C92:
				Mem6998 = Mem1481;
				loc75 = v967_n;
				loc81 = loc35_n;
				loc130 = v967_n;
				loc898 = 0x3F;
				goto l000D5AF9;
			case 0x44:
				goto l000D3C92;
			case 0x45:
				Mem6278 = Mem1481;
				Eq_n v982_n;
				v982_n.u2 = *v967_n.u4;
				Eq_n loc19_n;
				if (v982_n == 0x00)
					loc19_n.u2 = v967_n + 0x0240;
				else
				{
					Eq_n loc900_n = v982_n;
					Eq_n loc71_n;
					loc71_n.u2 = v967_n + &g_t0240;
					Eq_n v967_n;
					while (true)
					{
						v967_n.u2 = &loc71_n.u15->bFFFFFFFF;
						*v967_n.u2 = (int8) ((byte) loc900_n & 0x07 | 0x30);
						Eq_n v982_n = loc900_n >> 0x03;
						if (v982_n == 0x00)
							break;
						loc900_n = v982_n;
						loc71_n = v967_n;
					}
					loc19_n = v967_n;
				}
				Eq_n loc112;
				if ((v967_n & 0x08) == 0x00)
					loc112 = loc35_n;
				else
				{
					Eq_n v967_n = v967_n + &g_t0240 - loc19_n;
					Eq_n v967_n;
					if (loc35_n > v967_n)
						v967_n = loc35_n;
					else
						v967_n.u14 = v967_n.u14 + 1;
					loc112 = v967_n;
				}
				Eq_n loc21 = loc19_n;
				Eq_n loc76;
				loc76.u0 = 11587;
				Eq_n loc74;
				loc74.u0 = 0x00;
				Eq_n loc143 = v967_n;
				loc898 = 0x4C;
				goto l000D5AF9;
			case 0x46:
l000D3DBD:
				Mem6210 = Mem1481;
				Eq_n v982_n;
				v982_n.u2 = *v967_n.u4;
				Eq_n loc23;
				Eq_n loc25;
				Eq_n loc917;
				if (v982_n < 0x00)
				{
					Eq_n v982_n = 0x00 - v982_n;
					*v967_n.u4 = (real64) v982_n;
					loc23.u0 = 0x01;
					loc25.u0 = 11587;
					loc917 = v982_n;
					loc898 = 0x4B;
					goto l000D5AFA;
				}
				if ((v967_n & 0x0800) == 0x00)
				{
					Eq_n v967_n = v967_n & 0x01;
					Eq_n v967_n;
					if (v967_n == 0x00)
						v967_n.u0 = 11587;
					else
						v967_n.u0 = 11589;
					loc23 = v967_n;
					loc25 = v967_n;
				}
				else
				{
					loc23.u0 = 0x01;
					loc25.u0 = 11588;
				}
				loc917 = v982_n;
				loc898 = 0x4B;
l000D5AFA:
				Eq_n loc72;
				Eq_n loc105;
				Eq_n loc107;
				Eq_n loc108;
				Eq_n loc111;
				Eq_n loc150;
				Eq_n loc166;
				Eq_n loc810;
				Eq_n loc142;
				Eq_n loc27;
				if (loc898 == 0x3F)
				{
					Eq_n v982_n = *v967_n.u4;
					ui32 v967_n = loc75 & 0x20;
					Eq_n loc55_n;
					word64 loc910_n;
					if (v982_n == 0x00)
					{
						loc55_n.u2 = v967_n + &g_t0240;
						loc910_n = 0x00;
					}
					else
					{
						Eq_n loc68_n;
						loc68_n.u2 = v967_n + &g_t0240;
						Eq_n loc901_n = v982_n;
						Eq_n v967_n;
						while (true)
						{
							v967_n.u2 = loc68_n + ~0x00;
							*v967_n.u2 = (loc901_n & 0x0F)->b2D33 | (byte) v967_n;
							Eq_n v982_n = loc901_n >> 0x04;
							if (v982_n == 0x00)
								break;
							loc68_n = v967_n;
							loc901_n = v982_n;
						}
						loc55_n = v967_n;
						loc910_n = *v967_n.u4;
					}
					ui32 v967_n = (loc130 & 0x08) == 0x00 | loc910_n == 0x00;
					int32 v967_n = loc75 >> 0x04;
					Eq_n v967_n;
					if (v967_n)
						v967_n.u0 = 11587;
					else
						v967_n = v967_n + 11587;
					Eq_n v967_n;
					if (v967_n)
						v967_n.u0 = 0x00;
					else
						v967_n.u0 = 0x02;
					loc21 = loc55_n;
					loc74 = v967_n;
					loc76 = v967_n;
					loc112 = loc81;
					loc143 = loc130;
					loc898 = 0x4C;
				}
				else if (loc898 == 0x4B)
				{
					loc21 = fn000D68BF(loc917, v967_n + &g_t0240);
					loc74 = loc23;
					loc76 = loc25;
					loc112 = loc35_n;
					loc143 = v967_n;
					loc898 = 0x4C;
				}
				else if (loc898 == 0x51)
				{
					Eq_n v967_n = fn000D6AC0(loc72, 0x00, loc35_n);
					loc898 = 0x00;
					Eq_n v967_n = v967_n - loc72;
					Eq_n v967_n;
					v967_n.u2 = loc72 + loc35_n;
					Eq_n v967_n;
					if (v967_n == 0x00)
						v967_n = loc35_n;
					else
						v967_n = v967_n;
					Eq_n v967_n;
					if (v967_n == 0x00)
						v967_n = v967_n;
					else
						v967_n = v967_n;
					loc105 = loc72;
					loc107.u0 = 0x00;
					loc108.u0 = 11587;
					loc111 = v967_n;
					loc150 = v967_n;
					loc166 = v967_n;
				}
				else if (loc898 == 0x55)
				{
					loc898 = 0x00;
					Eq_n loc22_n = loc810;
					Eq_n loc28_n;
					loc28_n.u0 = 0x00;
					Eq_n loc78_n;
					loc78_n.u0 = 0x00;
					Eq_n loc26_n;
					Eq_n loc110_n;
					while (true)
					{
						Eq_n v967_n;
						v967_n.u2 = *loc22_n.u3;
						if (v967_n == 0x00)
							break;
						Eq_n v967_n = fn000D6E73(v967_n + 0x0210, v967_n);
						if (v967_n < 0x00 | v967_n > loc142 - loc28_n)
						{
							loc26_n = loc28_n;
							loc110_n = v967_n;
							goto l000D5DBF;
						}
						Eq_n v967_n;
						v967_n.u2 = v967_n + loc28_n;
						Eq_n v967_n;
						v967_n.u2 = loc22_n + 0x04;
						if (loc142 <= v967_n)
						{
							loc26_n = v967_n;
							loc110_n = v967_n;
							goto l000D5DBF;
						}
						loc22_n = v967_n;
						loc28_n = v967_n;
						loc78_n = v967_n;
					}
					loc26_n = loc28_n;
					loc110_n = loc78_n;
l000D5DBF:
					if (loc110_n < 0x00)
						goto l000D60EB;
					fn000D6D47(arg0, 0x20, loc82_n, loc26_n, v967_n);
					if (loc26_n != 0x00)
					{
						Eq_n loc73_n = loc810;
						Eq_n loc77_n;
						loc77_n.u0 = 0x00;
						while (true)
						{
							Eq_n v967_n;
							v967_n.u2 = *loc73_n.u3;
							if (v967_n == 0x00)
								break;
							Eq_n v967_n = fn000D6E73(v967_n + &g_t0210, v967_n);
							Eq_n v967_n;
							v967_n.u2 = v967_n + loc77_n;
							Eq_n v967_n;
							v967_n.u2 = loc73_n + 0x04;
							if (v967_n > loc26_n)
							{
								loc27 = loc26_n;
								loc898 = 0x60;
								goto l000D5EBD;
							}
							if ((*arg0.u3 & 0x20) == 0x00)
								fn000D61FC(v967_n + &g_t0210, v967_n, arg0);
							if (v967_n >= loc26_n)
							{
								loc27 = loc26_n;
								goto l000D5EB8;
							}
							loc73_n = v967_n;
							loc77_n = v967_n;
						}
						loc27 = loc26_n;
						loc898 = 0x60;
l000D5EBD:
						if (loc898 == 0x60)
						{
							fn000D6D47(arg0, 0x20, loc82_n, loc27, v967_n ^ 0x2000);
							loc898 = 0x00;
							Eq_n v967_n;
							if (loc82_n > loc27)
								v967_n = loc82_n;
							else
								v967_n = loc27;
							loc29_n = v967_n;
							loc30_n = loc79_n;
							loc40_n = loc131_n;
							loc42_n = v967_n;
						}
						else
						{
							if (loc898 == 0x4C)
							{
								loc898 = 0x00;
								Eq_n v967_n = loc143 & ~0x00010000;
								Eq_n v967_n;
								if (loc112 > ~0x00)
									v967_n = v967_n;
								else
									v967_n = loc143;
								word64 v982_n = *v967_n.u4;
								if (loc112 != 0x00 | v982_n != 0x00)
								{
									Eq_n v967_n;
									v967_n.u2 = (char *) &(v967_n + &g_t0240 - loc21).u0->t0000.u0 + (v982_n != 0x00 & 0x01 ^ 0x01);
									Eq_n v967_n;
									if (loc112 > v967_n)
										v967_n = loc112;
									else
										v967_n = v967_n;
									loc105 = loc21;
									loc150 = v967_n;
								}
								else
								{
									loc105.u2 = v967_n + &g_t0240;
									loc150.u0 = 0x00;
								}
								loc108 = loc76;
								loc166 = v967_n;
								loc107 = loc74;
								loc111.u2 = v967_n + &g_t0240;
							}
							Eq_n v967_n = loc111 - loc105;
							Eq_n v967_n;
							if (loc150 < v967_n)
								v967_n = v967_n;
							else
								v967_n = loc150;
							Eq_n v967_n;
							v967_n.u2 = v967_n + loc107;
							Eq_n v967_n;
							if (loc82_n < v967_n)
								v967_n = v967_n;
							else
								v967_n = loc82_n;
							fn000D6D47(arg0, 0x20, v967_n, v967_n, loc166);
							if ((*arg0.u3 & 0x20) == 0x00)
								fn000D61FC(loc108, loc107, arg0);
							fn000D6D47(arg0, 0x30, v967_n, v967_n, loc166 ^ 0x00010000);
							fn000D6D47(arg0, 0x30, v967_n, v967_n, 0x00);
							if ((*arg0.u3 & 0x20) == 0x00)
								fn000D61FC(loc105, v967_n, arg0);
							fn000D6D47(arg0, 0x20, v967_n, v967_n, loc166 ^ 0x2000);
							loc29_n = v967_n;
							loc30_n = loc79_n;
							loc40_n = loc131_n;
							loc42_n = v967_n;
						}
						goto l000D2F31;
					}
					loc27.u0 = 0x00;
l000D5EB8:
					loc898 = 0x60;
				}
				goto l000D5EBD;
			case 0x47:
				goto l000D3DBD;
			case 0x48:
				Mem6196 = Mem1481;
				loc23.u0 = 0x00;
				loc25.u0 = 11587;
				loc917.u2 = *v967_n.u4;
				loc898 = 0x4B;
				goto l000D5AF9;
			case 0x49:
				*(v967_n + 575) = (word32) *v967_n.u2;
				loc105.u2 = v967_n + &g_t023F;
				loc107.u0 = 0x00;
				loc108.u0 = 11587;
				loc111.u2 = v967_n + &g_t0240;
				loc150.u0 = 0x01;
				loc166 = v967_n;
				goto l000D5AF9;
			case 0x4A:
				Mem6155 = Mem1481;
				loc72 = fn000D69BF(*___errno_location().u3);
				loc898 = 0x51;
				goto l000D5AF9;
			case 0x4B:
				Mem6136 = Mem1481;
				Eq_n v967_n;
				v967_n.u2 = *v967_n.u3;
				Eq_n v967_n;
				if (v967_n != 0x00)
					v967_n = v967_n;
				else
					v967_n.u0 = 0x2D4D;
				loc72 = v967_n;
				loc898 = 0x51;
				goto l000D5AF9;
			case 0x4C:
				*(v967_n + 0x08) = (word32) *v967_n.u4;
				v967_n.u17[3] = (struct Eq_n) 0x00;
				*v967_n.u3 = v967_n + &g_t0008;
				loc142.u0 = ~0x00;
				loc810.u2 = v967_n + &g_t0008;
				loc898 = 0x55;
				goto l000D5AF9;
			case 77:
				Mem6082 = Mem1481;
				Eq_n v967_n;
				v967_n.u2 = *v967_n.u3;
				if (loc35_n == 0x00)
				{
					fn000D6D47(arg0, 0x20, loc82_n, 0x00, v967_n);
					loc27.u0 = 0x00;
					loc898 = 0x60;
				}
				else
				{
					loc142 = loc35_n;
					loc810 = v967_n;
					loc898 = 0x55;
				}
				goto l000D5AF9;
			case 0x4E:
				break;
			case 0x4F:
				break;
			case 0x50:
				goto l000D3FB9;
			case 0x51:
				goto l000D3FBB;
			case 0x52:
				goto l000D3FBD;
			case 0x53:
				goto l000D3FBF;
			case 0x54:
				goto l000D3FC1;
			case 0x55:
				goto l000D3FC3;
			case 0x56:
			case 0x57:
			case 88:
			case 0x59:
			case 0x5A:
			case 0x5B:
			case 0x5C:
			case 0x5D:
			case 0x5E:
			case 0x5F:
			case 0x60:
			case 0x61:
			case 0x62:
			case 99:
			case 100:
			case 101:
			case 0x66:
			case 0x67:
			case 0x68:
			case 0x69:
			case 0x6A:
			case 0x6B:
			case 0x6C:
			case 0x6D:
			case 110:
			case 111:
			case 0x70:
			case 113:
			case 114:
			case 115:
			case 116:
			case 117:
			case 118:
			case 0x77:
			case 0x78:
				Mem7007 = Mem1481;
				loc105 = loc42_n;
				loc107.u0 = 0x00;
				loc108.u0 = 11587;
				loc111.u2 = v967_n + &g_t0240;
				loc150 = loc35_n;
				loc166 = v967_n;
				goto l000D5AF9;
			}
l000D3FB9:
l000D3FBB:
l000D3FBD:
l000D3FBF:
l000D3FC1:
l000D3FC3:
			Eq_n v1001_n;
			v1001_n.u2 = *v967_n.u4;
			*(v967_n + 0x10) = (word32) 0x00;
			Eq_n loc938_n;
			Eq_n loc59_n;
			Eq_n loc61_n;
			if (reinterpret_cast<uint64>(v1001_n) < 0x00)
			{
				loc938_n = -v1001_n;
				loc59_n.u0 = 0x01;
				loc61_n.u0 = 11604;
			}
			else
			{
				Eq_n v967_n = v967_n & 0x01;
				if ((v967_n & 0x0800) == 0x00)
				{
					Eq_n v967_n;
					if (v967_n == 0x00)
						v967_n.u0 = 0x2D55;
					else
						v967_n.u0 = 11610;
					loc59_n = v967_n;
					loc61_n = v967_n;
				}
				else
				{
					loc59_n.u0 = 0x01;
					loc61_n.u0 = 11607;
				}
				loc938_n = v1001_n;
			}
			bool v969_n = (reinterpret_cast<uint64>(loc938_n) & 0x7FF00000) < 0x7FF00000;
			Eq_n loc46_n;
			if (!v969_n)
			{
				ui32 v967_n = v967_n & 0x20;
				Eq_n v967_n;
				if (v967_n != 0x00)
					v967_n.u0 = 11623;
				else
					v967_n.u0 = 11627;
				bool v969_n = loc938_n != loc938_n;
				Eq_n v967_n;
				if (v967_n != 0x00)
					v967_n.u0 = 13538;
				else
					v967_n.u0 = 11631;
				Eq_n v967_n;
				if (v969_n)
					v967_n.u0 = 0x00;
				else
					v967_n = loc59_n;
				Eq_n v967_n;
				if (v969_n)
					v967_n = v967_n;
				else
					v967_n = v967_n;
				Eq_n v967_n;
				v967_n.u14 = v967_n.u14 + 3;
				fn000D6D47(arg0, 0x20, loc82_n, v967_n, v967_n);
				Eq_n v967_n;
				v967_n.u2 = *arg0.u3;
				Eq_n loc384_n;
				if ((v967_n & 0x20) == 0x00)
				{
					fn000D61FC(loc61_n, v967_n, arg0);
					loc384_n.u2 = *arg0.u3;
				}
				else
					loc384_n = v967_n;
				if ((loc384_n & 0x20) == 0x00)
					fn000D61FC(v967_n, 0x03, arg0);
				fn000D6D47(arg0, 0x20, loc82_n, v967_n, v967_n ^ 0x2000);
				Eq_n v967_n;
				if (v967_n < loc82_n)
					v967_n = loc82_n;
				else
					v967_n = v967_n;
				loc46_n = v967_n;
l000D5ABF:
				goto l000D5AC0;
			}
			Eq_n v1001_n = fn000D6E9E(loc938_n, v967_n + &g_dw0010);
			bool v969_n = v1001_n *64 2.0 != 0.0;
			if (v969_n)
				*(v967_n + &g_dw0010) = (word32) (*(v967_n + &g_dw0010) + ~0x00);
			ui32 v967_n = v967_n | 0x20;
			if (v967_n == 0x61)
			{
				ui32 v967_n = v967_n & 0x20;
				Eq_n v967_n;
				v967_n.u2 = &loc61_n.u15->b0009;
				Eq_n v967_n;
				if (v967_n == 0x00)
					v967_n = loc61_n;
				else
					v967_n = v967_n;
				word32 v967_n = 0x0C - loc35_n;
				Eq_n v967_n = loc59_n | 0x02;
				ui32 v967_n = loc35_n > 11 | v967_n == 0x00;
				real64 loc942_n;
				if (v967_n)
					loc942_n = v1001_n *64 2.0;
				else
				{
					real64 loc939_n = 8.0;
					word32 loc94_n = v967_n;
					real64 v1001_n;
					while (true)
					{
						word32 v967_n = loc94_n + ~0x00;
						v1001_n = loc939_n * 16.0;
						if (v967_n == 0x00)
							break;
						loc939_n = v1001_n;
						loc94_n = v967_n;
					}
					if ((int32) *v967_n.u2 == 0x2D)
						loc942_n = -(v1001_n + (-(v1001_n *64 2.0) - v1001_n));
					else
						loc942_n = v1001_n *64 2.0 + v1001_n - v1001_n;
				}
				Eq_n v967_n;
				v967_n.u2 = *(v967_n + &g_dw0010);
				Eq_n v967_n = 0x00 - v967_n;
				Eq_n v967_n;
				if (v967_n < 0x00)
					v967_n = v967_n;
				else
					v967_n = v967_n;
				Eq_n v967_n = fn000D68BF((int64) v967_n, v967_n + &g_t024C);
				Eq_n loc57_n;
				if (v967_n == v967_n + &g_t024C)
				{
					*(v967_n + 0x024B) = (word32) 0x30;
					loc57_n.u2 = v967_n + &g_t024B;
				}
				else
					loc57_n = v967_n;
				loc57_n.u15->bFFFFFFFF = ((byte) (v967_n >> 0x1F) & 0x02) + 0x2B;
				Eq_n v967_n;
				v967_n.u2 = loc57_n + ~0x01;
				*v967_n.u2 = (int8) ((byte) v967_n + 0x0F);
				Eq_n v969_n = loc35_n < 0x01;
				ui32 v967_n = v967_n & 0x08;
				Eq_n loc62_n;
				loc62_n.u0 = v967_n + &g_t024C;
				real64 loc943_n = loc942_n;
l000D42E9:
				struct Eq_n * v967_n = f64-to-int(loc943_n);
				loc62_n.u0->b0000 = v967_n->b2D33 | (byte) v967_n;
				Eq_n v967_n;
				v967_n.u0 = loc62_n + 0x01;
				real64 v1001_n = loc943_n - (real64) v967_n;
				Eq_n v967_n = v967_n - (v967_n + &g_t024C);
				Eq_n loc99_n;
				if (v967_n == 0x01)
				{
					if (v967_n == 0x00 & (v969_n & v1001_n * 16.0 == 0.0))
					{
						loc99_n = v967_n;
						goto l000D43C3;
					}
					v967_n.u0->b0000 = 0x2E;
					loc99_n.u0 = loc62_n + 0x02;
				}
				else
					loc99_n = v967_n;
l000D43C3:
				if (v1001_n * 16.0 != 0.0)
				{
					loc62_n = loc99_n;
					loc943_n = v1001_n * 16.0;
					goto l000D42E9;
				}
				Eq_n v967_n = loc35_n.u2 + (v967_n + 0x024E) - v967_n;
				Eq_n v967_n;
				v967_n.u0 = loc99_n.u0 + (v967_n - v967_n);
				Eq_n v967_n;
				if (loc35_n != 0x00 & v967_n + loc99_n < loc35_n)
					v967_n = v967_n;
				else
					v967_n = v967_n;
				Eq_n v967_n;
				v967_n.u2 = v967_n + v967_n;
				fn000D6D47(arg0, 0x20, loc82_n, v967_n, v967_n);
				if ((*arg0.u3 & 0x20) == 0x00)
					fn000D61FC(v967_n, v967_n, arg0);
				fn000D6D47(arg0, 0x30, loc82_n, v967_n, v967_n ^ 0x00010000);
				Eq_n v967_n = loc99_n - (v967_n + &g_t024C);
				if ((*arg0.u3 & 0x20) == 0x00)
					fn000D61FC(v967_n + &g_t024C, v967_n, arg0);
				Eq_n v967_n = v967_n + &g_t024C - v967_n;
				fn000D6D47(arg0, 0x30, v967_n - (v967_n + v967_n), 0x00, 0x00);
				if ((*arg0.u3 & 0x20) == 0x00)
					fn000D61FC(v967_n, v967_n, arg0);
				fn000D6D47(arg0, 0x20, loc82_n, v967_n, v967_n ^ 0x2000);
				Eq_n v967_n;
				if (v967_n < loc82_n)
					v967_n = loc82_n;
				else
					v967_n = v967_n;
				loc46_n = v967_n;
l000D5AC0:
				loc29_n = loc46_n;
				loc30_n = loc79_n;
				loc40_n = loc131_n;
				loc42_n = v967_n;
				goto l000D2F31;
			}
			Eq_n v967_n;
			if (loc35_n < 0x00)
				v967_n.u0 = 0x06;
			else
				v967_n = loc35_n;
			real64 loc944_n;
			Eq_n loc180_n;
			if (v969_n)
			{
				Eq_n v967_n;
				v967_n.u2 = *(v967_n + &g_dw0010);
				*(v967_n + &g_dw0010) = (word32) v967_n - 28;
				loc944_n = v1001_n *64 2.0 * 268435456.0;
				loc180_n.u2 = (word32) v967_n - 28;
			}
			else
			{
				loc944_n = v1001_n *64 2.0;
				loc180_n.u2 = *(v967_n + &g_dw0010);
			}
			Eq_n v967_n;
			if (loc180_n < 0x00)
				v967_n.u0 = v967_n + 0x18;
			else
				v967_n.u0 = v967_n + 0x0138;
			Eq_n loc54_n = v967_n;
			real64 loc945_n = loc944_n;
			Eq_n v967_n;
			while (true)
			{
				uint32 v967_n = f64-to-int(loc945_n);
				loc54_n.u0->t0000.u0 = v967_n;
				real64 v1001_n = loc945_n - (real64) v967_n;
				v967_n.u0 = loc54_n + 0x04;
				if (v1001_n * 1000000000.0 == 0.0)
					break;
				loc54_n = v967_n;
				loc945_n = v1001_n * 1000000000.0;
			}
			Eq_n loc89_n;
			Eq_n loc92_n;
			Eq_n loc181_n;
			if (loc180_n <= 0x00)
			{
				loc89_n = v967_n;
				loc92_n = v967_n;
				loc181_n = loc180_n;
				goto l000D481E;
			}
			Eq_n loc90_n = v967_n;
			Eq_n loc93_n = v967_n;
			Eq_n loc477_n = loc180_n;
l000D4684:
			Eq_n v967_n;
			if (loc477_n > 0x1D)
				v967_n.u0 = 0x1D;
			else
				v967_n = loc477_n;
			Eq_n v967_n;
			v967_n.u0 = loc93_n + ~0x03;
			bool v969_n = v967_n < loc90_n;
			Eq_n loc121_n;
			if (v969_n)
				loc121_n = loc90_n;
			else
			{
				uint64 v1002_n = (uint64) v967_n;
				Eq_n loc51_n = v967_n;
				Eq_n loc53_n;
				loc53_n.u0 = 0x00;
				Eq_n v982_n;
				while (true)
				{
					Eq_n v982_n = ((uint64) loc51_n.u0->t0000.u0 << v1002_n) + (uint64) loc53_n;
					loc51_n.u0->t0000.u0 = (uint32) fn000D2E1D(v982_n, 1000000000);
					Eq_n v967_n;
					v967_n.u0 = loc51_n + ~0x03;
					v982_n = fn000D17F5(v982_n, 1000000000);
					if (v967_n < loc90_n)
						break;
					loc51_n = v967_n;
					loc53_n = v982_n;
				}
				if (v982_n == 0x00)
				{
					loc121_n = loc90_n;
					goto l000D4779;
				}
				Eq_n v967_n;
				v967_n.u0 = loc90_n + ~0x03;
				v967_n.u0->t0000.u0 = (uint32) v982_n;
				loc121_n = v967_n;
			}
l000D4779:
			Eq_n loc124_n = loc93_n;
			while (loc124_n > loc121_n != 0x00)
			{
				Eq_n v967_n;
				v967_n.u0 = loc124_n + ~0x03;
				if (v967_n.u0->t0000.u0 != 0x00)
					break;
				loc124_n = v967_n;
			}
			Eq_n v967_n = *(v967_n + &g_dw0010) - v967_n;
			*(v967_n + &g_dw0010) = (word32) v967_n;
			if (v967_n > 0x00)
			{
				loc90_n = loc121_n;
				loc93_n = loc124_n;
				loc477_n = v967_n;
				goto l000D4684;
			}
			loc89_n = loc121_n;
			loc92_n = loc124_n;
			loc181_n = v967_n;
l000D481E:
			Eq_n loc137_n;
			Eq_n loc139_n;
			if (loc181_n >= 0x00)
			{
				loc137_n = loc89_n;
				loc139_n = loc92_n;
				goto l000D4A6B;
			}
			Eq_n v967_n = i32s-div((word32) v967_n + 25, 0x09);
			Eq_n loc138_n = loc89_n;
			Eq_n loc140_n = loc92_n;
			Eq_n loc502_n = loc181_n;
l000D4868:
			int32 v967_n = 0x00 - loc502_n;
			int32 v967_n;
			if (v967_n > 0x09)
				v967_n = 0x09;
			else
				v967_n = v967_n;
			bool v969_n = loc138_n < loc140_n;
			Eq_n loc11_n;
			Eq_n loc148_n;
			if (v969_n)
			{
				ui32 v967_n = 0x01 << v967_n;
				uint32 v967_n = 1000000000 >> v967_n;
				ui32 loc48_n = 0x00;
				Eq_n loc91_n = loc138_n;
				ui32 v967_n;
				while (true)
				{
					uint32 v967_n = loc91_n.u0->t0000.u0;
					loc91_n.u0->t0000.u0 = (v967_n >> v967_n) + loc48_n;
					Eq_n v967_n;
					v967_n.u0 = loc91_n + 0x04;
					v967_n = (v967_n & v967_n + ~0x00) * v967_n;
					if (v967_n >= loc140_n)
						break;
					loc48_n = v967_n;
					loc91_n = v967_n;
				}
				Eq_n v967_n;
				v967_n.u0 = loc138_n + 0x04;
				Eq_n v967_n;
				if (loc138_n.u0->t0000.u0 == 0x00)
					v967_n = v967_n;
				else
					v967_n = loc138_n;
				if (v967_n == 0x00)
				{
					loc11_n = v967_n;
					loc148_n = loc140_n;
					goto l000D49BF;
				}
				loc140_n.u0->t0000.u0 = v967_n;
				loc11_n = v967_n;
				loc148_n.u0 = loc140_n + 0x04;
			}
			else
			{
				Eq_n v967_n;
				v967_n.u0 = loc138_n + 0x04;
				Eq_n v967_n;
				if (loc138_n.u0->t0000.u0 == 0x00)
					v967_n = v967_n;
				else
					v967_n = loc138_n;
				loc11_n = v967_n;
				loc148_n = loc140_n;
			}
l000D49BF:
			Eq_n v967_n;
			if (v967_n == 0x66)
				v967_n = v967_n;
			else
				v967_n = loc11_n;
			Eq_n v967_n;
			v967_n.u0 = v967_n + ((word32) v967_n + 1 << 0x02);
			Eq_n v967_n;
			if (loc148_n - v967_n >> 0x02 > (word32) v967_n + 1)
				v967_n = v967_n;
			else
				v967_n = loc148_n;
			Eq_n v967_n = *(v967_n + &g_dw0010) + v967_n;
			*(v967_n + &g_dw0010) = (word32) v967_n;
			if (v967_n < 0x00)
			{
				loc138_n = loc11_n;
				loc140_n = v967_n;
				loc502_n = v967_n;
				goto l000D4868;
			}
			loc137_n = loc11_n;
			loc139_n = v967_n;
l000D4A6B:
			bool v969_n = loc137_n < loc139_n;
			Eq_n loc97_n;
			if (v969_n)
			{
				Eq_n v967_n = (v967_n - loc137_n >> 0x02) * 0x09;
				uint32 v967_n = loc137_n.u0->t0000.u0;
				if (v967_n < 0x0A)
				{
					loc97_n = v967_n;
					goto l000D4B0E;
				}
				Eq_n loc58_n = v967_n;
				uint32 loc67_n = 0x0A;
				Eq_n v967_n;
				while (true)
				{
					uint32 v967_n = loc67_n * 0x0A;
					v967_n.u0 = (word32) loc58_n + 1;
					if (v967_n < v967_n)
						break;
					loc58_n = v967_n;
					loc67_n = v967_n;
				}
				loc97_n = v967_n;
			}
			else
				loc97_n.u0 = 0x00;
l000D4B0E:
			Eq_n v967_n;
			if (v967_n != 0x66)
				v967_n = loc97_n;
			else
				v967_n.u0 = 0x00;
			Eq_n v969_n = v967_n != 0x00;
			Eq_n v967_n;
			v967_n.u1 = &(v967_n - v967_n).u1->b0000 + (int32) (v969_n & v967_n == 0x67);
			Eq_n loc160_n;
			Eq_n loc172_n;
			Eq_n loc174_n;
			if (v967_n >= (loc139_n - v967_n >> 0x02) * 0x09 + ~0x08)
			{
				loc160_n = loc97_n;
				loc172_n = loc139_n;
				loc174_n = loc137_n;
				goto l000D4F7F;
			}
			Eq_n v967_n;
			v967_n.u0 = (char *) &((word32) i32s-div((word32) v967_n + 0x00002400, 0x09) - 0x0400 << 0x02).u1->t0000.u0 + (v967_n + 0x04);
			int32 v967_n = i32s-rem((word32) v967_n + 0x00002400, 0x09);
			ui32 loc102_n;
			if (v967_n < 0x08)
			{
				int32 loc66_n = v967_n + 0x01;
				ui32 loc103_n = 0x0A;
				ui32 v967_n;
				while (true)
				{
					v967_n = loc103_n * 0x0A;
					int32 v967_n = loc66_n + 0x01;
					if (v967_n == 0x09)
						break;
					loc66_n = v967_n;
					loc103_n = v967_n;
				}
				loc102_n = v967_n;
			}
			else
				loc102_n = 0x0A;
			word32 v967_n = v967_n.u0->t0000.u0;
			up32 v967_n = i32u-rem(v967_n, loc102_n);
			Eq_n v969_n = v967_n + 0x04 == loc139_n;
			ui32 v967_n = v969_n & v967_n == 0x00;
			Eq_n loc147_n;
			Eq_n loc149_n;
			Eq_n loc173_n;
			if (v967_n)
			{
				loc147_n = v967_n;
				loc149_n = loc97_n;
				loc173_n = loc137_n;
				goto l000D4F38;
			}
			real64 v1001_n;
			if ((i32u-div(v967_n, loc102_n) & 0x01) == 0x00)
				v1001_n = 9007199254740992.0;
			else
				v1001_n = 9007199254740994.0;
			up32 v967_n = i32s-div(loc102_n, 0x02);
			real64 loc937_n;
			if (v967_n < v967_n)
				loc937_n = 0.5;
			else
			{
				real64 v1001_n;
				if (v969_n & v967_n == v967_n)
					v1001_n = 1.0;
				else
					v1001_n = 1.5;
				loc937_n = v1001_n;
			}
			bool v969_n = loc59_n == 0x00;
			real64 loc940_n;
			real64 loc941_n;
			if (v969_n)
			{
				loc940_n = loc937_n;
				loc941_n = v1001_n;
			}
			else
			{
				if ((int32) *loc61_n.u2 == 0x2D == 0x00)
				{
					loc940_n = loc937_n;
					loc941_n = v1001_n;
					goto l000D4D8E;
				}
				loc940_n = -loc937_n;
				loc941_n = -v1001_n;
			}
l000D4D8E:
			word32 v967_n = v967_n - v967_n;
			v967_n.u0->t0000.u0 = v967_n;
			if (loc941_n + loc940_n != loc941_n == 0x00)
			{
				loc147_n = v967_n;
				loc149_n = loc97_n;
				loc173_n = loc137_n;
				goto l000D4F39;
			}
			up32 v967_n = v967_n + loc102_n;
			v967_n.u0->t0000.u0 = v967_n;
			Eq_n loc122_n;
			Eq_n loc157_n;
			if (v967_n > 999999999)
			{
				Eq_n loc123_n = v967_n;
				Eq_n loc158_n = loc137_n;
				Eq_n v967_n;
				Eq_n loc165_n;
				while (true)
				{
					loc123_n.u0->t0000.u0 = 0x00;
					v967_n.u0 = loc123_n + ~0x03;
					if (v967_n < loc158_n)
					{
						Eq_n v967_n;
						v967_n.u0 = loc158_n + ~0x03;
						v967_n.u0->t0000.u0 = 0x00;
						loc165_n = v967_n;
					}
					else
						loc165_n = loc158_n;
					up32 v967_n = v967_n.u0->t0000.u0;
					v967_n.u0->t0000.u0 = v967_n + 0x01;
					if (v967_n <= 999999998)
						break;
					loc123_n = v967_n;
					loc158_n = loc165_n;
				}
				loc122_n = v967_n;
				loc157_n = loc165_n;
			}
			else
			{
				loc122_n = v967_n;
				loc157_n = loc137_n;
			}
			Eq_n v967_n = (v967_n - loc157_n >> 0x02) * 0x09;
			uint32 v967_n = loc157_n.u0->t0000.u0;
			if (v967_n < 0x0A)
			{
				loc147_n = loc122_n;
				loc149_n = v967_n;
				loc173_n = loc157_n;
				goto l000D4F39;
			}
			Eq_n loc126_n = v967_n;
			uint32 loc128_n = 0x0A;
			Eq_n v967_n;
			while (true)
			{
				uint32 v967_n = loc128_n * 0x0A;
				v967_n.u0 = (word32) loc126_n + 1;
				if (v967_n < v967_n)
					break;
				loc126_n = v967_n;
				loc128_n = v967_n;
			}
			loc147_n = loc122_n;
			loc149_n = v967_n;
			loc173_n = loc157_n;
l000D4F39:
			Eq_n v967_n;
			v967_n.u0 = loc147_n + 0x04;
			Eq_n v967_n;
			if (loc139_n > v967_n)
				v967_n = v967_n;
			else
				v967_n = loc139_n;
			loc160_n = loc149_n;
			loc172_n = v967_n;
			loc174_n = loc173_n;
l000D4F7F:
			Eq_n v967_n = 0x00 - loc160_n;
			Eq_n loc171_n = loc172_n;
			word32 loc175_n;
			while (loc171_n > loc174_n != 0x00)
			{
				Eq_n v967_n;
				v967_n.u0 = loc171_n + ~0x03;
				if (v967_n.u0->t0000.u0 != 0x00)
				{
					loc175_n = 0x01;
					goto l000D4FDC;
				}
				loc171_n = v967_n;
			}
			loc175_n = 0x00;
l000D4FDC:
			int32 loc88_n;
			ui32 loc184_n;
			Eq_n loc136_n;
			if (v967_n != 0x67)
			{
				ui32 v967_n = v967_n & 0x08;
				loc88_n = v967_n;
				loc184_n = v967_n;
				loc136_n = v967_n;
				goto l000D5230;
			}
			Eq_n v967_n;
			v967_n.u0 = v967_n.u2 + (v969_n & 0x01 ^ 0x01);
			int32 loc47_n;
			Eq_n loc120_n;
			if (v967_n > loc160_n & loc160_n > ~0x04)
			{
				loc47_n = v967_n + ~0x00;
				loc120_n = &v967_n.u0->bFFFFFFFF - loc160_n;
			}
			else
			{
				loc47_n = v967_n + ~0x01;
				loc120_n.u2 = &v967_n.u0->bFFFFFFFF;
			}
			ui32 v967_n = v967_n & 0x08;
			if (v967_n == 0x00 == 0x00)
			{
				loc88_n = loc47_n;
				loc136_n = loc120_n;
				loc184_n = v967_n;
				goto l000D5230;
			}
			ui32 loc127_n;
			if (loc175_n)
			{
				word32 v967_n = loc171_n.u0->dwFFFFFFFC;
				if (v967_n == 0x00)
				{
					loc127_n = 0x09;
					goto l000D5137;
				}
				if (i32u-rem(v967_n, 0x0A) != 0x00)
				{
					loc127_n = 0x00;
					goto l000D5137;
				}
				ui32 loc101_n = 0x00;
				ui32 loc141_n = 0x0A;
				ui32 v967_n;
				while (true)
				{
					ui32 v967_n = loc141_n * 0x0A;
					v967_n = loc101_n + 0x01;
					if (i32u-rem(v967_n, v967_n) != 0x00)
						break;
					loc101_n = v967_n;
					loc141_n = v967_n;
				}
				loc127_n = v967_n;
			}
			else
				loc127_n = 0x09;
l000D5137:
			ui32 v967_n = (loc171_n - v967_n >> 0x02) * 0x09;
			if ((loc47_n | 0x20) == 0x66)
			{
				Eq_n v967_n = v967_n + ~0x08 - loc127_n;
				Eq_n v967_n;
				if (v967_n < 0x00)
					v967_n.u0 = 0x00;
				else
					v967_n = v967_n;
				Eq_n v967_n;
				if (loc120_n < v967_n)
					v967_n = loc120_n;
				else
					v967_n = v967_n;
				loc88_n = loc47_n;
				loc136_n = v967_n;
				loc184_n = 0x00;
			}
			else
			{
				Eq_n v967_n = (char *) &loc160_n.u0->t0000.u0 + (v967_n + ~0x08) - loc127_n;
				Eq_n v967_n;
				if (v967_n < 0x00)
					v967_n.u0 = 0x00;
				else
					v967_n = v967_n;
				Eq_n v967_n;
				if (loc120_n < v967_n)
					v967_n = loc120_n;
				else
					v967_n = v967_n;
				loc88_n = loc47_n;
				loc136_n = v967_n;
				loc184_n = 0x00;
			}
l000D5230:
			ui32 v967_n = loc136_n | loc184_n;
			Mem4128 = Mem11953;
			ui32 v967_n = v967_n != 0x00 & 0x01;
			ui32 v967_n = loc88_n | 0x20;
			Eq_n loc125_n;
			Eq_n loc178_n;
			if (v967_n == 0x66)
			{
				Eq_n v967_n;
				if (loc160_n > 0x00)
					v967_n = loc160_n;
				else
					v967_n.u0 = 0x00;
				loc125_n.u0 = 0x00;
				loc178_n = v967_n;
			}
			else
			{
				Eq_n v967_n;
				if (loc160_n < 0x00)
					v967_n = v967_n;
				else
					v967_n = loc160_n;
				Eq_n v967_n = fn000D68BF((int64) v967_n, v967_n + &g_t024C);
				Eq_n loc95_n;
				if (v967_n + &g_t024C - v967_n < 0x02)
				{
					Eq_n loc96_n = v967_n;
					Eq_n v967_n;
					while (true)
					{
						v967_n.u2 = loc96_n + ~0x00;
						*v967_n.u2 = 0x30;
						if (v967_n + &g_t024C - v967_n >= 0x02)
							break;
						loc96_n = v967_n;
					}
					loc95_n = v967_n;
				}
				else
					loc95_n = v967_n;
				loc95_n.u15->bFFFFFFFF = ((byte) (loc160_n >> 0x1F) & 0x02) + 0x2B;
				Eq_n v967_n;
				v967_n.u2 = loc95_n + ~0x01;
				*v967_n.u2 = (byte) loc88_n;
				loc125_n = v967_n;
				loc178_n = v967_n + &g_t024C - v967_n;
			}
			Eq_n v967_n;
			v967_n.u2 = (char *) &loc178_n.u0->t0000.u0 + (((loc59_n.u14 + 1) + loc136_n) + v967_n);
			fn000D6D47(arg0, 0x20, loc82_n, v967_n, v967_n);
			if ((*arg0.u3 & 0x20) == 0x00)
				fn000D61FC(loc61_n, loc59_n, arg0);
			fn000D6D47(arg0, 0x30, loc82_n, v967_n, v967_n ^ 0x00010000);
			if (v967_n == 0x66)
			{
				Eq_n v967_n;
				if (loc174_n > v967_n)
					v967_n = v967_n;
				else
					v967_n = loc174_n;
				Eq_n loc159_n = v967_n;
l000D5429:
				Eq_n v967_n = fn000D68BF((uint64) loc159_n.u0->t0000.u0, v967_n + 0x0255);
				bool v969_n = loc159_n == v967_n;
				Eq_n loc87_n;
				if (v969_n)
				{
					if (v967_n == v967_n + &g_t0255 == 0x00)
					{
						loc87_n = v967_n;
						goto l000D54E4;
					}
					*(v967_n + 0x0254) = (word32) 0x30;
					loc87_n.u2 = v967_n + &g_t0254;
				}
				else
				{
					if (v967_n > v967_n + &g_t024C == 0x00)
					{
						loc87_n = v967_n;
						goto l000D54E4;
					}
					_memset(v967_n + &g_t024C, 0x30, v967_n - (v967_n + &g_t024C));
					Eq_n loc45_n = v967_n;
					Eq_n v967_n;
					while (true)
					{
						v967_n.u2 = &loc45_n.u15->bFFFFFFFF;
						if (v967_n <= v967_n + &g_t024C)
							break;
						loc45_n = v967_n;
					}
					loc87_n = v967_n;
				}
l000D54E4:
				if ((*arg0.u3 & 0x20) == 0x00)
					fn000D61FC(loc87_n, v967_n + &g_t0255 - loc87_n, arg0);
				Eq_n v967_n;
				v967_n.u0 = loc159_n + 0x04;
				if (v967_n > v967_n)
				{
					if (v967_n == 0x00 == 0x00)
					{
						if ((*arg0.u3 & 0x20) == 0x00 == 0x00)
							goto l000D5586;
						fn000D61FC(11635, 0x01, arg0);
					}
l000D5586:
					Eq_n loc145_n;
					if (loc136_n > 0x00 & v967_n < loc171_n)
					{
						Eq_n loc146_n = loc136_n;
						Eq_n loc167_n = v967_n;
						Eq_n v967_n;
						while (true)
						{
							Eq_n v967_n = fn000D68BF((uint64) loc167_n.u0->t0000.u0, v967_n + &g_t0255);
							Eq_n loc43_n;
							if (v967_n > v967_n + &g_t024C)
							{
								_memset(v967_n + &g_t024C, 0x30, v967_n - (v967_n + &g_t024C));
								Eq_n loc44_n = v967_n;
								Eq_n v967_n;
								while (true)
								{
									v967_n.u2 = &loc44_n.u15->bFFFFFFFF;
									if (v967_n <= v967_n + &g_t024C)
										break;
									loc44_n = v967_n;
								}
								loc43_n = v967_n;
							}
							else
								loc43_n = v967_n;
							if ((*arg0.u3 & 0x20) == 0x00)
							{
								Eq_n v967_n;
								if (loc146_n > 0x09)
									v967_n.u0 = 0x09;
								else
									v967_n = loc146_n;
								fn000D61FC(loc43_n, v967_n, arg0);
							}
							Eq_n v967_n;
							v967_n.u0 = loc167_n + 0x04;
							v967_n.u2 = (word32) loc146_n - 9;
							if (!(loc146_n > 0x09 & v967_n < loc171_n))
								break;
							loc146_n = v967_n;
							loc167_n = v967_n;
						}
						loc145_n = v967_n;
					}
					else
						loc145_n = loc136_n;
					fn000D6D47(arg0, 0x30, &loc145_n.u15->b0009, 0x09, 0x00);
					goto l000D5969;
				}
				loc159_n = v967_n;
				goto l000D5429;
			}
			Eq_n v967_n;
			v967_n.u0 = loc174_n + 0x04;
			Eq_n v967_n;
			if (loc175_n)
				v967_n = loc171_n;
			else
				v967_n = v967_n;
			Eq_n loc151_n;
			if (loc136_n <= ~0x00)
			{
				loc151_n = loc136_n;
				goto l000D5914;
			}
			Eq_n v969_n = loc184_n == 0x00;
			Eq_n loc163_n = loc136_n;
			Eq_n loc169_n = loc174_n;
l000D5728:
			Eq_n v967_n = fn000D68BF((uint64) loc169_n.u0->t0000.u0, v967_n + &g_t0255);
			Eq_n loc18_n;
			if (v967_n == v967_n + &g_t0255)
			{
				*(v967_n + &g_t0254) = (word32) 0x30;
				loc18_n.u2 = v967_n + &g_t0254;
			}
			else
				loc18_n = v967_n;
			bool v969_n = loc169_n == loc174_n;
			Eq_n loc106_n;
			if (v969_n)
			{
				Eq_n v967_n;
				v967_n.u2 = loc18_n + 0x01;
				if ((*arg0.u3 & 0x20) == 0x00)
					fn000D61FC(loc18_n, 0x01, arg0);
				if (v969_n & loc163_n < 0x01)
				{
					loc106_n = v967_n;
					goto l000D5869;
				}
				if ((*arg0.u3 & 0x20) == 0x00 == 0x00)
				{
					loc106_n = v967_n;
					goto l000D5869;
				}
				fn000D61FC(11635, 0x01, arg0);
				loc106_n = v967_n;
			}
			else
			{
				if (loc18_n > v967_n + &g_t024C == 0x00)
				{
					loc106_n = loc18_n;
					goto l000D5869;
				}
				_memset(v967_n + &g_t024C, 0x30, loc18_n + v967_n);
				Eq_n loc104_n = loc18_n;
				Eq_n v967_n;
				while (true)
				{
					v967_n.u2 = loc104_n + ~0x00;
					if (v967_n <= v967_n + &g_t024C)
						break;
					loc104_n = v967_n;
				}
				loc106_n = v967_n;
			}
l000D5869:
			Eq_n v967_n = v967_n + &g_t0255 - loc106_n;
			if ((*arg0.u3 & 0x20) == 0x00)
			{
				Eq_n v967_n;
				if (loc163_n > v967_n)
					v967_n = v967_n;
				else
					v967_n = loc163_n;
				fn000D61FC(loc106_n, v967_n, arg0);
			}
			Eq_n v967_n;
			v967_n.u0 = loc169_n + 0x04;
			Eq_n v967_n = loc163_n - v967_n;
			if (v967_n < v967_n & v967_n > ~0x00)
			{
				loc163_n = v967_n;
				loc169_n = v967_n;
				goto l000D5728;
			}
			loc151_n = v967_n;
l000D5914:
			fn000D6D47(arg0, 0x30, (word32) loc151_n + 18, 0x12, 0x00);
			if ((*arg0.u3 & 0x20) == 0x00 == 0x00)
				goto l000D596A;
			fn000D61FC(loc125_n, v967_n + &g_t024C - loc125_n, arg0);
l000D596A:
			fn000D6D47(arg0, 0x20, loc82_n, v967_n, v967_n ^ 0x2000);
			Eq_n v967_n;
			if (v967_n < loc82_n)
				v967_n = loc82_n;
			else
				v967_n = v967_n;
			loc46_n = v967_n;
			goto l000D5ABF;
		}
		Eq_n v967_n;
		v967_n.u14 = loc144_n.u14 + 2;
		Eq_n v967_n;
		v967_n.u0 = (int32) *v967_n.u2;
		if (v967_n < 0x3A && (int32) (loc144_n.u14)[3] == 0x24)
		{
			arg4.u3[(word32) v967_n - 48] = (int32) 0x0A;
			loc35_n.u2 = arg3.u4[(int32) *v967_n.u2 + ~0x2F];
			loc164_n.u15 = loc144_n.u15 + 2;
			goto l000D3862;
		}
		if (loc131_n == 0x00 == 0x00)
			goto l000D60EB;
		if (arg0 != 0x00)
		{
			union Eq_n * v967_n = *arg2.u3 + 0x03 & ~0x03;
			Eq_n v967_n;
			v967_n.u2 = v967_n->u2;
			*arg2.u3 = (char *) v967_n + 4;
			loc35_n = v967_n;
		}
		else
			loc35_n.u0 = 0x00;
		loc164_n = v967_n;
	}
	else
	{
		loc35_n.u0 = ~0x00;
		loc164_n = loc144_n;
	}
	goto l000D3862;
}

// 000D61F1: Stack Eq_n fn000D61F1(Stack Eq_n arg0)
// Called from:
//      fn000D2BD4
//      _fflush
//      fn000DBA9B
//      fn000DEB18
//      fn000DEC35
//      fn000DEDA6
//      fn000DEE2E
Eq_n fn000D61F1(Eq_n arg0)
{
	return <invalid>;
}

// 000D61FC: Stack Eq_n fn000D61FC(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000D2E2C
//      fn000D6D47
//      fn000DEDA6
Eq_n fn000D61FC(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v45_n;
	v45_n.u2 = arg2.u17[4];
	Eq_n loc12;
	word32 loc43;
	if (v45_n == 0x00)
	{
		if (fn000D799D(arg2) == 0x00)
		{
			loc12.u2 = arg2.u17[4];
			loc43 = 0x05;
		}
	}
	else
	{
		loc12 = v45_n;
		loc43 = 0x05;
	}
	if (loc43 != 0x05)
		return <invalid>;
	Eq_n v45_n;
	v45_n.u2 = arg2.u15[0x0A];
	if (loc12 - v45_n < arg1)
		return <invalid>;
	int32 v45_n = (int32) arg2.u15->b004B;
	Eq_n loc5_n;
	Eq_n loc6_n;
	Eq_n loc33_n;
	if (v45_n > ~0x00)
	{
		Eq_n loc3_n = arg1;
		while (loc3_n != 0x00)
		{
			Eq_n v45_n;
			v45_n.u2 = &loc3_n.u15->bFFFFFFFF;
			if ((int32) *(arg0 + v45_n) == 0x0A)
			{
				if ((arg2.u15[18] & 0x01FF) + 0x0F20 < loc3_n)
					return <invalid>;
				loc5_n = arg1 - loc3_n;
				loc6_n.u2 = arg0 + loc3_n;
				loc33_n.u2 = arg2.u15[0x0A];
				goto l000D638C;
			}
			loc3_n = v45_n;
		}
		loc5_n = arg1;
		loc6_n = arg0;
		loc33_n = v45_n;
	}
	else
	{
		loc5_n = arg1;
		loc6_n = arg0;
		loc33_n = v45_n;
l000D638C:
	}
	_memcpy(loc33_n, loc6_n, loc5_n);
	arg2.u15[0x0A] = (struct Eq_n) (arg2.u15[0x0A] + loc5_n);
	return <invalid>;
}

// 000D63BF: void fn000D63BF(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000D2E2C
void fn000D63BF(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	if (arg1 > 0x14 == 0x00)
	{
		switch (arg1)
		{
		case 0x09:
			union Eq_n * v156_n = *arg2.u3 + 0x03 & ~0x03;
			Eq_n v156_n;
			v156_n.u2 = v156_n->u2;
			*arg2.u3 = (char *) v156_n + 4;
			*arg0.u3 = (int32) v156_n;
			break;
		case 0x0A:
			word32 * v156_n = *arg2.u3 + 0x03 & ~0x03;
			word32 v156_n = *v156_n;
			*arg2.u3 = v156_n + 1;
			*arg0.u4 = (real64) (int64) v156_n;
			break;
		case 11:
			word32 * v156_n = *arg2.u3 + 0x03 & ~0x03;
			word32 v156_n = *v156_n;
			*arg2.u3 = v156_n + 1;
			*arg0.u4 = (real64) (uint64) v156_n;
			break;
		case 0x0C:
			union Eq_n * v156_n = *arg2.u3 + 0x07 & ~0x07;
			Eq_n v162_n;
			v162_n.u15 = v156_n->u15;
			*arg2.u3 = (char *) v156_n + 8;
			*arg0.u4 = (real64) v162_n;
			break;
		case 0x0D:
			word32 * v156_n = *arg2.u3 + 0x03 & ~0x03;
			word32 v156_n = *v156_n;
			*arg2.u3 = v156_n + 1;
			*arg0.u4 = (real64) (int64) (word16) v156_n;
			break;
		case 0x0E:
			ui32 * v156_n = *arg2.u3 + 0x03 & ~0x03;
			ui32 v156_n = *v156_n;
			*arg2.u3 = v156_n + 1;
			*arg0.u4 = (real64) (uint64) (v156_n & 0xFFFF);
			break;
		case 0x0F:
			word32 * v156_n = *arg2.u3 + 0x03 & ~0x03;
			word32 v156_n = *v156_n;
			*arg2.u3 = v156_n + 1;
			*arg0.u4 = (real64) (int64) (byte) v156_n;
			break;
		case 0x10:
			ui32 * v156_n = *arg2.u3 + 0x03 & ~0x03;
			ui32 v156_n = *v156_n;
			*arg2.u3 = v156_n + 1;
			*arg0.u4 = (real64) (uint64) (v156_n & 0xFF);
			break;
		case 0x11:
			union Eq_n * v156_n = *arg2.u3 + 0x07 & ~0x07;
			Eq_n v163_n;
			v163_n.u15 = v156_n->u15;
			*arg2.u3 = (char *) v156_n + 8;
			*arg0.u4 = (real64) v163_n;
			break;
		case 0x12:
			union Eq_n * v156_n = *arg2.u3 + 0x07 & ~0x07;
			Eq_n v163_n;
			v163_n.u15 = v156_n->u15;
			*arg2.u3 = (char *) v156_n + 8;
			*arg0.u4 = (real64) v163_n;
			break;
		}
	}
}

// 000D68BF: Stack Eq_n fn000D68BF(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000D2E2C
Eq_n fn000D68BF(Eq_n arg0, Eq_n arg1)
{
	Eq_n loc2_n;
	Eq_n loc4_n;
	if (arg0 > 0xFFFFFFFF)
	{
		Eq_n loc23_n = arg0;
		Eq_n loc5_n = arg1;
		Eq_n v28_n;
		Eq_n v29_n;
		while (true)
		{
			v28_n.u0 = &loc5_n.u1->bFFFFFFFF;
			v28_n.u0->b0000 = (byte) fn000D2E1D(loc23_n, 0x0A) | 0x30;
			v29_n = fn000D17F5(loc23_n, 0x0A);
			if (loc23_n <= 0xFFFFFFFF)
				break;
			loc23_n = v29_n;
			loc5_n = v28_n;
		}
		loc2_n = v29_n;
		loc4_n = v28_n;
	}
	else
	{
		loc2_n = arg0;
		loc4_n = arg1;
	}
	if (loc2_n != 0x00)
	{
		Eq_n loc3_n = loc2_n;
		Eq_n loc7_n = loc4_n;
		while (true)
		{
			Eq_n v28_n;
			v28_n.u0 = &loc7_n.u1->bFFFFFFFF;
			v28_n.u0->b0000 = (byte) i32u-rem(loc3_n, 0x0A) | 0x30;
			Eq_n v28_n = i32u-div(loc3_n, 0x0A);
			if (loc3_n < 0x0A)
				break;
			loc3_n = v28_n;
			loc7_n = v28_n;
		}
	}
	return <invalid>;
}

// 000D69BF: Stack Eq_n fn000D69BF(Stack Eq_n arg0)
// Called from:
//      fn000D2E2C
//      fn0011D16F
Eq_n fn000D69BF(Eq_n arg0)
{
	struct Eq_n * loc3_n = null;
	int8 * loc2;
	struct Eq_n * loc5;
	word32 loc18_n;
	while (((word32) loc3_n[11637] & 0xFF) != arg0)
	{
		struct Eq_n * v22_n = loc3_n + 1;
		if (v22_n == &g_t0057)
		{
			loc2 = &g_b2DCD;
			loc5 = &g_t0057;
			loc18_n = 0x05;
			goto l000D6A23;
		}
		loc3_n = v22_n;
	}
	loc18_n = 0x02;
l000D6A23:
	if (loc18_n == 0x02)
	{
		if (loc3_n != null)
		{
			loc2 = &g_b2DCD;
			loc5 = loc3_n;
			loc18_n = 0x05;
		}
	}
	if (loc18_n == 0x05)
	{
		while (true)
		{
			int8 * loc4_n = loc2;
			int8 * v22_n;
			while (true)
			{
				v22_n = loc4_n + 1;
				if ((int32) *loc4_n == 0x00)
					break;
				loc4_n = v22_n;
			}
			struct Eq_n * v22_n = (struct Eq_n *) ((char *) loc5 - 1);
			if (v22_n == null)
				break;
			loc2 = v22_n;
			loc5 = v22_n;
		}
	}
	return <invalid>;
}

// 000D6AC0: Stack Eq_n fn000D6AC0(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000D2E2C
//      fn000DD5D8
Eq_n fn000D6AC0(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	ui32 v59_n = arg2 != 0x00 & (arg0 & 0x03) != 0x00;
	Eq_n loc4;
	Eq_n loc7;
	Eq_n loc17;
	Eq_n loc5;
	Eq_n loc8;
	word32 loc57_n;
	if (v59_n)
	{
		Eq_n loc6_n = arg0;
		Eq_n loc9_n = arg2;
		while ((int32) *loc6_n.u2 != (int32) ((byte) arg1))
		{
			Eq_n v59_n;
			v59_n.u14 = loc6_n.u14 + 1;
			Eq_n v59_n;
			v59_n.u2 = &loc9_n.u15->bFFFFFFFF;
			if (!(v59_n != 0x00 & (v59_n & 0x03) != 0x00))
			{
				loc4 = v59_n;
				loc7 = v59_n;
				loc17 = v59_n != 0x00;
				goto l000D6B98;
			}
			loc6_n = v59_n;
			loc9_n = v59_n;
		}
		loc5 = loc6_n;
		loc8 = loc9_n;
		loc57_n = 0x06;
	}
	else
	{
		loc4 = arg0;
		loc7 = arg2;
		loc17 = arg2 != 0x00;
l000D6B98:
		loc57_n = 0x05;
	}
	Eq_n loc16;
	if (loc57_n == 0x05)
	{
		if (loc17)
		{
			loc5 = loc4;
			loc8 = loc7;
			loc57_n = 0x06;
		}
		else
			loc16.u0 = 0x00;
	}
	if (loc57_n != 0x06)
		return <invalid>;
	if ((int32) *loc5.u2 != (int32) ((byte) arg1))
	{
		ui32 v59_n = (arg1 & 0xFF) * 0x01010101;
		bool v61_n = loc8 > 0x03;
		Eq_n loc3;
		Eq_n loc11;
		Eq_n loc13;
		Eq_n loc15;
		if (v61_n)
		{
			Eq_n loc10_n = loc5;
			Eq_n loc12_n = loc8;
			while (true)
			{
				ui32 v59_n = *loc10_n.u3 ^ v59_n;
				if (((v59_n & 0x80808080 ^ 0x80808080) & v59_n + ~0x01010100) == 0x00 == 0x00)
					break;
				Eq_n v59_n;
				v59_n.u2 = loc10_n + 0x04;
				Eq_n v59_n;
				v59_n.u2 = &loc12_n.u15->dwFFFFFFFC;
				if (v59_n <= 0x03)
				{
					loc3 = v59_n;
					loc11 = v59_n;
					loc57_n = 11;
					goto l000D6CA6;
				}
				loc10_n = v59_n;
				loc12_n = v59_n;
			}
			loc13 = loc10_n;
			loc15 = loc12_n;
		}
		else
		{
			loc3 = loc5;
			loc11 = loc8;
			loc57_n = 11;
		}
l000D6CA6:
		if (loc57_n == 11)
		{
			if (loc11 == 0x00)
			{
				loc16.u0 = 0x00;
				return <invalid>;
			}
			loc13 = loc3;
			loc15 = loc11;
		}
		while ((int32) *loc13.u2 != (int32) ((byte) arg1))
		{
			Eq_n v59_n;
			v59_n.u2 = loc13 + 0x01;
			Eq_n v59_n;
			v59_n.u2 = &loc15.u15->bFFFFFFFF;
			if (v59_n == 0x00)
			{
				loc16.u0 = 0x00;
				goto l000D6D2C;
			}
			loc13 = v59_n;
			loc15 = v59_n;
		}
		loc16 = loc15;
		return <invalid>;
	}
	else
	{
		loc16 = loc8;
l000D6D2C:
		return <invalid>;
	}
}

// 000D6D47: void fn000D6D47(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3, Stack Eq_n arg4)
// Called from:
//      fn000D2E2C
void fn000D6D47(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3, Eq_n arg4)
{
	Eq_n v29_n;
	v29_n.u2 = g_t140030.u2;
	g_t140030.u2 += 0x0100;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x0100);
	ui32 v29_n = arg2 > arg3 & (arg4 & 0x00012000) == 0x00;
	if (v29_n)
	{
		Eq_n v29_n = arg2 - arg3;
		Eq_n v29_n;
		if (v29_n > 0x0100)
			v29_n.u0 = 0x0100;
		else
			v29_n = v29_n;
		_memset(v29_n, arg1, v29_n);
		ui32 v29_n = *arg0.u3;
		Eq_n v31_n = (v29_n & 0x20) == 0x00;
		Eq_n loc5_n;
		if (v29_n > 0xFF)
		{
			int32 v29_n = arg2 - arg3;
			Eq_n loc6_n = v29_n;
			ui32 loc21_n = v29_n;
			Eq_n loc22_n = v31_n;
			ui32 v29_n;
			while (true)
			{
				ui32 loc18_n;
				if (loc22_n)
				{
					fn000D61FC(v29_n, 0x0100, arg0);
					loc18_n = *arg0.u3;
				}
				else
					loc18_n = loc21_n;
				Eq_n v29_n;
				v29_n.u2 = (word32) loc6_n - 0x0100;
				v29_n = loc18_n & 0x20;
				if (v29_n <= 0xFF)
					break;
				loc6_n = v29_n;
				loc21_n = loc18_n;
				loc22_n = v29_n == 0x00;
			}
			if (v29_n != 0x00)
			{
l000D6E6B:
				g_t140030.u2 = (int8 *) v29_n;
				return;
			}
			loc5_n = v29_n & 0xFF;
		}
		else
		{
			if (!v31_n)
				goto l000D6E6B;
			loc5_n = v29_n;
		}
		fn000D61FC(v29_n, loc5_n, arg0);
	}
	goto l000D6E6B;
}

// 000D6E73: Stack Eq_n fn000D6E73(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000D2E2C
Eq_n fn000D6E73(Eq_n arg0, Eq_n arg1)
{
	if (arg0 != 0x00)
		fn000D779F(arg0, arg1, 0x00);
	return <invalid>;
}

// 000D6E9E: Stack Eq_n fn000D6E9E(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000D2E2C
Eq_n fn000D6E9E(Eq_n arg0, Eq_n arg1)
{
	return <invalid>;
}

// 000D6EB2: Stack Eq_n fn000D6EB2(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000D6E9E
//      fn000D6EB2
Eq_n fn000D6EB2(Eq_n arg0, Eq_n arg1)
{
	Eq_n v25_n = reinterpret_cast<uint64>(arg0);
	switch ((int32) (word48) (v25_n >> 0x34 & 0x07FF))
	{
	case 0:
		ui32 loc8_n;
		if (arg0 != 0.0)
		{
			fn000D6EB2(arg0 *64 1.8446744073709552e+19, arg1);
			loc8_n = arg1.u1->t0000.u0 + ~0x3F;
		}
		else
			loc8_n = 0x00;
		arg1.u1->t0000.u0 = loc8_n;
		break;
	case 1:
		break;
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 0x0A:
	case 11:
	case 0x0C:
	case 0x0D:
	case 0x0E:
	case 0x0F:
	case 16:
	case 0x0011:
	case 18:
	case 19:
	case 20:
	case 21:
	case 22:
	case 23:
	case 24:
	case 25:
	case 26:
	case 27:
	case 28:
	case 29:
	case 30:
	case 31:
	case 32:
	case 33:
	case 0x0022:
	case 35:
	case 36:
	case 37:
	case 38:
	case 39:
	case 40:
	case 41:
	case 42:
	case 43:
	case 44:
	case 45:
	case 46:
	case 47:
	case 48:
	case 49:
	case 50:
	case 0x0033:
	case 52:
	case 53:
	case 54:
	case 55:
	case 56:
	case 57:
	case 58:
	case 59:
	case 60:
	case 61:
	case 62:
	case 63:
	case 64:
	case 65:
	case 66:
	case 67:
	case 0x0044:
	case 69:
	case 70:
	case 71:
	case 72:
	case 73:
	case 74:
	case 75:
	case 76:
	case 77:
	case 78:
	case 79:
	case 80:
	case 81:
	case 82:
	case 83:
	case 84:
	case 0x0055:
	case 86:
	case 87:
	case 88:
	case 89:
	case 90:
	case 91:
	case 92:
	case 93:
	case 94:
	case 95:
	case 96:
	case 97:
	case 98:
	case 99:
	case 100:
	case 101:
	case 0x0066:
	case 0x0067:
	case 0x0068:
	case 0x0069:
	case 0x006A:
	case 0x006B:
	case 0x006C:
	case 0x006D:
	case 110:
	case 111:
	case 112:
	case 113:
	case 114:
	case 115:
	case 116:
	case 117:
	case 118:
	case 0x0077:
	case 0x0078:
	case 121:
	case 122:
	case 0x007B:
	case 0x007C:
	case 0x007D:
	case 0x007E:
	case 0x007F:
	case 0x0080:
	case 0x0081:
	case 0x0082:
	case 131:
	case 0x0084:
	case 133:
	case 0x0086:
	case 0x0087:
	case 0x0088:
	case 0x0089:
	case 0x008A:
	case 0x008B:
	case 0x008C:
	case 141:
	case 0x008E:
	case 0x008F:
	case 144:
	case 0x0091:
	case 0x0092:
	case 0x0093:
	case 0x0094:
	case 0x0095:
	case 0x0096:
	case 151:
	case 0x0098:
	case 0x0099:
	case 0x009A:
	case 155:
	case 0x009C:
	case 0x009D:
	case 0x009E:
	case 0x009F:
	case 0x00A0:
	case 161:
	case 0x00A2:
	case 0x00A3:
	case 0x00A4:
	case 0x00A5:
	case 166:
	case 0x00A7:
	case 0x00A8:
	case 0x00A9:
	case 0x00AA:
	case 171:
	case 0x00AC:
	case 0x00AD:
	case 0x00AE:
	case 0x00AF:
	case 0x00B0:
	case 177:
	case 0x00B2:
	case 0x00B3:
	case 0x00B4:
	case 181:
	case 0x00B6:
	case 0x00B7:
	case 0x00B8:
	case 0x00B9:
	case 0x00BA:
	case 0x00BB:
	case 188:
	case 0x00BD:
	case 0x00BE:
	case 191:
	case 0x00C0:
	case 0x00C1:
	case 0x00C2:
	case 0x00C3:
	case 0x00C4:
	case 0x00C5:
	case 0x00C6:
	case 199:
	case 200:
	case 0x00C9:
	case 202:
	case 0x00CB:
	case 0x00CC:
	case 0x00CD:
	case 0x00CE:
	case 0x00CF:
	case 0x00D0:
	case 0x00D1:
	case 0x00D2:
	case 211:
	case 212:
	case 0x00D5:
	case 0x00D6:
	case 0x00D7:
	case 0x00D8:
	case 0x00D9:
	case 0x00DA:
	case 0x00DB:
	case 220:
	case 0x00DD:
	case 222:
	case 223:
	case 224:
	case 225:
	case 226:
	case 227:
	case 228:
	case 229:
	case 0x00E6:
	case 0x00E7:
	case 232:
	case 233:
	case 0x00EA:
	case 0x00EB:
	case 0x00EC:
	case 0x00ED:
	case 0x00EE:
	case 0x00EF:
	case 0x00F0:
	case 0x00F1:
	case 242:
	case 0x00F3:
	case 244:
	case 0x00F5:
	case 0x00F6:
	case 0x00F7:
	case 0x00F8:
	case 0x00F9:
	case 0x00FA:
	case 0x00FB:
	case 252:
	case 0x00FD:
	case 0x00FE:
	case 0x00FF:
	case 0x0100:
	case 0x0101:
	case 258:
	case 259:
	case 260:
	case 261:
	case 262:
	case 263:
	case 264:
	case 265:
	case 266:
	case 267:
	case 268:
	case 269:
	case 270:
	case 271:
	case 272:
	case 0x0111:
	case 0x0112:
	case 0x0113:
	case 0x0114:
	case 277:
	case 0x0116:
	case 0x0117:
	case 0x0118:
	case 0x0119:
	case 282:
	case 0x011B:
	case 0x011C:
	case 0x011D:
	case 0x011E:
	case 0x011F:
	case 288:
	case 0x0121:
	case 0x0122:
	case 291:
	case 292:
	case 293:
	case 294:
	case 295:
	case 296:
	case 297:
	case 298:
	case 299:
	case 300:
	case 301:
	case 302:
	case 303:
	case 304:
	case 0x0131:
	case 306:
	case 0x0133:
	case 308:
	case 309:
	case 310:
	case 311:
	case 312:
	case 313:
	case 314:
	case 315:
	case 316:
	case 317:
	case 318:
	case 319:
	case 320:
	case 0x0141:
	case 322:
	case 323:
	case 0x0144:
	case 325:
	case 326:
	case 327:
	case 328:
	case 329:
	case 330:
	case 331:
	case 332:
	case 333:
	case 334:
	case 335:
	case 336:
	case 337:
	case 338:
	case 339:
	case 340:
	case 0x0155:
	case 342:
	case 343:
	case 344:
	case 345:
	case 346:
	case 347:
	case 348:
	case 349:
	case 350:
	case 351:
	case 352:
	case 353:
	case 354:
	case 355:
	case 356:
	case 357:
	case 0x0166:
	case 359:
	case 360:
	case 361:
	case 362:
	case 363:
	case 364:
	case 365:
	case 366:
	case 367:
	case 368:
	case 0x0171:
	case 370:
	case 371:
	case 372:
	case 373:
	case 374:
	case 0x0177:
	case 376:
	case 377:
	case 378:
	case 379:
	case 380:
	case 381:
	case 382:
	case 383:
	case 384:
	case 0x0181:
	case 386:
	case 387:
	case 388:
	case 389:
	case 390:
	case 391:
	case 0x0188:
	case 393:
	case 394:
	case 395:
	case 396:
	case 397:
	case 398:
	case 399:
	case 400:
	case 0x0191:
	case 402:
	case 403:
	case 404:
	case 405:
	case 406:
	case 407:
	case 408:
	case 0x0199:
	case 410:
	case 411:
	case 412:
	case 413:
	case 414:
	case 415:
	case 416:
	case 0x01A1:
	case 418:
	case 419:
	case 420:
	case 421:
	case 422:
	case 423:
	case 424:
	case 425:
	case 0x01AA:
	case 427:
	case 428:
	case 429:
	case 430:
	case 431:
	case 432:
	case 433:
	case 434:
	case 435:
	case 436:
	case 437:
	case 438:
	case 439:
	case 440:
	case 441:
	case 442:
	case 443:
	case 444:
	case 445:
	case 446:
	case 447:
	case 448:
	case 449:
	case 450:
	case 451:
	case 452:
	case 453:
	case 454:
	case 455:
	case 456:
	case 457:
	case 458:
	case 459:
	case 0x01CC:
	case 461:
	case 462:
	case 463:
	case 464:
	case 0x01D1:
	case 466:
	case 467:
	case 468:
	case 469:
	case 470:
	case 471:
	case 472:
	case 473:
	case 474:
	case 475:
	case 476:
	case 477:
	case 478:
	case 479:
	case 480:
	case 0x01E1:
	case 482:
	case 483:
	case 484:
	case 485:
	case 486:
	case 487:
	case 488:
	case 489:
	case 490:
	case 491:
	case 492:
	case 493:
	case 494:
	case 495:
	case 496:
	case 0x01F1:
	case 498:
	case 499:
	case 500:
	case 501:
	case 502:
	case 503:
	case 504:
	case 505:
	case 506:
	case 507:
	case 508:
	case 509:
	case 510:
	case 511:
	case 0x0200:
	case 513:
	case 0x0202:
	case 515:
	case 516:
	case 517:
	case 518:
	case 519:
	case 520:
	case 521:
	case 522:
	case 523:
	case 524:
	case 525:
	case 526:
	case 527:
	case 528:
	case 0x0211:
	case 0x0212:
	case 531:
	case 532:
	case 533:
	case 534:
	case 535:
	case 536:
	case 537:
	case 538:
	case 539:
	case 540:
	case 541:
	case 542:
	case 543:
	case 544:
	case 545:
	case 0x0222:
	case 0x0223:
	case 0x0224:
	case 0x0225:
	case 550:
	case 551:
	case 552:
	case 553:
	case 554:
	case 555:
	case 556:
	case 557:
	case 558:
	case 559:
	case 560:
	case 561:
	case 0x0232:
	case 0x0233:
	case 564:
	case 565:
	case 566:
	case 567:
	case 568:
	case 569:
	case 570:
	case 571:
	case 572:
	case 573:
	case 574:
	case 575:
	case 576:
	case 577:
	case 0x0242:
	case 579:
	case 0x0244:
	case 581:
	case 582:
	case 583:
	case 584:
	case 585:
	case 586:
	case 587:
	case 588:
	case 589:
	case 590:
	case 591:
	case 592:
	case 593:
	case 0x0252:
	case 595:
	case 596:
	case 0x0255:
	case 598:
	case 599:
	case 600:
	case 601:
	case 602:
	case 603:
	case 604:
	case 605:
	case 606:
	case 607:
	case 608:
	case 609:
	case 0x0262:
	case 611:
	case 612:
	case 613:
	case 0x0266:
	case 615:
	case 616:
	case 617:
	case 618:
	case 619:
	case 620:
	case 621:
	case 622:
	case 623:
	case 624:
	case 625:
	case 626:
	case 627:
	case 628:
	case 629:
	case 630:
	case 0x0277:
	case 632:
	case 633:
	case 634:
	case 635:
	case 636:
	case 637:
	case 638:
	case 639:
	case 640:
	case 641:
	case 0x0282:
	case 643:
	case 644:
	case 645:
	case 646:
	case 647:
	case 0x0288:
	case 649:
	case 650:
	case 651:
	case 652:
	case 653:
	case 654:
	case 655:
	case 656:
	case 657:
	case 0x0292:
	case 659:
	case 660:
	case 661:
	case 662:
	case 663:
	case 664:
	case 665:
	case 666:
	case 667:
	case 668:
	case 669:
	case 670:
	case 671:
	case 672:
	case 673:
	case 0x02A2:
	case 675:
	case 676:
	case 677:
	case 678:
	case 679:
	case 680:
	case 681:
	case 0x02AA:
	case 683:
	case 684:
	case 685:
	case 686:
	case 687:
	case 688:
	case 689:
	case 0x02B2:
	case 691:
	case 692:
	case 693:
	case 694:
	case 695:
	case 696:
	case 697:
	case 698:
	case 699:
	case 700:
	case 701:
	case 702:
	case 703:
	case 704:
	case 705:
	case 0x02C2:
	case 707:
	case 708:
	case 709:
	case 710:
	case 711:
	case 712:
	case 713:
	case 714:
	case 715:
	case 0x02CC:
	case 717:
	case 718:
	case 719:
	case 720:
	case 721:
	case 722:
	case 723:
	case 724:
	case 725:
	case 726:
	case 727:
	case 728:
	case 729:
	case 730:
	case 731:
	case 732:
	case 733:
	case 734:
	case 735:
	case 736:
	case 737:
	case 0x02E2:
	case 739:
	case 740:
	case 741:
	case 742:
	case 743:
	case 744:
	case 745:
	case 746:
	case 747:
	case 748:
	case 749:
	case 0x02EE:
	case 751:
	case 752:
	case 753:
	case 0x02F2:
	case 755:
	case 756:
	case 757:
	case 758:
	case 759:
	case 760:
	case 761:
	case 762:
	case 763:
	case 764:
	case 765:
	case 766:
	case 767:
	case 0x0300:
	case 769:
	case 770:
	case 771:
	case 772:
	case 773:
	case 774:
	case 775:
	case 776:
	case 777:
	case 778:
	case 779:
	case 780:
	case 781:
	case 782:
	case 783:
	case 784:
	case 0x0311:
	case 786:
	case 787:
	case 788:
	case 789:
	case 790:
	case 791:
	case 792:
	case 793:
	case 794:
	case 795:
	case 796:
	case 797:
	case 798:
	case 799:
	case 800:
	case 801:
	case 0x0322:
	case 0x0323:
	case 804:
	case 805:
	case 806:
	case 807:
	case 808:
	case 809:
	case 810:
	case 811:
	case 812:
	case 813:
	case 814:
	case 815:
	case 0x0330:
	case 0x0331:
	case 818:
	case 0x0333:
	case 0x0334:
	case 0x0335:
	case 822:
	case 0x0337:
	case 0x0338:
	case 0x0339:
	case 0x033A:
	case 0x033B:
	case 828:
	case 0x033D:
	case 0x033E:
	case 0x033F:
	case 832:
	case 833:
	case 834:
	case 0x0343:
	case 0x0344:
	case 837:
	case 838:
	case 839:
	case 840:
	case 841:
	case 842:
	case 843:
	case 844:
	case 845:
	case 846:
	case 847:
	case 848:
	case 849:
	case 850:
	case 0x0353:
	case 852:
	case 0x0355:
	case 854:
	case 855:
	case 856:
	case 857:
	case 858:
	case 859:
	case 860:
	case 861:
	case 862:
	case 863:
	case 864:
	case 865:
	case 866:
	case 0x0363:
	case 868:
	case 869:
	case 0x0366:
	case 871:
	case 872:
	case 873:
	case 874:
	case 875:
	case 876:
	case 877:
	case 878:
	case 879:
	case 880:
	case 881:
	case 882:
	case 883:
	case 884:
	case 885:
	case 886:
	case 887:
	case 888:
	case 889:
	case 890:
	case 891:
	case 892:
	case 893:
	case 894:
	case 895:
	case 896:
	case 897:
	case 898:
	case 899:
	case 900:
	case 901:
	case 902:
	case 903:
	case 0x0388:
	case 905:
	case 906:
	case 907:
	case 908:
	case 909:
	case 910:
	case 911:
	case 912:
	case 913:
	case 914:
	case 0x0393:
	case 916:
	case 917:
	case 918:
	case 919:
	case 920:
	case 0x0399:
	case 922:
	case 923:
	case 924:
	case 925:
	case 926:
	case 927:
	case 928:
	case 929:
	case 930:
	case 0x03A3:
	case 932:
	case 933:
	case 934:
	case 935:
	case 936:
	case 937:
	case 0x03AA:
	case 939:
	case 940:
	case 941:
	case 942:
	case 943:
	case 944:
	case 945:
	case 946:
	case 0x03B3:
	case 948:
	case 949:
	case 950:
	case 951:
	case 952:
	case 953:
	case 954:
	case 955:
	case 956:
	case 957:
	case 958:
	case 959:
	case 960:
	case 961:
	case 962:
	case 0x03C3:
	case 964:
	case 965:
	case 966:
	case 967:
	case 968:
	case 969:
	case 970:
	case 971:
	case 0x03CC:
	case 973:
	case 974:
	case 975:
	case 976:
	case 977:
	case 978:
	case 979:
	case 980:
	case 981:
	case 982:
	case 983:
	case 984:
	case 985:
	case 986:
	case 987:
	case 988:
	case 989:
	case 990:
	case 991:
	case 992:
	case 993:
	case 994:
	case 995:
	case 996:
	case 997:
	case 998:
	case 999:
	case 1000:
	case 1001:
	case 1002:
	case 1003:
	case 1004:
	case 1005:
	case 0x03EE:
	case 1007:
	case 1008:
	case 1009:
	case 1010:
	case 1011:
	case 1012:
	case 1013:
	case 1014:
	case 1015:
	case 1016:
	case 1017:
	case 1018:
	case 1019:
	case 1020:
	case 1021:
	case 1022:
	case 0x03FF:
	case 0x0400:
	case 0x0401:
	case 0x0402:
	case 0x0403:
	case 0x0404:
	case 0x0405:
	case 1030:
	case 1031:
	case 0x0408:
	case 1033:
	case 0x040A:
	case 0x040B:
	case 0x040C:
	case 0x040D:
	case 0x040E:
	case 0x040F:
	case 1040:
	case 0x0411:
	case 0x0412:
	case 0x0413:
	case 0x0414:
	case 0x0415:
	case 0x0416:
	case 0x0417:
	case 0x0418:
	case 0x0419:
	case 1050:
	case 1051:
	case 0x041C:
	case 0x041D:
	case 0x041E:
	case 1055:
	case 0x0420:
	case 0x0421:
	case 0x0422:
	case 0x0423:
	case 0x0424:
	case 1061:
	case 0x0426:
	case 0x0427:
	case 0x0428:
	case 0x0429:
	case 1066:
	case 0x042B:
	case 0x042C:
	case 0x042D:
	case 1070:
	case 1071:
	case 0x0430:
	case 0x0431:
	case 0x0432:
	case 0x0433:
	case 0x0434:
	case 1077:
	case 0x0436:
	case 0x0437:
	case 1080:
	case 1081:
	case 0x043A:
	case 0x043B:
	case 0x043C:
	case 0x043D:
	case 0x043E:
	case 0x043F:
	case 0x0440:
	case 0x0441:
	case 0x0442:
	case 0x0443:
	case 0x0444:
	case 0x0445:
	case 0x0446:
	case 0x0447:
	case 0x0448:
	case 0x0449:
	case 0x044A:
	case 0x044B:
	case 0x044C:
	case 1101:
	case 0x044E:
	case 0x044F:
	case 1104:
	case 1105:
	case 1106:
	case 1107:
	case 0x0454:
	case 0x0455:
	case 1110:
	case 1111:
	case 1112:
	case 1113:
	case 1114:
	case 1115:
	case 1116:
	case 1117:
	case 1118:
	case 1119:
	case 1120:
	case 1121:
	case 1122:
	case 1123:
	case 0x0464:
	case 1125:
	case 0x0466:
	case 1127:
	case 1128:
	case 1129:
	case 1130:
	case 1131:
	case 1132:
	case 1133:
	case 1134:
	case 1135:
	case 1136:
	case 1137:
	case 1138:
	case 1139:
	case 0x0474:
	case 1141:
	case 1142:
	case 0x0477:
	case 1144:
	case 1145:
	case 1146:
	case 1147:
	case 1148:
	case 1149:
	case 1150:
	case 1151:
	case 1152:
	case 1153:
	case 1154:
	case 1155:
	case 0x0484:
	case 1157:
	case 1158:
	case 1159:
	case 0x0488:
	case 1161:
	case 1162:
	case 1163:
	case 1164:
	case 1165:
	case 1166:
	case 1167:
	case 1168:
	case 1169:
	case 1170:
	case 1171:
	case 0x0494:
	case 1173:
	case 1174:
	case 1175:
	case 1176:
	case 0x0499:
	case 1178:
	case 1179:
	case 1180:
	case 1181:
	case 1182:
	case 1183:
	case 1184:
	case 1185:
	case 1186:
	case 1187:
	case 0x04A4:
	case 1189:
	case 1190:
	case 1191:
	case 1192:
	case 1193:
	case 0x04AA:
	case 1195:
	case 1196:
	case 1197:
	case 1198:
	case 1199:
	case 1200:
	case 1201:
	case 1202:
	case 0x04B3:
	case 0x04B4:
	case 0x04B5:
	case 0x04B6:
	case 0x04B7:
	case 0x04B8:
	case 0x04B9:
	case 1210:
	case 1211:
	case 1212:
	case 1213:
	case 1214:
	case 1215:
	case 1216:
	case 1217:
	case 1218:
	case 1219:
	case 0x04C4:
	case 1221:
	case 1222:
	case 1223:
	case 1224:
	case 1225:
	case 1226:
	case 1227:
	case 0x04CC:
	case 1229:
	case 0x04CE:
	case 1231:
	case 1232:
	case 1233:
	case 0x04D2:
	case 0x04D3:
	case 0x04D4:
	case 0x04D5:
	case 0x04D6:
	case 0x04D7:
	case 0x04D8:
	case 1241:
	case 1242:
	case 0x04DB:
	case 1244:
	case 0x04DD:
	case 0x04DE:
	case 0x04DF:
	case 0x04E0:
	case 0x04E1:
	case 0x04E2:
	case 1251:
	case 0x04E4:
	case 0x04E5:
	case 0x04E6:
	case 1255:
	case 0x04E8:
	case 0x04E9:
	case 0x04EA:
	case 0x04EB:
	case 0x04EC:
	case 1261:
	case 0x04EE:
	case 0x04EF:
	case 0x04F0:
	case 0x04F1:
	case 1266:
	case 0x04F3:
	case 0x04F4:
	case 0x04F5:
	case 0x04F6:
	case 1271:
	case 1272:
	case 0x04F9:
	case 0x04FA:
	case 0x04FB:
	case 0x04FC:
	case 1277:
	case 0x04FE:
	case 0x04FF:
	case 0x0500:
	case 1281:
	case 1282:
	case 0x0503:
	case 0x0504:
	case 0x0505:
	case 0x0506:
	case 0x0507:
	case 1288:
	case 0x0509:
	case 0x050A:
	case 1291:
	case 1292:
	case 0x050D:
	case 0x050E:
	case 0x050F:
	case 0x0510:
	case 0x0511:
	case 0x0512:
	case 1299:
	case 1300:
	case 0x0515:
	case 0x0516:
	case 1303:
	case 0x0518:
	case 0x0519:
	case 0x051A:
	case 0x051B:
	case 0x051C:
	case 0x051D:
	case 1310:
	case 1311:
	case 1312:
	case 1313:
	case 0x0522:
	case 1315:
	case 1316:
	case 0x0525:
	case 1318:
	case 1319:
	case 0x0528:
	case 1321:
	case 1322:
	case 1323:
	case 0x052C:
	case 0x052D:
	case 0x052E:
	case 0x052F:
	case 0x0530:
	case 0x0531:
	case 1330:
	case 0x0533:
	case 1332:
	case 1333:
	case 1334:
	case 1335:
	case 1336:
	case 1337:
	case 1338:
	case 1339:
	case 0x053C:
	case 1341:
	case 0x053E:
	case 1343:
	case 1344:
	case 0x0541:
	case 0x0542:
	case 0x0543:
	case 0x0544:
	case 0x0545:
	case 0x0546:
	case 1351:
	case 0x0548:
	case 1353:
	case 0x054A:
	case 1355:
	case 0x054C:
	case 0x054D:
	case 0x054E:
	case 0x054F:
	case 0x0550:
	case 0x0551:
	case 0x0552:
	case 0x0553:
	case 0x0554:
	case 0x0555:
	case 0x0556:
	case 0x0557:
	case 0x0558:
	case 0x0559:
	case 0x055A:
	case 0x055B:
	case 0x055C:
	case 0x055D:
	case 0x055E:
	case 0x055F:
	case 0x0560:
	case 1377:
	case 0x0562:
	case 0x0563:
	case 0x0564:
	case 0x0565:
	case 0x0566:
	case 1383:
	case 0x0568:
	case 0x0569:
	case 0x056A:
	case 0x056B:
	case 1388:
	case 0x056D:
	case 0x056E:
	case 1391:
	case 0x0570:
	case 1393:
	case 0x0572:
	case 0x0573:
	case 0x0574:
	case 0x0575:
	case 0x0576:
	case 0x0577:
	case 1400:
	case 1401:
	case 0x057A:
	case 0x057B:
	case 1404:
	case 0x057D:
	case 0x057E:
	case 0x057F:
	case 0x0580:
	case 0x0581:
	case 1410:
	case 1411:
	case 1412:
	case 0x0585:
	case 1414:
	case 1415:
	case 0x0588:
	case 1417:
	case 1418:
	case 1419:
	case 0x058C:
	case 1421:
	case 1422:
	case 0x058F:
	case 1424:
	case 0x0591:
	case 0x0592:
	case 0x0593:
	case 0x0594:
	case 0x0595:
	case 0x0596:
	case 1431:
	case 0x0598:
	case 0x0599:
	case 1434:
	case 0x059B:
	case 0x059C:
	case 0x059D:
	case 0x059E:
	case 0x059F:
	case 1440:
	case 1441:
	case 1442:
	case 1443:
	case 1444:
	case 0x05A5:
	case 1446:
	case 1447:
	case 1448:
	case 1449:
	case 0x05AA:
	case 1451:
	case 0x05AC:
	case 0x05AD:
	case 1454:
	case 1455:
	case 0x05B0:
	case 0x05B1:
	case 0x05B2:
	case 0x05B3:
	case 0x05B4:
	case 0x05B5:
	case 0x05B6:
	case 0x05B7:
	case 1464:
	case 0x05B9:
	case 1466:
	case 0x05BB:
	case 0x05BC:
	case 0x05BD:
	case 0x05BE:
	case 1471:
	case 0x05C0:
	case 0x05C1:
	case 1474:
	case 0x05C3:
	case 0x05C4:
	case 0x05C5:
	case 0x05C6:
	case 0x05C7:
	case 0x05C8:
	case 1481:
	case 0x05CA:
	case 0x05CB:
	case 0x05CC:
	case 0x05CD:
	case 0x05CE:
	case 0x05CF:
	case 1488:
	case 0x05D1:
	case 0x05D2:
	case 1491:
	case 0x05D4:
	case 0x05D5:
	case 1494:
	case 0x05D7:
	case 0x05D8:
	case 0x05D9:
	case 0x05DA:
	case 1499:
	case 1500:
	case 0x05DD:
	case 0x05DE:
	case 0x05DF:
	case 0x05E0:
	case 1505:
	case 0x05E2:
	case 0x05E3:
	case 0x05E4:
	case 0x05E5:
	case 1510:
	case 1511:
	case 1512:
	case 1513:
	case 1514:
	case 1515:
	case 1516:
	case 1517:
	case 0x05EE:
	case 1519:
	case 0x05F0:
	case 1521:
	case 1522:
	case 0x05F3:
	case 0x05F4:
	case 0x05F5:
	case 0x05F6:
	case 0x05F7:
	case 0x05F8:
	case 0x05F9:
	case 0x05FA:
	case 1531:
	case 0x05FC:
	case 1533:
	case 0x05FE:
	case 0x05FF:
	case 0x0600:
	case 0x0601:
	case 0x0602:
	case 0x0603:
	case 0x0604:
	case 1541:
	case 0x0606:
	case 0x0607:
	case 1544:
	case 1545:
	case 0x060A:
	case 0x060B:
	case 0x060C:
	case 0x060D:
	case 1550:
	case 1551:
	case 1552:
	case 0x0611:
	case 1554:
	case 1555:
	case 1556:
	case 1557:
	case 0x0616:
	case 1559:
	case 0x0618:
	case 1561:
	case 0x061A:
	case 0x061B:
	case 0x061C:
	case 1565:
	case 1566:
	case 0x061F:
	case 0x0620:
	case 0x0621:
	case 0x0622:
	case 1571:
	case 0x0624:
	case 0x0625:
	case 0x0626:
	case 1575:
	case 0x0628:
	case 1577:
	case 0x062A:
	case 0x062B:
	case 0x062C:
	case 1581:
	case 0x062E:
	case 0x062F:
	case 0x0630:
	case 1585:
	case 0x0632:
	case 0x0633:
	case 1588:
	case 0x0635:
	case 0x0636:
	case 1591:
	case 0x0638:
	case 0x0639:
	case 0x063A:
	case 1595:
	case 0x063C:
	case 0x063D:
	case 0x063E:
	case 1599:
	case 1600:
	case 1601:
	case 0x0642:
	case 0x0643:
	case 0x0644:
	case 0x0645:
	case 0x0646:
	case 0x0647:
	case 0x0648:
	case 0x0649:
	case 1610:
	case 1611:
	case 1612:
	case 1613:
	case 1614:
	case 1615:
	case 1616:
	case 1617:
	case 1618:
	case 1619:
	case 0x0654:
	case 0x0655:
	case 0x0656:
	case 0x0657:
	case 0x0658:
	case 0x0659:
	case 1626:
	case 0x065B:
	case 0x065C:
	case 0x065D:
	case 0x065E:
	case 1631:
	case 0x0660:
	case 0x0661:
	case 0x0662:
	case 0x0663:
	case 0x0664:
	case 0x0665:
	case 0x0666:
	case 0x0667:
	case 0x0668:
	case 0x0669:
	case 0x066A:
	case 0x066B:
	case 0x066C:
	case 0x066D:
	case 0x066E:
	case 0x066F:
	case 0x0670:
	case 0x0671:
	case 0x0672:
	case 1651:
	case 0x0674:
	case 0x0675:
	case 0x0676:
	case 0x0677:
	case 1656:
	case 0x0679:
	case 0x067A:
	case 0x067B:
	case 1660:
	case 1661:
	case 1662:
	case 1663:
	case 1664:
	case 1665:
	case 1666:
	case 1667:
	case 1668:
	case 1669:
	case 0x0686:
	case 1671:
	case 0x0688:
	case 0x0689:
	case 0x068A:
	case 0x068B:
	case 1676:
	case 1677:
	case 0x068E:
	case 0x068F:
	case 0x0690:
	case 1681:
	case 0x0692:
	case 0x0693:
	case 0x0694:
	case 0x0695:
	case 0x0696:
	case 0x0697:
	case 1688:
	case 0x0699:
	case 0x069A:
	case 1691:
	case 0x069C:
	case 0x069D:
	case 0x069E:
	case 0x069F:
	case 1696:
	case 0x06A1:
	case 0x06A2:
	case 1699:
	case 1700:
	case 1701:
	case 0x06A6:
	case 0x06A7:
	case 0x06A8:
	case 0x06A9:
	case 0x06AA:
	case 1707:
	case 0x06AC:
	case 0x06AD:
	case 1710:
	case 1711:
	case 1712:
	case 1713:
	case 1714:
	case 1715:
	case 1716:
	case 1717:
	case 0x06B6:
	case 1719:
	case 0x06B8:
	case 1721:
	case 1722:
	case 0x06BB:
	case 0x06BC:
	case 0x06BD:
	case 0x06BE:
	case 1727:
	case 0x06C0:
	case 0x06C1:
	case 0x06C2:
	case 1731:
	case 0x06C4:
	case 1733:
	case 0x06C6:
	case 0x06C7:
	case 0x06C8:
	case 1737:
	case 0x06CA:
	case 0x06CB:
	case 0x06CC:
	case 1741:
	case 0x06CE:
	case 0x06CF:
	case 1744:
	case 0x06D1:
	case 0x06D2:
	case 1747:
	case 0x06D4:
	case 0x06D5:
	case 0x06D6:
	case 1751:
	case 0x06D8:
	case 0x06D9:
	case 0x06DA:
	case 1755:
	case 0x06DC:
	case 0x06DD:
	case 0x06DE:
	case 0x06DF:
	case 0x06E0:
	case 1761:
	case 0x06E2:
	case 0x06E3:
	case 0x06E4:
	case 0x06E5:
	case 0x06E6:
	case 1767:
	case 0x06E8:
	case 0x06E9:
	case 1770:
	case 1771:
	case 1772:
	case 1773:
	case 0x06EE:
	case 1775:
	case 1776:
	case 1777:
	case 1778:
	case 1779:
	case 0x06F4:
	case 1781:
	case 0x06F6:
	case 0x06F7:
	case 0x06F8:
	case 0x06F9:
	case 0x06FA:
	case 1787:
	case 1788:
	case 0x06FD:
	case 0x06FE:
	case 0x06FF:
	case 0x0700:
	case 0x0701:
	case 0x0702:
	case 0x0703:
	case 0x0704:
	case 1797:
	case 0x0706:
	case 0x0707:
	case 1800:
	case 1801:
	case 0x070A:
	case 0x070B:
	case 0x070C:
	case 0x070D:
	case 0x070E:
	case 0x070F:
	case 1808:
	case 0x0711:
	case 1810:
	case 1811:
	case 1812:
	case 1813:
	case 1814:
	case 0x0717:
	case 1816:
	case 1817:
	case 1818:
	case 1819:
	case 0x071C:
	case 1821:
	case 1822:
	case 0x071F:
	case 0x0720:
	case 0x0721:
	case 0x0722:
	case 0x0723:
	case 1828:
	case 0x0725:
	case 0x0726:
	case 0x0727:
	case 0x0728:
	case 1833:
	case 0x072A:
	case 0x072B:
	case 0x072C:
	case 0x072D:
	case 1838:
	case 0x072F:
	case 0x0730:
	case 1841:
	case 0x0732:
	case 0x0733:
	case 1844:
	case 0x0735:
	case 0x0736:
	case 0x0737:
	case 1848:
	case 0x0739:
	case 0x073A:
	case 1851:
	case 0x073C:
	case 0x073D:
	case 0x073E:
	case 1855:
	case 0x0740:
	case 0x0741:
	case 1858:
	case 0x0743:
	case 0x0744:
	case 1861:
	case 0x0746:
	case 0x0747:
	case 0x0748:
	case 0x0749:
	case 1866:
	case 0x074B:
	case 1868:
	case 0x074D:
	case 0x074E:
	case 1871:
	case 0x0750:
	case 0x0751:
	case 0x0752:
	case 0x0753:
	case 0x0754:
	case 0x0755:
	case 1878:
	case 0x0757:
	case 1880:
	case 1881:
	case 1882:
	case 1883:
	case 1884:
	case 1885:
	case 1886:
	case 1887:
	case 1888:
	case 1889:
	case 0x0762:
	case 1891:
	case 0x0764:
	case 0x0765:
	case 0x0766:
	case 0x0767:
	case 0x0768:
	case 0x0769:
	case 1898:
	case 1899:
	case 1900:
	case 1901:
	case 0x076E:
	case 0x076F:
	case 0x0770:
	case 0x0771:
	case 0x0772:
	case 0x0773:
	case 0x0774:
	case 0x0775:
	case 0x0776:
	case 0x0777:
	case 0x0778:
	case 0x0779:
	case 0x077A:
	case 0x077B:
	case 0x077C:
	case 0x077D:
	case 0x077E:
	case 0x077F:
	case 0x0780:
	case 1921:
	case 1922:
	case 0x0783:
	case 0x0784:
	case 0x0785:
	case 0x0786:
	case 0x0787:
	case 0x0788:
	case 1929:
	case 0x078A:
	case 1931:
	case 0x078C:
	case 1933:
	case 0x078E:
	case 0x078F:
	case 0x0790:
	case 0x0791:
	case 0x0792:
	case 1939:
	case 0x0794:
	case 1941:
	case 0x0796:
	case 0x0797:
	case 1944:
	case 0x0799:
	case 0x079A:
	case 0x079B:
	case 0x079C:
	case 1949:
	case 0x079E:
	case 1951:
	case 0x07A0:
	case 0x07A1:
	case 0x07A2:
	case 1955:
	case 0x07A4:
	case 0x07A5:
	case 0x07A6:
	case 0x07A7:
	case 0x07A8:
	case 1961:
	case 0x07AA:
	case 0x07AB:
	case 0x07AC:
	case 0x07AD:
	case 1966:
	case 0x07AF:
	case 0x07B0:
	case 1969:
	case 0x07B2:
	case 1971:
	case 0x07B4:
	case 0x07B5:
	case 0x07B6:
	case 0x07B7:
	case 0x07B8:
	case 1977:
	case 0x07BA:
	case 0x07BB:
	case 0x07BC:
	case 1981:
	case 0x07BE:
	case 0x07BF:
	case 0x07C0:
	case 0x07C1:
	case 0x07C2:
	case 0x07C3:
	case 1988:
	case 1989:
	case 1990:
	case 0x07C7:
	case 1992:
	case 1993:
	case 1994:
	case 1995:
	case 0x07CC:
	case 1997:
	case 1998:
	case 1999:
	case 2000:
	case 2001:
	case 2002:
	case 2003:
	case 2004:
	case 2005:
	case 2006:
	case 0x07D7:
	case 2008:
	case 2009:
	case 2010:
	case 2011:
	case 2012:
	case 0x07DD:
	case 0x07DE:
	case 0x07DF:
	case 0x07E0:
	case 0x07E1:
	case 0x07E2:
	case 0x07E3:
	case 2020:
	case 2021:
	case 2022:
	case 0x07E7:
	case 2024:
	case 2025:
	case 2026:
	case 2027:
	case 2028:
	case 2029:
	case 0x07EE:
	case 0x07EF:
	case 2032:
	case 2033:
	case 0x07F2:
	case 0x07F3:
	case 0x07F4:
	case 0x07F5:
	case 0x07F6:
	case 0x07F7:
	case 2040:
	case 0x07F9:
	case 2042:
	case 0x07FB:
	case 2044:
	case 0x07FD:
	case 0x07FE:
	case 0x07FF:
		arg1.u1->t0000.u0 = (v25_n >> 0x34 & 0x07FF) + ~0x03FD;
		break;
	}
	return <invalid>;
}

// 000D779F: Stack Eq_n fn000D779F(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000D6E73
//      fn000DE31D
//      fn000DE5D1
Eq_n fn000D779F(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	if (arg0 != 0x00)
	{
		if (arg1 < 0x80)
			*arg0.u2 = (int8) (byte) arg1;
		else if (arg1 < 0x0800)
		{
			*arg0.u2 = (int8) ((byte) (arg1 >> 0x06) | 0xC0);
			arg0.u14[1] = (struct Eq_n) ((byte) arg1 & 0x3F | 0x80);
		}
		else if (arg1 < 0xD800 | (arg1 & ~0x1FFF) == 0xE000)
		{
			*arg0.u2 = (int8) ((byte) (arg1 >> 0x0C) | 0xE0);
			arg0.u14[1] = (struct Eq_n) ((byte) (arg1 >> 0x06) & 0x3F | 0x80);
			arg0.u14[2] = (struct Eq_n) ((byte) arg1 & 0x3F | 0x80);
		}
		else if (arg1 < 0x00110000)
		{
			*arg0.u2 = (int8) ((byte) (arg1 >> 0x12) | 0xF0);
			arg0.u14[1] = (struct Eq_n) ((byte) (arg1 >> 0x0C) & 0x3F | 0x80);
			arg0.u14[2] = (struct Eq_n) ((byte) (arg1 >> 0x06) & 0x3F | 0x80);
			arg0.u14[3] = (struct Eq_n) ((byte) arg1 & 0x3F | 0x80);
		}
		else
			*___errno_location().u3 = 0x54;
	}
	return <invalid>;
}

// 000D799D: Stack Eq_n fn000D799D(Stack Eq_n arg0)
// Called from:
//      fn000D61FC
//      fn000DE8FC
Eq_n fn000D799D(Eq_n arg0)
{
	int32 v27_n = (int32) arg0.u14[74];
	arg0.u14[74] = (struct Eq_n) ((byte) v27_n + ~0x00 | (byte) v27_n);
	Eq_n v27_n;
	v27_n.u2 = *arg0.u3;
	if ((v27_n & 0x08) == 0x00)
	{
		arg0.u15[4] = (struct Eq_n) 0x00;
		arg0.u15[2] = (struct Eq_n) 0x00;
		Eq_n v27_n;
		v27_n.u2 = arg0.u15[22];
		arg0.u18->dw001C = (ui32) v27_n;
		arg0.u15[0x0A] = (struct Eq_n) v27_n;
		arg0.u17[4] = (struct Eq_n) (v27_n + (arg0.u15)[24]);
	}
	else
		*arg0.u3 = (int32) (v27_n | 0x20);
	return <invalid>;
}

// 000D7A7D: Stack Eq_n fn000D7A7D(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
Eq_n fn000D7A7D(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v15_n;
	v15_n.u2 = arg0.u15[0x0A];
	Eq_n v15_n = arg0.u17[4] - v15_n;
	Eq_n v15_n;
	if (v15_n > arg2)
		v15_n = arg2;
	else
		v15_n = v15_n;
	_memcpy(v15_n, arg1, v15_n);
	arg0.u15[0x0A] = (struct Eq_n) (arg0.u15[0x0A] + v15_n);
	return <invalid>;
}

// 000D7AE1: Stack Eq_n fn000D7AE1()
Eq_n fn000D7AE1()
{
	return <invalid>;
}

// 000D7AED: Stack Eq_n fn000D7AED()
Eq_n fn000D7AED()
{
	return <invalid>;
}

// 000D7AF9: Stack Eq_n fn000D7AF9()
Eq_n fn000D7AF9()
{
	return <invalid>;
}

// 000D7B05: Stack Eq_n fn000D7B05(Stack Eq_n arg0)
// Called from:
//      fn00119977
//      fn001199A5
//      fn0011CD9A
Eq_n fn000D7B05(Eq_n arg0)
{
	Eq_n loc1_n = arg0;
	while (true)
	{
		Eq_n v13_n;
		v13_n.u15 = loc1_n.u15 + 2;
		if (*loc1_n.u3 == null)
			break;
		loc1_n = v13_n;
	}
	return <invalid>;
}

// 000D7B53: Stack Eq_n fn000D7B53(Stack Eq_n arg0)
// Called from:
//      fn000DB316
Eq_n fn000D7B53(Eq_n arg0)
{
	return <invalid>;
}

// 000D7B90: Stack Eq_n fn000D7B90(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000DBA9B
//      fn000DEF2C
Eq_n fn000D7B90(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n loc22;
	Eq_n loc284;
	Eq_n loc24;
	Eq_n loc23;
	Eq_n loc740;
	Eq_n loc719;
	Eq_n loc77;
	word32 loc19;
	int64 loc666;
	word32 loc20;
	real64 loc720;
	real64 loc721;
	Eq_n loc21;
	word32 loc81;
	int64 loc679;
	int64 loc678;
	word32 loc60;
	word32 loc82;
	real64 loc730;
	real64 loc731;
	Eq_n loc83;
	int64 loc683;
	word32 loc96;
	int32 loc67;
	Eq_n loc78;
	word32 loc49;
	Eq_n loc681;
	word32 loc91;
	Eq_n loc592;
	int32 loc34;
	int32 loc39;
	Eq_n loc54;
	Eq_n loc673;
	Eq_n loc687;
	Eq_n loc593;
	int32 loc33;
	int32 loc38;
	Eq_n loc53;
	Eq_n loc672;
	Eq_n loc688;
	Eq_n loc689;
	Eq_n loc671;
	int32 loc32;
	int32 loc37;
	Eq_n loc52;
	word32 loc74;
	Eq_n loc684;
	Eq_n loc670;
	word32 loc104;
	Eq_n loc94;
	int32 loc31;
	int32 loc36;
	Eq_n loc51;
	Eq_n v820_n;
	v820_n.u2 = g_t140030.u2;
	g_t140030.u2 += 0x0200;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x0200);
	word32 loc12_n;
	Eq_n loc13_n;
	switch (arg1)
	{
	case 0x00:
		loc12_n = ~0x94;
		loc13_n.u0 = 0x18;
		break;
	case 0x01:
		loc12_n = 4294966222;
		loc13_n.u0 = 0x35;
		break;
	case 0x02:
		loc12_n = 4294966222;
		loc13_n.u0 = 0x35;
		break;
	}
	Mem5976 = Mem9;
	if (false)
	{
l000DA619:
		goto l000DA619;
	}
	Eq_n loc176_n;
	do
	{
		Eq_n v820_n;
		v820_n.u2 = arg0.u15[2];
		if (v820_n < (arg0.u15)[50])
		{
			arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
			loc176_n = (word32) *v820_n.u2 & 0xFF;
		}
		else
			loc176_n = fn000D2493(arg0);
	} while (fn000D2665(loc176_n) != 0x00);
	Eq_n v822_n = loc176_n == 0x2D;
	Eq_n loc10_n;
	int32 loc16_n;
	switch (loc176_n)
	{
	case 0x2B:
		goto l000D7CC9;
	case 44:
l000D7CC9:
		Eq_n v820_n;
		v820_n.u2 = arg0.u15[2];
		int32 v820_n = 0x01 - ((v822_n & 0x01) << 0x01);
		if (v820_n < (arg0.u15)[50])
		{
			arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
			loc10_n = (word32) *v820_n.u2 & 0xFF;
			loc16_n = v820_n;
		}
		else
		{
			loc10_n = fn000D2493(arg0);
			loc16_n = v820_n;
		}
		break;
	case 0x2D:
		Mem5984 = Mem136;
		loc16_n = 0x01;
		loc10_n = loc176_n;
		break;
	}
	struct Eq_n * loc15_n = null;
	Eq_n loc63_n = loc10_n;
	struct Eq_n * loc14_n;
	Eq_n loc56_n;
	while ((loc63_n | 0x20) == (int32) loc15_n[0x000034D9] != 0x00)
	{
		bool v822_n = loc15_n < &g_t0007;
		Eq_n loc76_n;
		if (v822_n)
		{
			Eq_n v820_n;
			v820_n.u2 = arg0.u15[2];
			if (v820_n < (arg0.u15)[50])
			{
				arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
				loc76_n = (word32) *v820_n.u2 & 0xFF;
			}
			else
				loc76_n = fn000D2493(arg0);
		}
		else
		{
			Mem5697 = Mem194;
			loc76_n = loc63_n;
		}
		struct Eq_n * v820_n = loc15_n + 1;
		if (v820_n >= &g_t0008)
		{
			loc14_n = v820_n;
			loc56_n = loc76_n;
			goto l000D7E4F;
		}
		loc15_n = v820_n;
		loc63_n = loc76_n;
	}
	loc14_n = loc15_n;
	loc56_n = loc63_n;
l000D7E4F:
	word32 loc662_n = 0x04;
	switch (loc14_n)
	{
	case 0x03:
		goto l000DA54F;
	case 0x04:
		loc662_n = 0x17;
l000DA550:
		Mem5692 = Mem5695;
		if (loc662_n == 0x17)
		{
			Eq_n v820_n;
			v820_n.u2 = arg0.u15[50];
			if (v820_n == 0x00 == 0x00)
				arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
			if (arg2 != 0x00 & loc14_n > &g_t0003)
			{
				struct Eq_n * loc59_n = loc14_n;
				while (true)
				{
					if (v820_n == 0x00 == 0x00)
						arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
					struct Eq_n * v820_n = (struct Eq_n *) ((char *) loc59_n - 1);
					if (v820_n <= &g_t0003)
						break;
					loc59_n = v820_n;
				}
			}
		}
		goto l000DA619;
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x08:
		loc662_n = 0x04;
		if (arg2 != 0x00 & loc14_n > &g_t0003)
		{
			if (loc14_n != &g_t0008)
				loc662_n = 0x17;
			goto l000DA550;
		}
		Mem5399 = Mem5695;
		bool v822_n = loc14_n == null;
		struct Eq_n * loc95_n;
		Eq_n loc123_n;
		if (v822_n)
		{
			struct Eq_n * loc80_n = null;
			Eq_n loc97_n = loc56_n;
			while ((loc97_n | 0x20) == (int32) loc80_n[13538] != 0x00)
			{
				bool v822_n = loc80_n < &g_t0002;
				Eq_n loc107_n;
				if (v822_n)
				{
					Eq_n v820_n;
					v820_n.u2 = arg0.u15[2];
					if (v820_n < (arg0.u15)[50])
					{
						arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
						loc107_n = (word32) *v820_n.u2 & 0xFF;
					}
					else
						loc107_n = fn000D2493(arg0);
				}
				else
				{
					Mem5401 = Mem323;
					loc107_n = loc97_n;
				}
				struct Eq_n * v820_n = loc80_n + 1;
				if (v820_n >= &g_t0003)
				{
					loc95_n = v820_n;
					loc123_n = loc107_n;
					goto l000D7FBB;
				}
				loc80_n = v820_n;
				loc97_n = loc107_n;
			}
			loc95_n = loc80_n;
			loc123_n = loc97_n;
		}
		else
		{
			loc95_n = loc14_n;
			loc123_n = loc56_n;
l000D7FBB:
		}
		switch (loc95_n)
		{
		case 0x00:
			Eq_n v820_n;
			v820_n.u2 = arg0.u15[2];
			Eq_n loc616_n;
			if (v820_n < (arg0.u15)[50])
			{
				arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
				loc616_n = (word32) *v820_n.u2 & 0xFF;
			}
			else
				loc616_n = fn000D2493(arg0);
			if (loc616_n == 0x28)
			{
				word32 loc109_n = 0x01;
				Eq_n loc630_n;
				while (true)
				{
					Eq_n v820_n;
					v820_n.u2 = arg0.u15[2];
					if (v820_n < (arg0.u15)[50])
					{
						arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
						loc630_n = (word32) *v820_n.u2 & 0xFF;
					}
					else
						loc630_n = fn000D2493(arg0);
					if ((loc630_n < 0x3A | loc630_n < 0x5B) == 0x00 && (loc630_n == 0x5F | loc630_n < 0x7B) == 0x00)
						break;
					++loc109_n;
				}
				if (loc630_n != 0x29)
				{
					Eq_n v820_n;
					v820_n.u2 = arg0.u15[50];
					if (v820_n == 0x00 == 0x00)
						arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
					if (arg2 != 0x00 == 0x00)
					{
						*___errno_location().u3 = 22;
						fn000D1767(arg0, 0x00);
					}
					else if (loc109_n != 0x00)
					{
						word32 loc135_n = loc109_n;
						while (true)
						{
							word32 v820_n = loc135_n + ~0x00;
							if (v820_n == 0x00 == 0x00)
								arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
							if (v820_n == 0x00)
								break;
							loc135_n = v820_n;
						}
					}
				}
			}
			else if (arg0.u15[50] != 0x00)
				arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
			goto l000DA619;
		case 0x01:
			Mem455 = Mem5397;
			bool v822_n = loc123_n == 0x30;
			Eq_n loc130_n;
			if (!v822_n)
			{
				loc130_n = loc123_n;
				goto l000D8DEC;
			}
			Eq_n v820_n;
			v820_n.u2 = arg0.u15[2];
			Eq_n loc173_n;
			if (v820_n < (arg0.u15)[50])
			{
				arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
				loc173_n = (word32) *v820_n.u2 & 0xFF;
			}
			else
				loc173_n = fn000D2493(arg0);
			if ((loc173_n | 0x20) == 0x78 == 0x00)
			{
				if (arg0.u15[50] == 0x00)
					loc130_n.u0 = 0x30;
				else
				{
					arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
					loc130_n.u0 = 0x30;
				}
l000D8DEC:
				int32 v820_n = (word32) loc13_n + loc12_n;
				int32 v820_n = 0x00 - v820_n;
				Eq_n loc25_n = loc130_n;
				word32 loc50_n = 0x00;
l000D8E09:
				Eq_n loc51_n = loc51;
				int32 loc36_n = loc36;
				int32 loc31_n = loc31;
				Eq_n loc94_n = loc94;
				word32 loc104_n = loc104;
				Eq_n loc670_n = loc670;
				Eq_n loc684_n = loc684;
				word32 loc74_n = loc74;
				Eq_n loc52_n = loc52;
				int32 loc37_n = loc37;
				int32 loc32_n = loc32;
				Eq_n loc671_n = loc671;
				Eq_n loc689_n = loc689;
				Eq_n loc688_n = loc688;
				Eq_n loc672_n = loc672;
				Eq_n loc53_n = loc53;
				int32 loc38_n = loc38;
				int32 loc33_n = loc33;
				Eq_n loc593_n = loc593;
				Eq_n loc687_n = loc687;
				Eq_n loc673_n = loc673;
				Eq_n loc54_n = loc54;
				int32 loc39_n = loc39;
				int32 loc34_n = loc34;
				Eq_n loc592_n = loc592;
				word32 loc91_n = loc91;
				Eq_n loc681_n = loc681;
				word32 loc49_n = loc49;
				Eq_n loc78_n = loc78;
				word32 loc662_n = 0x04;
				switch (loc25_n)
				{
				case 0x2E:
					loc662_n = 0x8A;
					break;
				case 0x2F:
					Mem1923 = Mem1973;
					Eq_n v820_n;
					v820_n.u2 = arg0.u15[2];
					if (v820_n < (arg0.u15)[50])
					{
						arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
						loc25_n = (word32) *v820_n.u2 & 0xFF;
						loc50_n = 0x01;
					}
					else
					{
						loc25_n = fn000D2493(arg0);
						loc50_n = 0x01;
					}
					goto l000D8E09;
				case 0x30:
					loc49_n = 0x00;
					loc681_n.u0 = 0x00;
					loc78_n = loc25_n;
					loc91_n = loc50_n;
					break;
				}
				if (loc662_n == 0x8A)
				{
					Eq_n v820_n;
					v820_n.u2 = arg0.u15[2];
					Eq_n loc65_n;
					if (v820_n < (arg0.u15)[50])
					{
						arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
						loc65_n = (word32) *v820_n.u2 & 0xFF;
					}
					else
						loc65_n = fn000D2493(arg0);
					if (loc65_n == 0x30)
					{
						Eq_n loc675_n;
						loc675_n.u0 = 0x00;
						Eq_n v834_n;
						Eq_n loc64_n;
						while (true)
						{
							Eq_n v820_n;
							v820_n.u2 = arg0.u15[2];
							v834_n = (word32) loc675_n - 1;
							if (v820_n < (arg0.u15)[50])
							{
								arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
								loc64_n = (word32) *v820_n.u2 & 0xFF;
							}
							else
								loc64_n = fn000D2493(arg0);
							if (loc64_n != 0x30)
								break;
							loc675_n = v834_n;
						}
						loc681_n = v834_n;
						loc78_n = loc64_n;
						loc91_n = 0x01;
					}
					else
					{
						loc681_n.u0 = 0x00;
						loc78_n = loc65_n;
						loc91_n = loc50_n;
					}
					loc49_n = 0x01;
				}
				*v820_n.u3 = (int32) 0x00;
				uint32 v820_n = (word32) loc78_n - 48;
				Eq_n v822_n = loc78_n == 0x2E;
				ui32 v820_n = v822_n | v820_n < 0x0A;
				word32 loc662_n;
				if (v820_n)
				{
					int32 loc35_n = 0x00;
					int32 loc40_n = 0x00;
					Eq_n loc55_n;
					loc55_n.u0 = 0x00;
					Eq_n loc674_n;
					loc674_n.u0 = 0x00;
					word32 loc75_n = loc49_n;
					Eq_n loc685_n = loc681_n;
					word32 loc105_n = loc91_n;
					Eq_n loc106_n = loc78_n;
					Eq_n loc588_n = v822_n;
					uint32 loc589_n = v820_n;
l000D9038:
					Eq_n loc680_n;
					int32 loc84_n;
					int32 loc85_n;
					word32 loc90_n;
					Eq_n loc92_n;
					Eq_n loc686_n;
					word32 loc121_n;
					if (!loc588_n)
					{
						Eq_n v834_n = (word32) loc674_n + 1;
						Eq_n v822_n = loc106_n != 0x30;
						if (loc40_n < 0x7D == 0x00)
						{
							if (v822_n == 0x00)
							{
								loc680_n = v834_n;
								loc84_n = loc35_n;
								loc85_n = loc40_n;
								loc90_n = loc75_n;
								loc92_n = loc55_n;
								loc686_n = loc685_n;
								loc121_n = loc105_n;
							}
							else
							{
								v820_n.u14[496] = (struct Eq_n) (v820_n.u14[496] | 0x01);
								loc680_n = v834_n;
								loc84_n = loc35_n;
								loc85_n = loc40_n;
								loc90_n = loc75_n;
								loc92_n = loc55_n;
								loc686_n = loc685_n;
								loc121_n = loc105_n;
							}
l000D91B4:
							Eq_n v820_n;
							v820_n.u2 = arg0.u15[2];
							Eq_n loc93_n;
							if (v820_n < (arg0.u15)[50])
							{
								arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
								loc93_n = (word32) *v820_n.u2 & 0xFF;
							}
							else
								loc93_n = fn000D2493(arg0);
							uint32 v820_n = (word32) loc93_n - 48;
							Eq_n v822_n = loc93_n == 0x2E;
							if (v822_n | v820_n < 0x0A)
							{
								loc35_n = loc84_n;
								loc40_n = loc85_n;
								loc55_n = loc92_n;
								loc674_n = loc680_n;
								loc75_n = loc90_n;
								loc685_n = loc686_n;
								loc105_n = loc121_n;
								loc106_n = loc93_n;
								loc588_n = v822_n;
								loc589_n = v820_n;
								goto l000D9038;
							}
							loc31_n = loc84_n;
							loc36_n = loc85_n;
							loc51_n = loc92_n;
							loc670_n = loc680_n;
							loc74_n = loc90_n;
							loc684_n = loc686_n;
							loc94_n = loc93_n;
							loc104_n = loc121_n;
							loc662_n = 161;
l000D92EF:
							if (loc662_n == 161)
							{
								Eq_n v834_n;
								if (loc74_n == 0x00)
									v834_n = loc670_n;
								else
									v834_n = loc684_n;
								Eq_n v822_n = loc104_n != 0x00;
								if ((v822_n & (loc94_n | 0x20) == 101) == 0x00)
								{
									if (loc94_n > ~0x00)
									{
										loc34_n = loc31_n;
										loc39_n = loc36_n;
										loc54_n = loc51_n;
										loc673_n = loc670_n;
										loc687_n = v834_n;
										loc592_n = v822_n;
										loc662_n = 0xA9;
									}
									else
									{
										loc33_n = loc31_n;
										loc38_n = loc36_n;
										loc53_n = loc51_n;
										loc672_n = loc670_n;
										loc688_n = v834_n;
										loc593_n = v822_n;
										loc662_n = 171;
									}
l000D944B:
									int32 loc67_n = loc67;
									if (loc662_n == 0xA9)
									{
										if (arg0.u15[50] == 0x00)
										{
											loc33_n = loc34_n;
											loc38_n = loc39_n;
											loc53_n = loc54_n;
											loc672_n = loc673_n;
											loc688_n = loc687_n;
											loc593_n = loc592_n;
											loc662_n = 171;
										}
										else
										{
											arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
											if (loc592_n)
											{
												loc32_n = loc34_n;
												loc37_n = loc39_n;
												loc52_n = loc54_n;
												loc671_n = loc673_n;
												loc689_n = loc687_n;
												loc662_n = 0xAD;
											}
											else
												loc662_n = 0xAC;
										}
									}
									if (loc662_n == 171)
									{
										if (loc593_n)
										{
											loc32_n = loc33_n;
											loc37_n = loc38_n;
											loc52_n = loc53_n;
											loc671_n = loc672_n;
											loc689_n = loc688_n;
											loc662_n = 0xAD;
										}
										else
											loc662_n = 0xAC;
									}
									if (loc662_n == 0xAC)
									{
										*___errno_location().u3 = 22;
										fn000D1767(arg0, 0x00);
										goto l000DA4E7;
									}
									if (loc662_n != 0xAD)
									{
l000DA4E7:
										goto l000DA4E8;
									}
									uint32 v820_n = (uint32) *v820_n.u3;
									if (v820_n == 0x00 || loc671_n < 0x0A & loc689_n == loc671_n && loc13_n > 0x1E | v820_n >> loc13_n == 0x00)
										goto l000DA4E8;
									if (loc689_n > (int64) i32s-div(loc12_n, ~0x01))
									{
										*___errno_location().u3 = 0x22;
										goto l000DA4E8;
									}
									if (loc689_n < (int64) (loc12_n + ~0x69))
									{
										*___errno_location().u3 = 0x22;
										goto l000DA4E8;
									}
									int32 loc101_n;
									if (loc32_n == 0x00)
										loc101_n = loc37_n;
									else
									{
										if (loc32_n < 0x09)
										{
											ui32 * v820_n = (ui32 *) (v820_n.u2 + (loc37_n << 0x02));
											int32 loc100_n = loc32_n;
											ui32 loc399_n = *v820_n;
											ui32 v820_n;
											while (true)
											{
												v820_n = loc399_n * 0x0A;
												int32 v820_n = loc100_n + 0x01;
												if (v820_n == 0x09)
													break;
												loc100_n = v820_n;
												loc399_n = v820_n;
											}
											*v820_n = v820_n;
										}
										loc101_n = loc37_n + 0x01;
									}
									if (loc52_n < 0x09)
									{
										if (loc52_n <= loc689_n & loc689_n < 0x12)
										{
											if (loc689_n == 0x09 || loc689_n < 0x09)
												goto l000DA4E8;
											Eq_n v820_n = (word32) loc13_n + 27 + loc689_n * ~0x02;
											if (v820_n > 0x1E | *v820_n.u3 >> v820_n == 0x00)
											{
l000DA4E8:
												goto l000DA619;
											}
										}
									}
									ui32 v820_n = i32s-rem(loc689_n, 0x09);
									int32 loc70_n;
									int32 loc86_n;
									Eq_n loc89_n;
									if (v820_n == 0x00)
									{
										loc70_n = loc101_n;
										loc86_n = 0x00;
										loc89_n = loc689_n;
									}
									else
									{
										ui32 v820_n;
										if (loc689_n > ~0x00)
											v820_n = v820_n;
										else
											v820_n = v820_n + 0x09;
										word32 v820_n = g_a18F0[0x08 - v820_n];
										int32 loc41_n;
										int32 loc44_n;
										Eq_n loc47_n;
										if (loc101_n == 0x00)
										{
											loc41_n = 0x00;
											loc44_n = 0x00;
											loc47_n = loc689_n;
										}
										else
										{
											ui32 v820_n = i32s-div(1000000000, v820_n);
											ui32 loc30_n = 0x00;
											int32 loc42_n = 0x00;
											Eq_n loc48_n = loc689_n;
											int32 loc113_n = 0x00;
											ui32 v820_n;
											Eq_n v820_n;
											int32 v820_n;
											while (true)
											{
												word32 * v820_n = (word32 *) (v820_n.u2 + (loc113_n << 0x02));
												word32 v820_n = *v820_n;
												ui32 v820_n = i32u-rem(v820_n, v820_n);
												word32 v820_n = i32u-div(v820_n, v820_n) + loc30_n;
												*v820_n = v820_n;
												v820_n = v820_n * v820_n;
												ui32 v820_n = loc113_n == loc42_n & v820_n == 0x00;
												ui32 v820_n = loc42_n + 0x01;
												Eq_n v820_n = (word32) loc48_n - 9;
												if (v820_n)
													v820_n = v820_n;
												else
													v820_n = loc48_n;
												if (v820_n)
													v820_n = v820_n & 0x7F;
												else
													v820_n = loc42_n;
												int32 v820_n = loc113_n + 0x01;
												if (v820_n == loc101_n)
													break;
												loc30_n = v820_n;
												loc42_n = v820_n;
												loc48_n = v820_n;
												loc113_n = v820_n;
											}
											if (v820_n == 0x00)
												loc44_n = loc101_n;
											else
											{
												v820_n.u3[loc101_n] = v820_n;
												loc44_n = loc101_n + 0x01;
											}
											loc41_n = v820_n;
											loc47_n = v820_n;
										}
										loc70_n = loc44_n;
										loc86_n = loc41_n;
										loc89_n = (word32) loc47_n + (0x09 - v820_n);
									}
									Eq_n loc46_n;
									loc46_n.u0 = 0x00;
									while (true)
									{
										Eq_n v822_n = loc89_n < 0x12;
										Eq_n v822_n = loc89_n == 0x12;
										up32 * v820_n = (up32 *) (v820_n.u2 + (loc86_n << 0x02));
										Eq_n loc45_n = loc46_n;
										int32 loc69_n = loc70_n;
										Eq_n loc66_n;
										int32 v820_n;
										Eq_n v820_n;
										while (true)
										{
											if (v822_n == 0x00)
											{
												Eq_n loc120_n;
												if (v822_n == 0x00)
												{
													loc120_n = loc89_n;
													goto l000D9D18;
												}
												if (*v820_n < 9007199 == 0x00)
												{
													loc120_n.u0 = 0x12;
l000D9D18:
													int32 loc115_n = loc86_n;
													Eq_n loc72_n = loc45_n;
													int32 loc132_n = loc69_n;
													while (true)
													{
														int32 v820_n = loc132_n + 0x01;
														ui32 * v820_n = (ui32 *) (v820_n.u2 + ((loc132_n + 0x7F & 0x7F) << 0x02));
														Eq_n loc73_n = loc72_n;
														int32 loc116_n = loc115_n;
														Eq_n loc119_n = loc120_n;
														Eq_n v820_n;
														ui32 v820_n;
														Eq_n v820_n;
														int32 v820_n;
														while (true)
														{
															while (true)
															{
																Eq_n v822_n = loc119_n == 0x12;
																word32 v820_n;
																if (loc119_n > 0x1B)
																	v820_n = 0x09;
																else
																	v820_n = 0x01;
																Eq_n loc71_n = loc73_n;
																int32 loc114_n = loc116_n;
																while (true)
																{
																	int32 loc29_n = 0x00;
																	while (true)
																	{
																		ui32 v820_n = loc29_n + loc114_n;
																		if ((v820_n & 0x7F) == loc132_n)
																			break;
																		up32 v820_n = (up32) v820_n.u3[v820_n & 0x7F];
																		up32 v820_n = g_a1910[loc29_n];
																		if (v820_n < v820_n)
																		{
																			loc67_n = 0x02;
																			loc662_n = 220;
																			goto l000D9E46;
																		}
																		if (v820_n > v820_n)
																			goto l000D9E46;
																		int32 v820_n = loc29_n + 0x01;
																		if (v820_n >= 0x02)
																		{
																			loc67_n = v820_n;
																			loc662_n = 220;
																			goto l000D9E46;
																		}
																		loc29_n = v820_n;
																	}
																	loc67_n = 0x02;
																	loc662_n = 220;
l000D9E46:
																	if (loc662_n == 220)
																	{
																		loc662_n = 0x00;
																		if (v822_n & loc67_n == 0x02)
																		{
																			real64 loc724_n = 0.0;
																			word32 loc122_n = 0x00;
																			int32 loc134_n = loc132_n;
																			int32 loc58_n;
																			real64 v823_n;
																			while (true)
																			{
																				ui32 v820_n = loc122_n + loc114_n;
																				int32 v820_n = loc134_n + 0x01;
																				if ((v820_n & 0x7F) == loc134_n)
																				{
																					v820_n.u3[(v820_n & 0x7F) + ~0x00] = 0x00;
																					loc58_n = v820_n & 0x7F;
																				}
																				else
																					loc58_n = loc134_n;
																				v823_n = loc724_n * 1000000000.0 + (real64) (v820_n.u3)[v820_n & 0x7F];
																				word32 v820_n = loc122_n + 0x01;
																				if (v820_n == 0x02)
																					break;
																				loc724_n = v823_n;
																				loc122_n = v820_n;
																				loc134_n = loc58_n;
																			}
																			real64 v823_n = (real64) loc16_n;
																			ui32 v820_n = (word32) loc71_n + 53;
																			Eq_n v820_n = v820_n - loc12_n;
																			Eq_n v823_n = v823_n * v823_n;
																			Eq_n v822_n = v820_n < loc13_n;
																			Eq_n v820_n;
																			if (v820_n < 0x00)
																				v820_n.u0 = 0x00;
																			else
																				v820_n = v820_n;
																			ui32 loc43_n = v822_n & 0x01;
																			Eq_n v820_n;
																			if (v822_n)
																				v820_n = v820_n;
																			else
																				v820_n = loc13_n;
																			Eq_n loc722_n;
																			Eq_n loc723_n;
																			Eq_n loc729_n;
																			if (v820_n < 0x35)
																			{
																				Eq_n v823_n = fn000DAAEE(fn000DA9E1(1.0, 0x69 - v820_n), v823_n);
																				Eq_n v823_n = fn000DAB16(v823_n, fn000DA9E1(1.0, 0x35 - v820_n));
																				loc722_n = v823_n;
																				loc723_n = v823_n;
																				loc729_n = v823_n + (v823_n - v823_n);
																			}
																			else
																			{
																				loc722_n.u0 = 0.0;
																				loc723_n.u0 = 0.0;
																				loc729_n = v823_n;
																			}
																			int32 v820_n = loc114_n + 0x02;
																			bool v822_n = (v820_n & 0x7F) == loc58_n;
																			Eq_n loc735_n;
																			if (v822_n)
																				loc735_n = loc723_n;
																			else
																			{
																				up32 v820_n = (up32) v820_n.u3[v820_n & 0x7F];
																				Eq_n loc728_n;
																				if (v820_n < 500000000)
																				{
																					if (v820_n == 0x00 && (loc114_n + 0x03 & 0x7F) == loc58_n)
																						loc728_n = loc723_n;
																					else
																					{
																						Eq_n v823_n = v823_n * 0.25 + loc723_n;
																						loc43_n = v820_n < loc13_n & 0x01;
																						loc728_n = v823_n;
																					}
																				}
																				else if (v820_n == 500000000 == 0x00)
																					loc728_n = v823_n * 0.75 + loc723_n;
																				else if ((loc114_n + 0x03 & 0x7F) == loc58_n)
																					loc728_n = v823_n * 0.5 + loc723_n;
																				else
																					loc728_n = v823_n * 0.75 + loc723_n;
																				if (0x35 - v820_n > 0x01)
																				{
																					if (fn000DAB16(loc728_n, 1.0) != 0.0)
																					{
																						loc735_n = loc728_n;
																						goto l000DA3B3;
																					}
																					loc735_n = loc728_n + 1.0;
																				}
																				else
																					loc735_n = loc728_n;
																			}
l000DA3B3:
																			Eq_n v823_n = loc729_n + loc735_n - loc722_n;
																			bool v822_n = (v820_n & 0x7FFFFFFF) > ~0x01 - v820_n;
																			Eq_n loc736_n;
																			Eq_n loc118_n;
																			if (v822_n)
																			{
																				Eq_n loc732_n;
																				ui32 loc87_n;
																				Eq_n loc103_n;
																				if (fabs(v823_n) >= 9007199254740992.0 == 0x00)
																				{
																					loc732_n = v823_n;
																					loc87_n = loc43_n;
																					loc103_n = loc71_n;
																				}
																				else
																				{
																					Eq_n v820_n;
																					v820_n.u0 = loc71_n.u0 + 1;
																					ui32 v820_n;
																					if (v822_n & v820_n == v820_n)
																						v820_n = 0x00;
																					else
																						v820_n = loc43_n;
																					loc732_n = v823_n *64 0.5;
																					loc87_n = v820_n;
																					loc103_n = v820_n;
																				}
																				if ((word32) loc103_n + 50 > v820_n == 0x00 && (loc735_n != 0.0 & loc87_n != 0x00) == 0x00)
																				{
																					loc736_n = loc732_n;
																					loc118_n = loc103_n;
																					goto l000DA4D4;
																				}
																				*___errno_location().u3 = 0x22;
																				loc736_n = loc732_n;
																				loc118_n = loc103_n;
																			}
																			else
																			{
																				loc736_n = v823_n;
																				loc118_n = loc71_n;
																			}
l000DA4D4:
																			fn000DAB02(loc736_n, loc118_n);
																			goto l000DA4E7;
																		}
																	}
																	v820_n.u0 = loc71_n.u0 + v820_n;
																	if (loc114_n != loc132_n)
																		break;
																	loc71_n = v820_n;
																	loc114_n = loc132_n;
																}
																ui32 v820_n = 0x01 << v820_n;
																uint32 v820_n = 1000000000 >> v820_n;
																ui32 loc26_n = 0x00;
																int32 loc128_n = loc114_n;
																Eq_n loc129_n = loc119_n;
																int32 loc133_n = loc114_n;
																while (true)
																{
																	uint32 * v820_n = (uint32 *) (v820_n.u2 + (loc133_n << 0x02));
																	uint32 v820_n = *v820_n;
																	uint32 v820_n = (v820_n >> v820_n) + loc26_n;
																	*v820_n = v820_n;
																	v820_n = (v820_n & v820_n + ~0x00) * v820_n;
																	ui32 v820_n = loc133_n == loc128_n & v820_n == 0x00;
																	int32 v820_n = loc128_n + 0x01;
																	Eq_n v820_n = (word32) loc129_n - 9;
																	if (v820_n)
																		v820_n = v820_n;
																	else
																		v820_n = loc129_n;
																	if (v820_n)
																		v820_n = v820_n & 0x7F;
																	else
																		v820_n = loc128_n;
																	int32 v820_n = loc133_n + 0x01;
																	if ((v820_n & 0x7F) == loc132_n)
																		break;
																	loc26_n = v820_n;
																	loc128_n = v820_n;
																	loc129_n = v820_n;
																	loc133_n = v820_n & 0x7F;
																}
																if (v820_n != 0x00)
																	break;
																loc73_n = v820_n;
																loc116_n = v820_n;
																loc119_n = v820_n;
															}
															if ((v820_n & 0x7F) == v820_n == 0x00)
																break;
															*v820_n |= 0x01;
															loc73_n = v820_n;
															loc116_n = v820_n;
															loc119_n = v820_n;
														}
														v820_n.u3[loc132_n] = v820_n;
														loc72_n = v820_n;
														loc115_n = v820_n;
														loc120_n = v820_n;
														loc132_n = v820_n & 0x7F;
													}
												}
											}
											Eq_n loc28_n;
											loc28_n.u0 = 0x00;
											int32 loc88_n = loc69_n;
											int32 loc126_n = loc69_n + 0x7F;
											while (true)
											{
												int32 v820_n = loc126_n & 0x7F;
												union Eq_n * v820_n = (union Eq_n *) (v820_n.u2 + (v820_n << 0x02));
												Eq_n v834_n = ((uint64) v820_n->u2 << 0x1D) + (uint64) loc28_n;
												Eq_n loc142_n;
												if (v834_n > 1000000000)
												{
													loc66_n = fn000D17F5(v834_n, 1000000000);
													loc142_n = fn000D2E1D(v834_n, 1000000000);
												}
												else
												{
													loc66_n.u0 = 0x00;
													loc142_n = v834_n;
												}
												v820_n->u2 = (int8 *) loc142_n;
												Eq_n v822_n = v820_n == loc86_n;
												ui32 v820_n = v820_n != (loc88_n + 0x7F & 0x7F) | v822_n;
												int32 v820_n;
												if (loc142_n == 0x00)
													v820_n = v820_n;
												else
													v820_n = loc88_n;
												if (v820_n)
													v820_n = loc88_n;
												else
													v820_n = v820_n;
												if (v822_n)
													break;
												loc28_n = loc66_n;
												loc88_n = v820_n;
												loc126_n = v820_n + ~0x00;
											}
											v820_n.u0 = (word32) loc45_n - 29;
											if (loc66_n != 0x00)
												break;
											loc45_n = v820_n;
											loc69_n = v820_n;
										}
										ui32 v820_n = loc86_n + 0x7F;
										Eq_n v820_n = (word32) loc89_n + 9;
										int32 v820_n = v820_n + 0x7F;
										ui32 * v820_n = (ui32 *) (v820_n.u2 + ((v820_n + 0x7E & 0x7F) << 0x02));
										int32 loc117_n;
										if ((v820_n & 0x7F) == v820_n)
										{
											*v820_n |= v820_n.u3[v820_n & 0x7F];
											loc117_n = v820_n & 0x7F;
										}
										else
											loc117_n = v820_n;
										v820_n.u3[v820_n & 0x7F] = (int32) loc66_n;
										loc46_n = v820_n;
										loc70_n = loc117_n;
										loc86_n = v820_n & 0x7F;
										loc89_n = v820_n;
									}
								}
								loc52_n = loc52;
								loc37_n = loc37;
								loc32_n = loc32;
								loc671_n = loc671;
								loc689_n = loc689;
								loc688_n = loc688;
								loc672_n = loc672;
								loc53_n = loc53;
								loc38_n = loc38;
								loc33_n = loc33;
								loc593_n = loc593;
								Mem2553 = Mem2680;
								Eq_n v834_n = fn000DA625(arg0, arg2);
								Eq_n loc668_n;
								if (v834_n == 0x80000000)
								{
									if (arg2 == 0x00)
									{
										fn000D1767(arg0, 0x00);
										goto l000D944B;
									}
									if (arg0.u15[50] != 0x00)
										arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
									loc668_n.u0 = 0x00;
								}
								else
									loc668_n = v834_n;
								loc32_n = loc31_n;
								loc37_n = loc36_n;
								loc52_n = loc51_n;
								loc671_n = loc670_n;
								loc689_n = loc668_n + v834_n;
								loc662_n = 0xAD;
							}
							loc688_n = loc688;
							loc672_n = loc672;
							loc53_n = loc53;
							loc38_n = loc38;
							loc33_n = loc33;
							loc593_n = loc593;
							goto l000D944B;
						}
						Eq_n v820_n;
						if (v822_n)
							v820_n = v834_n;
						else
							v820_n = loc55_n;
						uint32 * v820_n = (uint32 *) (v820_n.u2 + (loc40_n << 0x02));
						uint32 loc660_n;
						if (loc35_n == 0x00)
							loc660_n = loc589_n;
						else
							loc660_n = (word32) loc106_n - 48 + *v820_n * 0x0A;
						*v820_n = loc660_n;
						int32 v820_n = loc35_n + 0x01;
						int32 v820_n = (v820_n == 0x09 & 0x01) + loc40_n;
						int32 v820_n;
						if (v820_n == 0x09)
							v820_n = 0x00;
						else
							v820_n = v820_n;
						loc680_n = v834_n;
						loc84_n = v820_n;
						loc85_n = v820_n;
						loc90_n = loc75_n;
						loc92_n = v820_n;
						loc686_n = loc685_n;
						loc121_n = 0x01;
l000D91B3:
						goto l000D91B4;
					}
					if (loc75_n == 0x00)
					{
						loc680_n = loc674_n;
						loc84_n = loc35_n;
						loc85_n = loc40_n;
						loc90_n = 0x01;
						loc92_n = loc55_n;
						loc686_n = loc674_n;
						loc121_n = loc105_n;
						goto l000D91B3;
					}
					loc34_n = loc35_n;
					loc39_n = loc40_n;
					loc54_n = loc55_n;
					loc673_n = loc674_n;
					loc687_n = loc685_n;
					loc592_n = loc105_n != 0x00;
					loc662_n = 0xA9;
				}
				else
				{
					loc31_n = 0x00;
					loc36_n = 0x00;
					loc51_n.u0 = 0x00;
					loc670_n.u0 = 0x00;
					loc74_n = loc49_n;
					loc684_n = loc681_n;
					loc94_n = loc78_n;
					loc104_n = loc91_n;
					loc662_n = 161;
				}
				goto l000D92EF;
			}
			Eq_n v820_n;
			v820_n.u2 = arg0.u15[2];
			Eq_n loc11_n;
			if (v820_n < (arg0.u15)[50])
			{
				arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
				loc11_n = (word32) *v820_n.u2 & 0xFF;
			}
			else
				loc11_n = fn000D2493(arg0);
			word32 loc18_n = 0x00;
l000D8362:
			word32 loc96_n = loc96;
			int64 loc683_n = loc683;
			Eq_n loc83_n = loc83;
			real64 loc731_n = loc731;
			real64 loc730_n = loc730;
			word32 loc82_n = loc82;
			word32 loc60_n = loc60;
			int64 loc678_n = loc678;
			int64 loc679_n = loc679;
			word32 loc81_n = loc81;
			Eq_n loc21_n = loc21;
			real64 loc721_n = loc721;
			real64 loc720_n = loc720;
			word32 loc20_n = loc20;
			int64 loc666_n = loc666;
			word32 loc19_n = loc19;
			Eq_n loc77_n = loc77;
			word32 loc662_n = 0x04;
			switch (loc11_n)
			{
			case 0x2E:
				loc662_n = 0x4A;
				break;
			case 0x2F:
				Mem567 = Mem617;
				Eq_n v820_n;
				v820_n.u2 = arg0.u15[2];
				if (v820_n < (arg0.u15)[50])
				{
					arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
					loc11_n = (word32) *v820_n.u2 & 0xFF;
					loc18_n = 0x01;
				}
				else
				{
					loc11_n = fn000D2493(arg0);
					loc18_n = 0x01;
				}
				goto l000D8362;
			case 0x30:
				loc666_n = 0x00;
				loc19_n = 0x00;
				loc20_n = 0x00;
				loc720_n = 1.0;
				loc721_n = 0.0;
				loc21_n.u0 = 0x00;
				loc679_n = 0x00;
				loc77_n = loc11_n;
				loc81_n = loc18_n;
				break;
			}
			if (loc662_n == 0x4A)
			{
				Eq_n v820_n;
				v820_n.u2 = arg0.u15[2];
				Eq_n loc57_n;
				if (v820_n < (arg0.u15)[50])
				{
					arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
					loc57_n = (word32) *v820_n.u2 & 0xFF;
				}
				else
					loc57_n = fn000D2493(arg0);
				if (loc57_n == 0x30)
				{
					int64 loc667_n = 0x00;
					Eq_n loc209_n;
					int64 v834_n;
					while (true)
					{
						Eq_n v820_n;
						v820_n.u2 = arg0.u15[2];
						if (v820_n < (arg0.u15)[50])
						{
							arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
							loc209_n = (word32) *v820_n.u2 & 0xFF;
						}
						else
							loc209_n = fn000D2493(arg0);
						v834_n = loc667_n + ~0x00;
						if (loc209_n != 0x30)
							break;
						loc667_n = v834_n;
					}
					loc679_n = v834_n;
					loc77_n = loc209_n;
					loc81_n = 0x01;
				}
				else
				{
					loc679_n = 0x00;
					loc77_n = loc57_n;
					loc81_n = loc18_n;
				}
				loc21_n.u0 = 0x00;
				loc721_n = 0.0;
				loc720_n = 1.0;
				loc20_n = 0x00;
				loc666_n = 0x00;
				loc19_n = 0x01;
			}
l000D8599:
			Eq_n loc719_n = loc719;
			Eq_n loc740_n = loc740;
			Eq_n loc23_n = loc23;
			Eq_n loc24_n = loc24;
			Eq_n loc284_n = loc284;
			Eq_n loc22_n = loc22;
			Eq_n v820_n = (word32) loc77_n - 48;
			uint32 v820_n = loc77_n | 0x20;
			if (v820_n >= 0x0A)
			{
				Eq_n v822_n = loc77_n == 0x2E;
				Eq_n loc79_n;
				if ((v822_n | v820_n < 0x67) == 0x00)
				{
					loc79_n = loc77_n;
					goto l000D8838;
				}
				if (v822_n)
				{
					if (loc19_n != 0x00)
					{
						loc79_n.u0 = 0x2E;
l000D8838:
						if (loc81_n == 0x00)
						{
							Eq_n v820_n;
							v820_n.u2 = arg0.u15[50];
							if (v820_n == 0x00 == 0x00)
								arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
							if (arg2 == 0x00)
								fn000D1767(arg0, 0x00);
							else if (v820_n == 0x00 == 0x00)
							{
								Eq_n v820_n;
								v820_n.u2 = arg0.u15[2];
								arg0.u15[2] = (struct Eq_n) &v820_n.u15->bFFFFFFFF;
								if (loc19_n == 0x00 == 0x00)
									arg0.u15[2] = (struct Eq_n) ((word32) v820_n - 2);
							}
						}
						else
						{
							int64 v834_n;
							if (loc19_n == 0x00)
								v834_n = loc666_n;
							else
								v834_n = loc679_n;
							Eq_n loc98_n;
							if (loc666_n < 0x08)
							{
								int64 loc682_n = loc666_n;
								Eq_n loc99_n = loc21_n;
								Eq_n v820_n;
								while (true)
								{
									v820_n = loc99_n << 0x04;
									int64 v834_n = loc682_n + 0x01;
									if (v834_n >= 0x08)
										break;
									loc682_n = v834_n;
									loc99_n = v820_n;
								}
								loc98_n = v820_n;
							}
							else
								loc98_n = loc21_n;
							Eq_n loc664_n;
							if ((loc79_n | 0x20) == 0x70)
							{
								Eq_n v834_n = fn000DA625(arg0, arg2);
								if (v834_n == 0x80000000)
								{
									if (arg2 == 0x00)
									{
										fn000D1767(arg0, 0x00);
										goto l000DA619;
									}
									if (arg0.u15[50] != 0x00)
										arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
									loc664_n.u0 = 0x00;
								}
								else
									loc664_n = v834_n;
							}
							else
							{
								if (arg0.u15[50] != 0x00)
									arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
								loc664_n.u0 = 0x00;
							}
							Eq_n v834_n;
							v834_n.u0 = (word32) loc664_n + ((v834_n << 0x02) + ~0x1F);
							if (loc98_n != 0x00)
							{
								if (v834_n > (uint64) (0x00 - loc12_n))
									*___errno_location().u3 = 0x22;
								else if (v834_n < (int64) (loc12_n + ~0x69))
									*___errno_location().u3 = 0x22;
								else
								{
									Eq_n loc676_n;
									real64 loc733_n;
									Eq_n loc111_n;
									if (loc98_n > ~0x00)
									{
										Eq_n loc677_n = v834_n;
										real64 loc734_n = loc721_n;
										Eq_n loc112_n = loc98_n;
										int32 v820_n;
										real64 v823_n;
										Eq_n v834_n;
										while (true)
										{
											Eq_n v822_n = loc734_n >= 0.5;
											real64 v823_n = loc734_n + -1.0;
											v820_n = v822_n == 0x00 & 0x01 | loc112_n << 0x01;
											real64 v823_n;
											if (v822_n == 0x00)
												v823_n = loc734_n;
											else
												v823_n = v823_n;
											v823_n = loc734_n + v823_n;
											v834_n.u0 = &loc677_n.u1->bFFFFFFFF;
											if (v820_n <= ~0x00)
												break;
											loc677_n = v834_n;
											loc734_n = v823_n;
											loc112_n = v820_n ^ 0x01;
										}
										loc676_n = v834_n;
										loc733_n = v823_n;
										loc111_n = v820_n ^ 0x01;
									}
									else
									{
										loc676_n = v834_n;
										loc733_n = loc721_n;
										loc111_n = loc98_n;
									}
									Eq_n v834_n = loc676_n.u0 + (0x20 - (int64) loc12_n);
									word32 loc662_n;
									if ((uint64) loc13_n > v834_n)
									{
										if (v834_n < 0x00)
										{
											loc24_n.u0 = 0x00;
											loc284_n.u0 = 0x54;
											loc662_n = 0x7F;
										}
										else
										{
											loc22_n = v834_n;
											loc662_n = 0x7D;
										}
									}
									else
									{
										loc22_n = loc13_n;
										loc662_n = 0x7D;
									}
									if (loc662_n == 0x7D)
									{
										Eq_n v820_n = 0x54 - loc22_n;
										if (loc22_n < 0x35)
										{
											loc24_n = loc22_n;
											loc284_n = v820_n;
											loc662_n = 0x7F;
										}
										else
										{
											loc719_n.u0 = 0.0;
											loc23_n = loc22_n;
											loc740_n.u2 = (real64) loc16_n;
										}
									}
									if (loc662_n == 0x7F)
									{
										Eq_n v823_n;
										v823_n.u2 = (real64) loc16_n;
										loc719_n = fn000DAAEE(fn000DA9E1(1.0, loc284_n), v823_n);
										loc23_n = loc24_n;
										loc740_n = v823_n;
									}
									ui32 v820_n = (loc111_n & 0x01) == 0x00 & (loc733_n != 0.0 & loc23_n < 0x20);
									uint32 v820_n = (word32) loc111_n + (v820_n & 0x01);
									real64 v823_n;
									if (v820_n)
										v823_n = 0.0;
									else
										v823_n = loc733_n;
									Eq_n v823_n = loc740_n *64 v823_n + (loc719_n + loc740_n *64 (real64) v820_n) - loc719_n;
									if (v823_n != 0.0 == 0x00)
										*___errno_location().u3 = 0x22;
									fn000DAB02(v823_n, loc676_n);
								}
							}
						}
						goto l000DA619;
					}
					loc678_n = loc666_n;
					loc60_n = 0x01;
					loc683_n = loc666_n;
					loc82_n = loc20_n;
					loc730_n = loc720_n;
					loc731_n = loc721_n;
					loc83_n = loc21_n;
					loc96_n = loc81_n;
				}
				else
					loc662_n = 0x56;
				goto l000D863C;
			}
			loc662_n = 0x56;
l000D863C:
			if (loc662_n != 0x56)
				goto l000D8789;
			loc662_n = 0x00;
			Eq_n v820_n;
			if (loc77_n > 0x39)
				v820_n = v820_n + ~0x56;
			else
				v820_n = v820_n;
			bool v822_n = loc666_n < 0x08;
			word32 loc61_n;
			real64 loc727_n;
			Eq_n loc62_n;
			real64 loc726_n;
			if (!v822_n)
			{
				if (loc666_n >= 0x0E)
				{
					if (loc20_n != 0x00 | v820_n == 0x00)
					{
						loc61_n = loc20_n;
						loc727_n = loc721_n;
					}
					else
					{
						loc61_n = 0x01;
						loc727_n = loc721_n + loc720_n * 0.5;
					}
					loc62_n = loc21_n;
					goto l000D8755;
				}
				else
				{
					real64 v823_n = loc720_n * 0.0625;
					loc61_n = loc20_n;
					loc726_n = v823_n;
					loc727_n = loc721_n + v823_n * (real64) v820_n;
					loc62_n = loc21_n;
					goto l000D8756;
				}
			}
			else
			{
				loc61_n = loc20_n;
				loc727_n = loc721_n;
				loc62_n = (word32) v820_n + (loc21_n << 0x04);
l000D8755:
				loc726_n = loc720_n;
l000D8756:
				loc678_n = loc666_n + 0x01;
				loc60_n = loc19_n;
				loc683_n = loc679_n;
				loc82_n = loc61_n;
				loc730_n = loc726_n;
				loc731_n = loc727_n;
				loc83_n = loc62_n;
				loc96_n = 0x01;
l000D8789:
				Eq_n v820_n;
				v820_n.u2 = arg0.u15[2];
				if (v820_n < (arg0.u15)[50])
				{
					arg0.u15[2] = (struct Eq_n) (v820_n.u14 + 1);
					loc666_n = loc678_n;
					loc19_n = loc60_n;
					loc20_n = loc82_n;
					loc720_n = loc730_n;
					loc721_n = loc731_n;
					loc21_n = loc83_n;
					loc679_n = loc683_n;
					loc77_n = (word32) *v820_n.u2 & 0xFF;
					loc81_n = loc96_n;
				}
				else
				{
					loc666_n = loc678_n;
					loc19_n = loc60_n;
					loc20_n = loc82_n;
					loc720_n = loc730_n;
					loc721_n = loc731_n;
					loc21_n = loc83_n;
					loc679_n = loc683_n;
					loc77_n = fn000D2493(arg0);
					loc81_n = loc96_n;
				}
				goto l000D8599;
			}
		case 0x02:
		case 0x03:
			Mem414 = Mem5397;
			if (arg0.u15[50] == 0x00 == 0x00)
				arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
			*___errno_location().u3 = 22;
			fn000D1767(arg0, 0x00);
l000DA619:
			g_t140030.u2 = (int8 *) v820_n;
			return <invalid>;
		}
	}
}

// 000DA625: Stack word64 fn000DA625(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000D7B90
word64 fn000DA625(Eq_n arg0, Eq_n arg1)
{
	Eq_n v101_n;
	v101_n.u2 = arg0.u15[2];
	Eq_n loc13_n;
	if (v101_n < (arg0.u15)[50])
	{
		arg0.u15[2] = (struct Eq_n) (v101_n.u14 + 1);
		loc13_n = (word32) *v101_n.u2 & 0xFF;
	}
	else
		loc13_n = fn000D2493(arg0);
	Eq_n v103_n = loc13_n == 0x2D;
	Eq_n loc4_n;
	switch (loc13_n)
	{
	case 0x2B:
		goto l000DA69C;
	case 44:
l000DA69C:
		Eq_n v101_n;
		v101_n.u2 = arg0.u15[2];
		Eq_n loc24_n;
		if (v101_n < (arg0.u15)[50])
		{
			arg0.u15[2] = (struct Eq_n) (v101_n.u14 + 1);
			loc24_n = (word32) *v101_n.u2 & 0xFF;
		}
		else
			loc24_n = fn000D2493(arg0);
		ui32 loc2_n;
		if (arg1 != 0x00 & loc24_n > 0x39)
		{
			if (arg0.u15[50] != 0x00)
				arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
			loc2_n = loc13_n == 0x2D & 0x01;
		}
		else
			loc2_n = v103_n & 0x01;
		loc4_n = loc24_n;
		break;
	case 0x2D:
		Mem483 = Mem69;
		loc2_n = 0x00;
		loc4_n = loc13_n;
		break;
	}
	if (loc4_n > 0x39)
	{
		if (arg0.u15[50] != 0x00)
			arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
	}
	else
	{
		Eq_n loc3_n;
		loc3_n.u0 = 0x00;
		Eq_n loc6_n = loc4_n;
		Eq_n v101_n;
		Eq_n loc5_n;
		while (true)
		{
			Eq_n v101_n;
			v101_n.u2 = arg0.u15[2];
			v101_n = (word32) loc6_n - 48 + loc3_n * 0x0A;
			if (v101_n < (arg0.u15)[50])
			{
				arg0.u15[2] = (struct Eq_n) (v101_n.u14 + 1);
				loc5_n = (word32) *v101_n.u2 & 0xFF;
			}
			else
				loc5_n = fn000D2493(arg0);
			if (!(loc5_n < 0x3A & v101_n < 0x0CCCCCCC))
				break;
			loc3_n = v101_n;
			loc6_n = loc5_n;
		}
		int64 v108_n = (int64) v101_n;
		Eq_n loc8_n;
		if (loc5_n < 0x3A)
		{
			int64 loc91_n = v108_n;
			Eq_n loc9_n = loc5_n;
			Eq_n loc7_n;
			while (true)
			{
				Eq_n v101_n;
				v101_n.u2 = arg0.u15[2];
				int64 v106_n = (int64) loc9_n + ~0x2F + loc91_n * 0x0A;
				if (v101_n < (arg0.u15)[50])
				{
					arg0.u15[2] = (struct Eq_n) (v101_n.u14 + 1);
					loc7_n = (word32) *v101_n.u2 & 0xFF;
				}
				else
					loc7_n = fn000D2493(arg0);
				if (!(loc7_n < 0x3A & v106_n < 0x7BE7EFBE))
					break;
				loc91_n = v106_n;
				loc9_n = loc7_n;
			}
			loc8_n = loc7_n;
		}
		else
			loc8_n = loc5_n;
		if (loc8_n < 0x3A)
		{
			Eq_n loc10_n;
			do
			{
				Eq_n v101_n;
				v101_n.u2 = arg0.u15[2];
				if (v101_n < (arg0.u15)[50])
				{
					arg0.u15[2] = (struct Eq_n) (v101_n.u14 + 1);
					loc10_n = (word32) *v101_n.u2 & 0xFF;
				}
				else
					loc10_n = fn000D2493(arg0);
			} while (loc10_n < 0x3A != 0x00);
		}
		if (arg0.u15[50] == 0x00 == 0x00)
			arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
	}
	return <invalid>;
}

// 000DA9E1: Stack Eq_n fn000DA9E1(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000D7B90
//      fn000DAB02
Eq_n fn000DA9E1(Eq_n arg0, Eq_n arg1)
{
	return <invalid>;
}

// 000DAAEE: Stack Eq_n fn000DAAEE(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000D7B90
Eq_n fn000DAAEE(Eq_n arg0, Eq_n arg1)
{
	return <invalid>;
}

// 000DAB02: Stack Eq_n fn000DAB02(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000D7B90
Eq_n fn000DAB02(Eq_n arg0, Eq_n arg1)
{
	return <invalid>;
}

// 000DAB16: Stack Eq_n fn000DAB16(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000D7B90
Eq_n fn000DAB16(Eq_n arg0, Eq_n arg1)
{
	return <invalid>;
}

// 000DAB2A: Stack Eq_n fn000DAB2A(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000DAB16
Eq_n fn000DAB2A(Eq_n arg0, Eq_n arg1)
{
	Eq_n v103_n = reinterpret_cast<uint64>(arg0);
	Eq_n v103_n = reinterpret_cast<uint64>(arg1);
	bool v107_n = v103_n << 0x01 == 0x00;
	word32 loc46;
	Eq_n loc93;
	if (v107_n)
		loc46 = 0x03;
	else if ((v103_n & 0xFFFFFFFF) > 0x7FF00000 | (v103_n >> 0x34 & 0x07FF) == 0x07FF)
		loc46 = 0x03;
	else
	{
		if (v103_n << 0x01 > v103_n << 0x01 == 0x00)
		{
			Eq_n v102_n;
			if (v103_n << 0x01 == v103_n << 0x01)
				v102_n = arg0 *64 0.0;
			else
				v102_n = arg0;
			return v102_n;
		}
		Eq_n loc48_n;
		int32 loc7_n;
		if ((v103_n >> 0x34 & 0x07FF) == 0x00)
		{
			int32 loc4_n;
			if (v103_n << 0x0C > ~0x00)
			{
				int64 loc49_n = v103_n << 0x0C;
				int32 loc5_n = 0x00;
				int32 v101_n;
				while (true)
				{
					v101_n = loc5_n + ~0x00;
					int64 v104_n = loc49_n << 0x01;
					if (v104_n <= ~0x00)
						break;
					loc49_n = v104_n;
					loc5_n = v101_n;
				}
				loc4_n = v101_n;
			}
			else
				loc4_n = 0x00;
			loc48_n = v103_n << (uint64) (0x01 - loc4_n);
			loc7_n = loc4_n;
		}
		else
		{
			loc48_n = v103_n & 0xFFFFFFFF | 0x00100000;
			loc7_n = v103_n >> 0x34 & 0x07FF;
		}
		int32 loc6_n;
		ui64 loc59_n;
		if ((v103_n >> 0x34 & 0x07FF) == 0x00)
		{
			int32 loc2_n;
			if (v103_n << 0x0C > ~0x00)
			{
				int32 loc3_n = 0x00;
				int64 loc51_n = v103_n << 0x0C;
				int32 v101_n;
				while (true)
				{
					v101_n = loc3_n + ~0x00;
					int64 v104_n = loc51_n << 0x01;
					if (v104_n <= ~0x00)
						break;
					loc3_n = v101_n;
					loc51_n = v104_n;
				}
				loc2_n = v101_n;
			}
			else
				loc2_n = 0x00;
			loc6_n = loc2_n;
			loc59_n = v103_n << (uint64) (0x01 - loc2_n);
		}
		else
		{
			loc6_n = v103_n >> 0x34 & 0x07FF;
			loc59_n = v103_n & 0xFFFFFFFF | 0x00100000;
		}
		bool v107_n = loc7_n > loc6_n;
		Eq_n v104_n = loc48_n - loc59_n;
		Eq_n loc50_n;
		int32 loc8_n;
		Eq_n loc12_n;
		Eq_n loc58_n;
		if (v107_n)
		{
			Eq_n loc52_n = loc48_n;
			int32 loc9_n = loc7_n;
			Eq_n loc78_n = v104_n;
			Eq_n loc43_n = v104_n > ~0x00;
			Eq_n v104_n;
			int32 v101_n;
			Eq_n v104_n;
			while (true)
			{
				Eq_n loc53_n;
				if (loc43_n)
				{
					if (loc78_n == 0x00)
					{
						loc93 = arg0 *64 0.0;
						goto l000DAEE1;
					}
					loc53_n = loc78_n;
				}
				else
					loc53_n = loc52_n;
				v104_n = loc53_n << 0x01;
				v101_n = loc9_n + ~0x00;
				v104_n = v104_n - loc59_n;
				if (v101_n <= loc6_n)
					break;
				loc52_n = v104_n;
				loc9_n = v101_n;
				loc78_n = v104_n;
				loc43_n = v104_n > ~0x00;
			}
			loc50_n = v104_n;
			loc8_n = v101_n;
			loc12_n = v104_n > ~0x00;
			loc58_n = v104_n;
		}
		else
		{
			loc50_n = loc48_n;
			loc8_n = loc7_n;
			loc12_n = v104_n > ~0x00;
			loc58_n = v104_n;
		}
		Eq_n loc55_n;
		if (loc12_n)
		{
			if (loc58_n == 0x00)
			{
				loc93 = arg0 *64 0.0;
				goto l000DAEE1;
			}
			loc55_n = loc58_n;
		}
		else
			loc55_n = loc50_n;
		Eq_n loc54_n;
		int32 loc10_n;
		if (loc55_n < 0x00100000)
		{
			int32 loc11_n = loc8_n;
			Eq_n loc56_n = loc55_n;
			Eq_n v104_n;
			int32 v101_n;
			while (true)
			{
				v104_n = loc56_n << 0x01;
				v101_n = loc11_n + ~0x00;
				if (v104_n >= 0x00100000)
					break;
				loc11_n = v101_n;
				loc56_n = v104_n;
			}
			loc54_n = v104_n;
			loc10_n = v101_n;
		}
		else
		{
			loc54_n = loc55_n;
			loc10_n = loc8_n;
		}
		uint64 loc57_n;
		if (loc10_n > 0x00)
			loc57_n = (word32) loc54_n + 0x00F00000 | (uint64) loc10_n << 0x34;
		else
			loc57_n = loc54_n >> (uint64) (0x01 - loc10_n);
		loc93 = reinterpret_cast<real64>(loc57_n | v103_n & 0x80000000);
	}
l000DAEE1:
	if (loc46 == 0x03)
	{
		real64 v102_n = arg0 *64 arg1;
		loc93 = v102_n / v102_n;
	}
	return loc93;
}

// 000DAF01: Stack Eq_n fn000DAF01(Stack Eq_n arg0)
Eq_n fn000DAF01(Eq_n arg0)
{
	return <invalid>;
}

// 000DAF0C: Stack Eq_n fn000DAF0C(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3)
Eq_n fn000DAF0C(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3)
{
	return <invalid>;
}

// 000DAF17: Stack Eq_n fn000DAF17(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn0011547B
//      fn0011579C
Eq_n fn000DAF17(Eq_n arg0, Eq_n arg1)
{
	return <invalid>;
}

// 000DAF22: void fn000DAF22(Stack Eq_n arg0)
void fn000DAF22(Eq_n arg0)
{
	_free(arg0);
}

// 000DAF30: Stack Eq_n fn000DAF30(Stack Eq_n arg0)
// Called from:
//      fn000D0843
//      fn001154D6
//      fn001157F7
//      fn0011B742
//      fn0011C019
//      fn0011C48D
//      fn0011D16F
//      fn0011D354
Eq_n fn000DAF30(Eq_n arg0)
{
	bool v37_n = (arg0 & 0x03) == 0x00;
	Eq_n loc3;
	word32 loc31;
	if (v37_n)
	{
		loc3 = arg0;
l000DAFB7:
		loc31 = 0x04;
	}
	else
	{
		Eq_n loc4_n = arg0;
		while ((int32) *loc4_n.u2 != 0x00)
		{
			Eq_n v35_n;
			v35_n.u14 = loc4_n.u14 + 1;
			if ((v35_n & 0x03) == 0x00)
			{
				loc3 = v35_n;
				goto l000DAFB7;
			}
			loc4_n = v35_n;
		}
	}
	if (loc31 == 0x04)
	{
		Eq_n loc1_n = loc3;
		ui32 v35_n;
		while (true)
		{
			v35_n = *loc1_n.u3;
			Eq_n v35_n;
			v35_n.u2 = loc1_n + 0x04;
			if (((v35_n & 0x80808080 ^ 0x80808080) & v35_n + ~0x01010100) != 0x00)
				break;
			loc1_n = v35_n;
		}
		if ((int32) (byte) v35_n != 0x00)
		{
			Eq_n loc7_n = loc1_n;
			while (true)
			{
				Eq_n v35_n;
				v35_n.u2 = loc7_n + 0x01;
				if ((int32) *v35_n.u2 == 0x00)
					break;
				loc7_n = v35_n;
			}
		}
	}
	return <invalid>;
}

// 000DB07F: Stack Eq_n fn000DB07F(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3)
// Called from:
//      fn000DBA9B
//      fn000DD675
//      fn000DD6A2
Eq_n fn000DB07F(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3)
{
	Eq_n v57_n;
	v57_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	Eq_n v57_n;
	if (arg3 == 0x00)
		v57_n.u0 = 0x4654;
	else
		v57_n = arg3;
	int32 v57_n = *v57_n.u3;
	word32 loc56;
	if (arg1 == 0x00)
	{
		if (v57_n != 0x00)
			loc56 = 0x0F;
	}
	else
	{
		Eq_n v57_n;
		if (arg0 == 0x00)
			v57_n = v57_n;
		else
			v57_n = arg0;
		if (arg2 != 0x00)
		{
			int32 loc12;
			Eq_n loc6;
			int32 loc7;
			Eq_n loc8;
			if (v57_n == 0x00)
			{
				Eq_n v60_n;
				v60_n.u0 = *arg1.u2;
				ui32 v57_n = (word32) v60_n;
				if ((int32) v60_n > ~0x00)
				{
					*v57_n.u3 = v57_n & 0xFF;
					goto l000DB2CD;
				}
				uint32 v57_n = (v57_n & 0xFF) + ~0xC1;
				if (v57_n > 0x32)
				{
					loc56 = 0x0F;
					goto l000DB2CD;
				}
				int32 v57_n = g_a0A48[v57_n];
				if (arg2 == 0x01)
					loc12 = v57_n;
				else
				{
					loc6.u14 = arg1.u14 + 1;
					loc7 = v57_n;
					loc8.u2 = &arg2.u15->bFFFFFFFF;
					loc56 = 0x09;
				}
			}
			else
			{
				loc6 = arg1;
				loc7 = v57_n;
				loc8 = arg2;
				loc56 = 0x09;
			}
			if (loc56 == 0x09)
			{
				ui32 v57_n = (word32) *loc6.u2;
				uint32 v57_n = (v57_n & 0xFF) >> 0x03;
				if ((v57_n + ~0x0F | v57_n + (loc7 >> 0x1A)) > 0x07)
					loc56 = 0x0F;
				else
				{
					Eq_n loc9_n = loc6;
					int32 loc10_n = loc7;
					Eq_n loc11_n = loc8;
					ui32 loc39_n = v57_n;
					int32 v57_n;
					while (true)
					{
						v57_n = (loc39_n & 0xFF) + ~0x7F | loc10_n << 0x06;
						Eq_n v57_n;
						v57_n.u14 = loc9_n.u14 + 1;
						Eq_n v57_n;
						v57_n.u2 = &loc11_n.u15->bFFFFFFFF;
						if (v57_n < 0x00 == 0x00)
							break;
						if (v57_n == 0x00)
						{
							loc12 = v57_n;
							goto l000DB2BF;
						}
						ui32 v57_n = (word32) *v57_n.u2;
						if ((int32) ((byte) v57_n & 0xC0) != ~0x7F)
						{
							loc56 = 0x0F;
							goto l000DB2CD;
						}
						loc9_n = v57_n;
						loc10_n = v57_n;
						loc11_n = v57_n;
						loc39_n = v57_n;
					}
					*v57_n.u3 = 0x00;
					*v57_n.u3 = v57_n;
				}
l000DB2CD:
				if (loc56 == 0x0F)
				{
					*v57_n.u3 = 0x00;
					*___errno_location().u3 = 0x54;
				}
				g_t140030.u2 = (int8 *) v57_n;
				return <invalid>;
			}
l000DB2BF:
			*v57_n.u3 = loc12;
		}
	}
	goto l000DB2CD;
}

// 000DB2F6: Stack Eq_n fn000DB2F6(Stack Eq_n arg0, Stack Eq_n arg1)
Eq_n fn000DB2F6(Eq_n arg0, Eq_n arg1)
{
	return <invalid>;
}

// 000DB316: Stack Eq_n fn000DB316(Stack Eq_n arg0, Stack Eq_n arg1)
Eq_n fn000DB316(Eq_n arg0, Eq_n arg1)
{
	return <invalid>;
}

// 000DB328: Stack Eq_n fn000DB328(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
Eq_n fn000DB328(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	word32 loc14;
	if ((int32) *arg1.u2 == 0x00)
		loc14 = 0x04;
	else if (fn000D28D3(arg1, 0x37CF) == 0x00)
		loc14 = 0x04;
	else if (fn000D28D3(arg1, 0x34E6) == 0x00)
		loc14 = 0x04;
	if (loc14 == 0x04 && arg2 == 0x00)
	{
		if (*(word32 *) 18008 == 0x00)
			*(word32 *) 18008 = 0x01;
		else
			fn000E3D5D(0x01, 0x04);
	}
	return <invalid>;
}

// 000DB3DF: Stack Eq_n fn000DB3DF(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3)
// Called from:
//      fn00110FF7
//      fn001131F3
Eq_n fn000DB3DF(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3)
{
	Eq_n v7_n;
	v7_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	*v7_n.u3 = (int32) arg3;
	Eq_n v7_n = fn000D29A3(arg0, arg1, arg2, v7_n);
	g_t140030.u2 = (int8 *) v7_n;
	return <invalid>;
}

// 000DB419: Stack Eq_n fn000DB419(Stack Eq_n arg0)
// Called from:
//      fn000EAD98
//      fn000FA95B
//      fn000FADDC
//      fn00106A39
//      fn00116E5E
//      fn0011742D
//      fn001179EC
//      fn00117D2C
Eq_n fn000DB419(Eq_n arg0)
{
	Eq_n v9_n = _pthread_self();
	if (arg0 == 0x00 == 0x00)
		v9_n.u14[0x00B8] = (struct Eq_n) arg0;
	return <invalid>;
}

// 000DB44C: Stack Eq_n fn000DB44C(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000E5F91
Eq_n fn000DB44C(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	if (arg2 == 0x00 == 0x00)
	{
		Eq_n loc3_n = arg2;
		Eq_n loc4_n = arg1;
		Eq_n loc5_n = arg0;
		while (true)
		{
			*loc5_n.u3 = *loc4_n.u3;
			Eq_n v14_n;
			v14_n.u2 = &loc3_n.u15->bFFFFFFFF;
			Eq_n v14_n;
			v14_n.u2 = loc4_n + 0x04;
			Eq_n v14_n;
			v14_n.u15 = loc5_n.u15 + 2;
			if (v14_n == 0x00)
				break;
			loc3_n = v14_n;
			loc4_n = v14_n;
			loc5_n = v14_n;
		}
	}
	return <invalid>;
}

// 000DB4B6: Stack Eq_n fn000DB4B6(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
Eq_n fn000DB4B6(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v55_n;
	v55_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	if (arg1 == 0x00)
	{
l000DB6CC:
		g_t140030.u2 = (int8 *) v55_n;
		return <invalid>;
	}
	if (arg2 == 0x00 == 0x00)
	{
		Eq_n v55_n;
		if (arg0 == 0x00)
			v55_n = v55_n;
		else
			v55_n = arg0;
		int8 v58_n = *arg1.u2;
		ui32 v55_n = (word32) v58_n;
		if ((int32) v58_n > ~0x00)
		{
			*v55_n.u3 = (int32) (v55_n & 0xFF);
			goto l000DB6CC;
		}
		uint32 v55_n = (v55_n & 0xFF) + ~0xC1;
		if (v55_n > 0x32 == 0x00)
		{
			int32 v55_n = g_a0A48[v55_n];
			if (arg2 < 0x04 && ((v55_n & 0x80000000 >> arg2 * 0x06 + ~0x05) == 0x00) == 0x00)
				goto l000DB6BA;
			ui32 v55_n = (word32) arg1.u14[1];
			uint32 v55_n = (v55_n & 0xFF) >> 0x03;
			if ((v55_n + ~0x0F | v55_n + (v55_n >> 0x1A)) > 0x07 == 0x00)
			{
				Eq_n v55_n = (v55_n & 0xFF) + ~0x7F | v55_n << 0x06;
				if (v55_n < 0x00 == 0x00)
				{
					*v55_n.u3 = (int32) v55_n;
					goto l000DB6CC;
				}
				uint32 v55_n = ((word32) arg1.u14[2] & 0xFF) + ~0x7F;
				if (v55_n > 0x3F == 0x00)
				{
					Eq_n v55_n = v55_n | v55_n << 0x06;
					if (v55_n < 0x00 == 0x00)
					{
						*v55_n.u3 = (int32) v55_n;
						goto l000DB6CC;
					}
					uint32 v55_n = ((word32) arg1.u14[3] & 0xFF) + ~0x7F;
					if (v55_n > 0x3F == 0x00)
					{
						*v55_n.u3 = (int32) (v55_n | v55_n << 0x06);
						goto l000DB6CC;
					}
				}
			}
		}
	}
l000DB6BA:
	*___errno_location().u3 = 0x54;
	goto l000DB6CB;
}

// 000DB6D6: Stack Eq_n _fflush(Stack Eq_n arg0)
// Called from:
//      _fflush
//      fn000E7E11
//      fn000E82AE
Eq_n _fflush(Eq_n arg0)
{
	if (arg0 != 0x00)
	{
		if (arg0.u15[38] > ~0x00 != 0x00)
		{
			Eq_n v41_n = fn000D61F1(arg0);
			fn000DB84B(arg0);
			if (v41_n != 0x00)
				fn000D1351(arg0);
			return <invalid>;
		}
		else
		{
			fn000DB84B(arg0);
			return <invalid>;
		}
	}
	else
	{
		if (g_t0C70.u2 != 0x00)
			_fflush(g_t0C70.u2);
		___lock(0x4640);
		Eq_n v41_n = *(union Eq_n *) 0x463C;
		if (v41_n != 0x00)
		{
			Eq_n loc4_n = v41_n;
			while (true)
			{
				Eq_n loc25_n;
				if (loc4_n.u15[38] > ~0x00)
					loc25_n = fn000D61F1(loc4_n);
				else
					loc25_n.u0 = 0x00;
				if (loc4_n.u15[0x0A] > (loc4_n.u18)->dw001C)
					fn000DB84B(loc4_n);
				if (loc25_n == 0x00 == 0x00)
					fn000D1351(loc4_n);
				Eq_n v41_n;
				v41_n.u2 = loc4_n.u15[28];
				if (v41_n == 0x00)
					break;
				loc4_n = v41_n;
			}
		}
		___unlock(0x4640);
		return <invalid>;
	}
}

// 000DB84B: Stack Eq_n fn000DB84B(Stack Eq_n arg0)
// Called from:
//      _fflush
Eq_n fn000DB84B(Eq_n arg0)
{
	word32 loc22;
	if (arg0.u15[0x0A] > (arg0.u18)->dw001C)
	{
		if (arg0.u15[0x0A] != 0x00)
			loc22 = 0x03;
	}
	else
		loc22 = 0x03;
	if (loc22 == 0x03)
	{
		arg0.u17[4] = (struct Eq_n) 0x00;
		arg0.u18->dw001C = (ui32) 0x00;
		arg0.u15[0x0A] = (struct Eq_n) 0x00;
		arg0.u15[4] = (struct Eq_n) 0x00;
		arg0.u15[2] = (struct Eq_n) 0x00;
	}
	return <invalid>;
}

// 000DB950: Stack Eq_n fn000DB950(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn001071CE
//      fn0010C171
Eq_n fn000DB950(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v7_n;
	v7_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	*v7_n.u3 = (int32) arg2;
	Eq_n v7_n = fn000DB988(arg0, arg1, v7_n);
	g_t140030.u2 = (int8 *) v7_n;
	return <invalid>;
}

// 000DB988: Stack Eq_n fn000DB988(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000DB950
//      fn000EAD98
Eq_n fn000DB988(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v11_n;
	v11_n.u2 = g_t140030.u2;
	g_t140030.u2 += 112;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x70);
	*v11_n.u4 = 0x00;
	v11_n.u15[4] = (struct Eq_n) 0x00;
	v11_n.u17[4] = (struct Eq_n) 0x00;
	v11_n.u15[0x0C] = (struct Eq_n) 0x00;
	v11_n.u15[16] = (struct Eq_n) 0x00;
	v11_n.u15[20] = (struct Eq_n) 0x00;
	v11_n.u15[24] = (struct Eq_n) 0x00;
	v11_n.u15[28] = (struct Eq_n) 0x00;
	v11_n.u15[32] = (struct Eq_n) 0x00;
	((word32) v11_n + 72)->u0 = 0x00;
	((word32) v11_n + 80)->u0 = 0x00;
	((word32) v11_n + 88)->u0 = 0x00;
	((word32) v11_n + 96)->u0 = 0x00;
	v11_n.u15[52] = (struct Eq_n) 0x00;
	v11_n.u15[16] = (struct Eq_n) 0x0170;
	v11_n.u15[22] = (struct Eq_n) arg0;
	v11_n.u15[38] = (struct Eq_n) ~0x00;
	*((word32) v11_n + 84) = arg0;
	Eq_n v11_n = fn000DBA9B(v11_n, arg1, arg2);
	g_t140030.u2 = (int8 *) v11_n;
	return <invalid>;
}

// 000DBA85: Stack Eq_n fn000DBA85(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
Eq_n fn000DBA85(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	return <invalid>;
}

// 000DBA9B: Stack Eq_n fn000DBA9B(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000DB988
Eq_n fn000DBA9B(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n loc72;
	ui32 loc29;
	Eq_n loc70;
	Eq_n loc69;
	Eq_n loc67;
	ui32 loc37;
	Eq_n loc73;
	Eq_n loc26;
	Eq_n v443_n;
	v443_n.u2 = g_t140030.u2;
	g_t140030.u2 += 304;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x0130);
	Eq_n loc330_n;
	if (arg0.u15[38] > ~0x00)
		loc330_n = fn000D61F1(arg0);
	else
		loc330_n.u0 = 0x00;
	int8 v446_n = *arg1.u2;
	ui32 v443_n = (word32) v446_n;
	int32 v443_n = (int32) v446_n;
	if (v443_n == 0x00)
	{
l000DD583:
		goto l000DD584;
	}
	Eq_n loc12_n = arg1;
	Eq_n loc17_n;
	loc17_n.u0 = 0x00;
	ui32 loc20_n = 0x00;
	Eq_n loc23_n;
	loc23_n.u0 = 0x00;
	Eq_n loc24_n;
	loc24_n.u0 = 0x00;
	ui32 loc252_n = v443_n;
	while (true)
	{
		Eq_n loc26_n = loc26;
		Eq_n loc73_n = loc73;
		ui32 loc37_n = loc37;
		Eq_n loc67_n = loc67;
		Eq_n loc69_n = loc69;
		Eq_n v443_n = fn000D2665(loc252_n & 0xFF);
		Eq_n loc27_n;
		ui32 loc34_n;
		Eq_n loc42_n;
		Eq_n loc63_n;
		Eq_n loc66_n;
		if (v443_n == 0x00)
		{
			Eq_n v445_n = (int32) (byte) loc252_n == 0x25;
			ui32 loc10;
			word32 loc437;
			if (v445_n)
			{
				Eq_n v443_n;
				v443_n.u2 = loc12_n + 0x01;
				int8 v447_n = *v443_n.u2;
				ui32 v443_n = (word32) v447_n;
				switch ((int32) v447_n)
				{
				case 0x25:
					break;
				case 0x26:
					Mem612 = Mem415;
					Eq_n loc22_n;
					loc22_n.u0 = 0x00;
					Eq_n loc38_n;
					loc38_n.u2 = loc12_n + 0x02;
					goto l000DBDD0;
				case 0x27:
				case 0x28:
				case 0x29:
				case 0x2A:
					Mem446 = Mem415;
					uint32 v443_n = (v443_n & 0xFF) + ~0x2F;
					if (v443_n < 0x0A && (int32) (loc12_n.u14)[2] == 0x24)
					{
						v443_n.u17[4] = (struct Eq_n) *arg2.u3;
						uint32 loc6_n = v443_n;
						Eq_n v443_n;
						while (true)
						{
							union Eq_n * v443_n = v443_n.u17[4].b0003 & ~0x03;
							v443_n.u2 = v443_n->u2;
							v443_n.u17[4] = (struct Eq_n) ((char *) v443_n + 4);
							uint32 v443_n = loc6_n + ~0x00;
							if (loc6_n <= 0x01)
								break;
							loc6_n = v443_n;
						}
						loc22_n = v443_n;
						loc38_n.u2 = loc12_n + 0x03;
					}
					else
					{
						union Eq_n * v443_n = *arg2.u3 + 0x03 & ~0x03;
						Eq_n v443_n;
						v443_n.u2 = v443_n->u2;
						*arg2.u3 = (char *) v443_n + 4;
						loc22_n = v443_n;
						loc38_n = v443_n;
l000DBDD0:
					}
					ui32 v443_n = (word32) *loc38_n.u2;
					Eq_n loc7_n;
					Eq_n loc46_n;
					ui32 loc74_n;
					if ((v443_n & 0xFF) < 0x3A)
					{
						Eq_n loc8_n;
						loc8_n.u0 = 0x00;
						Eq_n loc54_n = loc38_n;
						ui32 loc89_n = v443_n & 0xFF;
						Eq_n v443_n;
						ui32 v443_n;
						Eq_n v443_n;
						while (true)
						{
							v443_n.u2 = loc54_n + 0x01;
							v443_n = (word32) *v443_n.u2;
							v443_n = loc8_n * 0x0A + ~0x2F + loc89_n;
							if ((v443_n & 0xFF) >= 0x3A)
								break;
							loc8_n = v443_n;
							loc54_n = v443_n;
							loc89_n = v443_n & 0xFF;
						}
						loc7_n = v443_n;
						loc46_n = v443_n;
						loc74_n = v443_n;
					}
					else
					{
						loc7_n.u0 = 0x00;
						loc46_n = loc38_n;
						loc74_n = v443_n;
					}
					ui32 loc10_n;
					Eq_n loc35_n;
					Eq_n loc36_n;
					Eq_n loc55_n;
					ui32 loc98_n;
					if ((int32) (byte) loc74_n == 0x6D)
					{
						Eq_n v443_n;
						v443_n.u2 = loc46_n + 0x01;
						loc10_n = loc22_n != 0x00 & 0x01;
						loc35_n.u0 = 0x00;
						loc36_n.u0 = 0x00;
						loc55_n = v443_n;
						loc98_n = (word32) *v443_n.u2;
					}
					else
					{
						loc10_n = 0x00;
						loc35_n = loc23_n;
						loc36_n = loc24_n;
						loc55_n = loc46_n;
						loc98_n = loc74_n;
					}
					Eq_n v443_n;
					v443_n.u2 = loc55_n + 0x01;
					Eq_n loc9_n;
					Eq_n loc58_n;
					switch ((int32) (byte) loc98_n)
					{
					case 0x41:
						int32 v443_n = (int32) *v443_n.u2;
						Eq_n v443_n;
						v443_n.u2 = loc55_n + 0x02;
						Eq_n v443_n;
						if (v443_n == 0x68)
							v443_n = v443_n;
						else
							v443_n = v443_n;
						Eq_n v443_n;
						if (v443_n == 0x68)
							v443_n.u0 = ~0x01;
						else
							v443_n.u0 = ~0x00;
						loc9_n = v443_n;
						loc58_n = v443_n;
						break;
					case 66:
						int32 v443_n = (int32) *v443_n.u2;
						Eq_n v443_n;
						v443_n.u2 = loc55_n + 0x02;
						Eq_n v443_n;
						if (v443_n == 0x6C)
							v443_n = v443_n;
						else
							v443_n = v443_n;
						Eq_n v443_n;
						if (v443_n == 0x6C)
							v443_n.u0 = 0x03;
						else
							v443_n.u0 = 0x01;
						loc9_n = v443_n;
						loc58_n = v443_n;
						break;
					case 0x43:
						loc9_n.u0 = 0x03;
						loc58_n = v443_n;
						break;
					case 0x44:
						goto l000DBFF9;
					case 0x45:
l000DBFF9:
						loc9_n.u0 = 0x01;
						loc58_n = v443_n;
						break;
					case 0x46:
						loc9_n.u0 = 0x02;
						loc58_n = v443_n;
						break;
					case 0x47:
						goto l000DC017;
					case 0x48:
l000DC017:
						goto l000DC019;
					case 0x49:
l000DC019:
						goto l000DC01B;
					case 0x4A:
l000DC01B:
						goto l000DC01D;
					case 0x4B:
l000DC01D:
						goto l000DC01F;
					case 0x4C:
l000DC01F:
						goto l000DC021;
					case 77:
l000DC021:
						goto l000DC023;
					case 0x4E:
l000DC023:
						goto l000DC025;
					case 0x4F:
l000DC025:
						goto l000DC027;
					case 0x50:
l000DC027:
						goto l000DC029;
					case 0x51:
l000DC029:
						goto l000DC02B;
					case 0x52:
l000DC02B:
						goto l000DC02D;
					case 0x53:
l000DC02D:
						goto l000DC02F;
					case 0x54:
l000DC02F:
						goto l000DC031;
					case 0x55:
l000DC031:
						goto l000DC033;
					case 0x56:
l000DC033:
						goto l000DC035;
					case 0x57:
l000DC035:
						goto l000DC037;
					case 88:
l000DC037:
						goto l000DC039;
					case 0x59:
l000DC039:
						goto l000DC03B;
					case 0x5A:
l000DC03B:
						goto l000DC03D;
					case 0x5B:
l000DC03D:
						loc9_n.u0 = 0x00;
						loc58_n = loc55_n;
						break;
					case 0x5C:
					case 0x5D:
					case 0x5E:
					case 0x5F:
					case 0x60:
					case 0x61:
					case 0x62:
					case 99:
					case 100:
					case 101:
					case 0x66:
					case 0x67:
					case 0x68:
					case 0x69:
					case 0x6A:
					case 0x6B:
					case 0x6C:
					case 0x6D:
					case 110:
					case 111:
					case 0x70:
					case 113:
					case 114:
					case 115:
					case 116:
					case 117:
					case 118:
					case 0x77:
					case 0x78:
					case 121:
					case 122:
						loc26_n = loc26;
						loc73_n = loc73;
						loc37_n = loc37;
						Mem4250 = Mem610;
						loc10 = loc10_n;
						loc67_n = loc36_n;
						loc69_n = loc35_n;
						loc437 = 0x9A;
						goto l000DD495;
					}
					Mem884 = Mem610;
					ui32 v443_n = (word32) *loc58_n.u2;
					bool v445_n = (v443_n & 0x2F) == 0x03;
					ui32 v443_n = v443_n & 0xFF | 0x20;
					ui32 v443_n;
					if (v445_n)
						v443_n = v443_n;
					else
						v443_n = v443_n & 0xFF;
					Eq_n v443_n;
					if (v445_n)
						v443_n.u0 = 0x01;
					else
						v443_n = loc9_n;
					ui32 v443_n = v443_n & 0xFF;
					Eq_n loc28_n;
					Eq_n loc33_n;
					switch ((int32) (byte) v443_n)
					{
					case 0x5B:
						Eq_n v443_n;
						if (loc7_n < 0x01)
							v443_n.u0 = 0x01;
						else
							v443_n = loc7_n;
						loc28_n = v443_n;
						loc33_n = loc17_n;
						break;
					case 0x5C:
						Mem1243 = Mem610;
						loc28_n = loc7_n;
						loc33_n = loc17_n;
						break;
					case 0x5D:
						loc10 = loc10_n;
						Mem3885 = Mem610;
						Eq_n v455_n;
						v455_n.u2 = (int64) loc17_n;
						if (loc22_n == 0x00)
						{
							loc27_n = loc58_n;
							loc34_n = loc20_n;
							loc42_n = loc17_n;
							loc63_n = loc36_n;
							loc66_n = loc35_n;
						}
						else
						{
							switch (v443_n)
							{
							case ~0x01:
								*loc22_n.u2 = (int8) (byte) loc17_n;
								loc27_n = loc58_n;
								loc34_n = loc20_n;
								loc42_n = loc17_n;
								loc63_n = loc36_n;
								loc66_n = loc35_n;
								break;
							case ~0x00:
								loc22_n.u14->t0000.u6.u1 = (int16) (word16) loc17_n;
								loc10 = loc10_n;
								loc27_n = loc58_n;
								loc34_n = loc20_n;
								loc42_n = loc17_n;
								loc63_n = loc36_n;
								loc66_n = loc35_n;
								break;
							case 0x00:
								*loc22_n.u3 = (int32) loc17_n;
								loc10 = loc10_n;
								loc27_n = loc58_n;
								loc34_n = loc20_n;
								loc42_n = loc17_n;
								loc63_n = loc36_n;
								loc66_n = loc35_n;
								break;
							case 0x01:
								*loc22_n.u3 = (int32) loc17_n;
								loc10 = loc10_n;
								loc27_n = loc58_n;
								loc34_n = loc20_n;
								loc42_n = loc17_n;
								loc63_n = loc36_n;
								loc66_n = loc35_n;
								break;
							case 0x02:
								*loc22_n.u4 = (real64) v455_n;
								loc10 = loc10_n;
								loc27_n = loc58_n;
								loc34_n = loc20_n;
								loc42_n = loc17_n;
								loc63_n = loc36_n;
								loc66_n = loc35_n;
								break;
							case 0x03:
								loc10 = loc10_n;
								Mem3886 = Mem610;
								loc27_n = loc58_n;
								loc34_n = loc20_n;
								loc42_n = loc17_n;
								loc63_n = loc36_n;
								loc66_n = loc35_n;
								break;
							}
						}
						goto l000DD44A;
					case 0x5E:
					case 0x5F:
					case 0x60:
					case 0x61:
					case 0x62:
					case 99:
					case 100:
					case 101:
					case 0x66:
					case 0x67:
					case 0x68:
					case 0x69:
					case 0x6A:
					case 0x6B:
					case 0x6C:
					case 0x6D:
					case 110:
						fn000D1767(arg0, 0x00);
						Mem5891 = Mem610;
						Eq_n loc124_n;
						do
						{
							Eq_n v443_n;
							v443_n.u2 = arg0.u15[2];
							if (v443_n < (arg0.u15)[50])
							{
								arg0.u15[2] = (struct Eq_n) (v443_n.u14 + 1);
								loc124_n = (word32) *v443_n.u2 & 0xFF;
							}
							else
								loc124_n = fn000D2493(arg0);
						} while (fn000D2665(loc124_n) != 0x00);
						Eq_n loc137_n;
						if (arg0.u15[50] == 0x00)
							loc137_n.u2 = arg0.u15[2];
						else
						{
							Eq_n v443_n;
							v443_n.u2 = arg0.u15[2];
							arg0.u15[2] = (struct Eq_n) &v443_n.u15->bFFFFFFFF;
							loc137_n.u2 = &v443_n.u15->bFFFFFFFF;
						}
						loc28_n = loc7_n;
						loc33_n = loc137_n.u2 + ((arg0.u15)[54] + loc17_n) - (arg0.u15)[4];
						break;
					}
					fn000D1767(arg0, loc28_n);
					Eq_n v443_n;
					v443_n.u2 = arg0.u15[2];
					Eq_n v443_n;
					v443_n.u2 = arg0.u15[50];
					loc26_n = loc26;
					loc73_n = loc73;
					loc37_n = loc37;
					loc10 = loc10_n;
					Eq_n loc147_n;
					if (v443_n < v443_n)
					{
						arg0.u15[2] = (struct Eq_n) (v443_n.u14 + 1);
						loc147_n = v443_n;
					}
					else
					{
						if (fn000D2493(arg0) < 0x00)
						{
							loc67_n = loc36_n;
							loc69_n = loc35_n;
							loc437 = 0x9A;
							goto l000DD495;
						}
						loc147_n.u2 = arg0.u15[50];
					}
					if (loc147_n == 0x00 == 0x00)
						arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
					int32 * loc11_n;
					int32 * loc11;
					Eq_n loc25;
					Eq_n loc60;
					Eq_n loc62;
					switch ((int32) (byte) v443_n)
					{
					case 0x41:
						goto l000DC42E;
					case 66:
l000DC42E:
						goto l000DC430;
					case 0x43:
l000DC430:
						bool v445_n = v443_n == 99;
						ui32 v443_n = v443_n | 0x10;
						Eq_n loc71_n;
						if (v443_n != 115)
						{
							Eq_n v443_n;
							v443_n.u2 = loc58_n + 0x01;
							int32 v443_n = (int32) *v443_n.u2;
							Eq_n v443_n;
							v443_n.u2 = loc58_n + 0x02;
							ui32 v443_n = v443_n == 0x5E & 0x01;
							Eq_n v443_n;
							if (v443_n == 0x5E)
								v443_n = v443_n;
							else
								v443_n = v443_n;
							_memset((word32) v443_n + 0x0022, v443_n == 0x5E & 0x01, 0x0100);
							((word32) v443_n + 33)->u2 = 0x00;
							int8 v466_n = *v443_n.u2;
							Eq_n loc65_n;
							ui32 loc78_n;
							switch ((int32) v466_n)
							{
							case 0x2D:
								ui32 v443_n = (v443_n ^ 0x01) & 0xFF;
								v443_n.u14[79] = (struct Eq_n) (byte) v443_n;
								loc65_n.u2 = v443_n + 0x01;
								loc78_n = v443_n;
								break;
							case 0x2E:
								ui32 v443_n = (v443_n ^ 0x01) & 0xFF;
								v443_n.u14[0x007F] = (struct Eq_n) (byte) v443_n;
								loc65_n.u2 = v443_n + 0x01;
								loc78_n = v443_n;
								break;
							case 0x2F:
							case 0x30:
							case 0x31:
							case 0x32:
							case 0x33:
							case 0x34:
							case 0x35:
							case 0x36:
							case 55:
							case 0x38:
							case 0x39:
							case 0x3A:
							case 0x3B:
							case 0x3C:
							case 0x3D:
							case 0x3E:
							case 0x3F:
							case 0x40:
							case 0x41:
							case 66:
							case 0x43:
							case 0x44:
							case 0x45:
							case 0x46:
							case 0x47:
							case 0x48:
							case 0x49:
							case 0x4A:
							case 0x4B:
							case 0x4C:
							case 77:
							case 0x4E:
							case 0x4F:
							case 0x50:
							case 0x51:
							case 0x52:
							case 0x53:
							case 0x54:
							case 0x55:
							case 0x56:
							case 0x57:
							case 88:
							case 0x59:
							case 0x5A:
							case 0x5B:
							case 0x5C:
							case 0x5D:
								Mem6478 = Mem1744;
								loc65_n = v443_n;
								loc78_n = (v443_n ^ 0x01) & 0xFF;
								break;
							}
							Eq_n loc64_n = loc65_n;
							while (true)
							{
								int8 v469_n = *loc64_n.u2;
								loc26_n = loc26;
								loc73_n = loc73;
								loc37_n = loc37;
								loc10 = loc10_n;
								ui32 v443_n = (word32) v469_n;
								ui32 loc182_n;
								Eq_n loc68_n;
								switch ((int32) v469_n)
								{
								case 0:
									loc67_n = loc36_n;
									loc69_n = loc35_n;
									loc437 = 0x9A;
									goto l000DD495;
								case 1:
									Mem4253 = Mem1835;
									loc71_n = loc64_n;
									goto l000DC7FA;
								case 2:
									Eq_n v443_n;
									v443_n.u2 = loc64_n + 0x01;
									int8 v470_n = *v443_n.u2;
									ui32 v443_n = (word32) v470_n;
									switch ((int32) v470_n)
									{
									case 0:
										break;
									case 1:
										break;
									case 2:
									case 3:
									case 4:
									case 5:
									case 6:
									case 7:
									case 8:
									case 9:
									case 0x0A:
									case 11:
									case 0x0C:
									case 0x0D:
									case 0x0E:
									case 0x0F:
									case 16:
									case 0x0011:
									case 18:
									case 19:
									case 20:
									case 21:
									case 22:
									case 23:
									case 24:
									case 25:
									case 26:
									case 27:
									case 28:
									case 29:
									case 30:
									case 31:
									case 32:
									case 33:
									case 0x0022:
									case 35:
									case 36:
									case 37:
									case 38:
									case 39:
									case 40:
									case 41:
									case 42:
									case 43:
									case 44:
									case 45:
									case 46:
									case 47:
									case 48:
									case 49:
									case 50:
									case 0x0033:
									case 52:
									case 53:
									case 54:
									case 55:
									case 56:
									case 57:
									case 58:
									case 59:
									case 60:
									case 61:
									case 62:
									case 63:
									case 64:
									case 65:
									case 66:
									case 67:
									case 0x0044:
									case 69:
									case 70:
									case 71:
									case 72:
									case 73:
									case 74:
									case 75:
									case 76:
									case 77:
									case 78:
									case 79:
									case 80:
									case 81:
									case 82:
									case 83:
									case 84:
									case 0x0055:
									case 86:
									case 87:
									case 88:
									case 89:
									case 90:
									case 91:
									case 92:
									case 93:
										Mem1875 = Mem1835;
										ui32 v443_n = (word32) loc64_n.u15->bFFFFFFFF;
										if ((v443_n & 0xFF) < (v443_n & 0xFF))
										{
											int32 loc18_n = v443_n & 0xFF;
											ui32 v443_n;
											while (true)
											{
												int32 v443_n = loc18_n + 0x01;
												(v443_n.u14 + 33)[v443_n] = (struct Eq_n) (byte) loc78_n;
												v443_n = (word32) *v443_n.u2;
												if (v443_n >= (v443_n & 0xFF))
													break;
												loc18_n = v443_n;
											}
											loc182_n = v443_n;
										}
										else
											loc182_n = v443_n;
										loc68_n = v443_n;
										goto l000DC7C2;
									}
									loc68_n = loc64_n;
									loc182_n = 0x2D;
									break;
								case 3:
								case 4:
								case 5:
								case 6:
								case 7:
								case 8:
								case 9:
								case 0x0A:
								case 11:
								case 0x0C:
								case 0x0D:
								case 0x0E:
								case 0x0F:
								case 16:
								case 0x0011:
								case 18:
								case 19:
								case 20:
								case 21:
								case 22:
								case 23:
								case 24:
								case 25:
								case 26:
								case 27:
								case 28:
								case 29:
								case 30:
								case 31:
								case 32:
								case 33:
								case 0x0022:
								case 35:
								case 36:
								case 37:
								case 38:
								case 39:
								case 40:
								case 41:
								case 42:
								case 43:
								case 44:
								case 45:
								case 46:
								case 47:
								case 48:
								case 49:
								case 50:
								case 0x0033:
								case 52:
								case 53:
								case 54:
								case 55:
								case 56:
								case 57:
								case 58:
								case 59:
								case 60:
								case 61:
								case 62:
								case 63:
								case 64:
								case 65:
								case 66:
								case 67:
								case 0x0044:
								case 69:
								case 70:
								case 71:
								case 72:
								case 73:
								case 74:
								case 75:
								case 76:
								case 77:
								case 78:
								case 79:
								case 80:
								case 81:
								case 82:
								case 83:
								case 84:
								case 0x0055:
								case 86:
								case 87:
								case 88:
								case 89:
								case 90:
								case 91:
								case 92:
								case 93:
									loc68_n = loc64_n;
									loc182_n = v443_n;
l000DC7C2:
									break;
								}
								(v443_n.u14 + 33)[(loc182_n & 0xFF) + 0x01] = (struct Eq_n) (byte) loc78_n;
								loc64_n.u2 = loc68_n + 0x01;
							}
						}
						_memset((word32) v443_n + 0x0022, ~0x00, 0x0100);
						((word32) v443_n + 33)->u2 = 0x00;
						if (v443_n == 115)
						{
							v443_n.u14[66] = (struct Eq_n) 0x00;
							v443_n.u14[43] = (struct Eq_n) 0x00;
							v443_n.u14[47] = (struct Eq_n) 0x00;
						}
						loc71_n = loc58_n;
l000DC7FA:
						loc26_n = loc26;
						loc73_n = loc73;
						loc37_n = loc37;
						loc10 = loc10_n;
						Eq_n v443_n;
						v443_n.u14 = loc28_n.u14 + 1;
						Eq_n v443_n;
						if (v445_n)
							v443_n = v443_n;
						else
							v443_n.u0 = 0x1F;
						bool v445_n = v443_n == 0x01;
						bool v445_n = loc10_n != 0x00;
						Eq_n loc56_n;
						Eq_n loc59_n;
						Eq_n loc57_n;
						if (v445_n)
						{
							Eq_n loc44_n;
							if (v445_n)
							{
								Eq_n v443_n = _malloc(v443_n << 0x02);
								if (v443_n == 0x00)
								{
									loc67_n.u0 = 0x00;
									loc69_n = v443_n;
									loc437 = 0x9A;
									goto l000DD495;
								}
								loc44_n = v443_n;
							}
							else
								loc44_n = loc22_n;
							v443_n.u15[4] = (struct Eq_n) 0x00;
							v443_n.u17[3] = (struct Eq_n) 0x00;
							Mem6798 = Mem2540;
l000DC89E:
							Eq_n v443_n;
							v443_n.u2 = arg0.u15[2];
							loc26_n = loc26;
							loc73_n = loc73;
							loc37_n = loc37;
							loc10 = loc10_n;
							Eq_n loc204_n;
							if (v443_n < (arg0.u15)[50])
							{
								arg0.u15[2] = (struct Eq_n) (v443_n.u14 + 1);
								loc204_n = (word32) *v443_n.u2 & 0xFF;
							}
							else
								loc204_n = fn000D2493(arg0);
							if ((int32) *(v443_n.u14 + 33 + (loc204_n.u14 + 1)) != 0x00)
							{
								v443_n.u15[16] = (struct Eq_n) (byte) loc204_n;
								Eq_n v443_n = fn000DB07F(v443_n, v443_n.u15 + 16, 0x01, v443_n.u15 + 4);
								switch (v443_n)
								{
								case ~0x01:
									loc67_n.u0 = 0x00;
									loc69_n = loc44_n;
									loc437 = 0x9A;
									break;
								case ~0x00:
									Mem6800 = Mem2628;
									goto l000DC89E;
								}
								goto l000DD495;
							}
							if (fn000DD5A3(v443_n.u15 + 4) == 0x00)
							{
								loc67_n.u0 = 0x00;
								loc69_n = loc44_n;
								loc437 = 0x9A;
								goto l000DD495;
							}
							loc56_n.u0 = 0x00;
							loc59_n = loc44_n;
							loc57_n.u0 = 0x00;
							Mem2675 = Mem2606;
						}
						else if (v445_n)
						{
							Eq_n v443_n = _malloc(v443_n);
							if (v443_n == 0x00)
							{
								loc67_n.u0 = 0x00;
								loc69_n.u0 = 0x00;
								loc437 = 0x9A;
								goto l000DD495;
							}
							Eq_n loc31_n = v443_n;
							Eq_n loc40_n;
							loc40_n.u0 = 0x00;
							Eq_n loc45_n = v443_n;
l000DCAAD:
							Eq_n loc39_n = loc40_n;
							while (true)
							{
								Eq_n v443_n;
								v443_n.u2 = arg0.u15[2];
								Eq_n loc233_n;
								if (v443_n < (arg0.u15)[50])
								{
									arg0.u15[2] = (struct Eq_n) (v443_n.u14 + 1);
									loc233_n = (word32) *v443_n.u2 & 0xFF;
								}
								else
									loc233_n = fn000D2493(arg0);
								if ((int32) *(v443_n.u14 + 33 + (loc233_n.u14 + 1)) == 0x00)
									break;
								*(loc45_n + loc39_n) = (word32) (byte) loc233_n;
								Eq_n v443_n;
								v443_n.u14 = loc39_n.u14 + 1;
								if (v443_n == loc31_n)
								{
									ui32 v443_n = loc31_n << 0x01;
									Eq_n v443_n = fn000E3E00(loc45_n, v443_n | 0x01);
									if (v443_n != 0x00)
									{
										loc31_n = v443_n | 0x01;
										loc45_n = v443_n;
										loc40_n = loc31_n;
										goto l000DCAAD;
									}
									else
									{
										loc67_n = loc45_n;
										loc69_n.u0 = 0x00;
										loc437 = 0x9A;
										goto l000DD495;
									}
								}
								loc39_n = v443_n;
							}
							loc56_n = loc39_n;
							loc57_n = loc45_n;
							loc59_n.u0 = 0x00;
						}
						else if (loc22_n == 0x00)
						{
							Eq_n loc265_n = loc147_n;
							while (true)
							{
								Eq_n v443_n;
								v443_n.u2 = arg0.u15[2];
								Eq_n loc271_n;
								if (v443_n < loc265_n)
								{
									arg0.u15[2] = (struct Eq_n) (v443_n.u14 + 1);
									loc271_n = (word32) *v443_n.u2 & 0xFF;
								}
								else
									loc271_n = fn000D2493(arg0);
								if ((int32) *(v443_n.u14 + 33 + (loc271_n.u14 + 1)) == 0x00)
									break;
								loc265_n.u2 = arg0.u15[50];
							}
							loc56_n.u0 = 0x00;
							loc57_n.u0 = 0x00;
							loc59_n.u0 = 0x00;
						}
						else
						{
							Eq_n loc51_n;
							loc51_n.u0 = 0x00;
							Eq_n loc248_n = loc147_n;
							while (true)
							{
								Eq_n v443_n;
								v443_n.u2 = arg0.u15[2];
								Eq_n loc255_n;
								if (v443_n < loc248_n)
								{
									arg0.u15[2] = (struct Eq_n) (v443_n.u14 + 1);
									loc255_n = (word32) *v443_n.u2 & 0xFF;
								}
								else
									loc255_n = fn000D2493(arg0);
								if ((int32) *(v443_n.u14 + 33 + (loc255_n.u14 + 1)) == 0x00)
									break;
								*(loc22_n + loc51_n) = (word32) (byte) loc255_n;
								++loc51_n.u14;
								loc248_n.u2 = arg0.u15[50];
							}
							loc56_n = loc51_n;
							loc57_n = loc22_n;
							loc59_n.u0 = 0x00;
						}
						loc67_n = loc67;
						loc69_n = loc69;
						loc10 = loc10_n;
						Eq_n loc284_n;
						if (arg0.u15[50] == 0x00)
							loc284_n.u2 = arg0.u15[2];
						else
						{
							Eq_n v443_n;
							v443_n.u2 = arg0.u15[2];
							arg0.u15[2] = (struct Eq_n) &v443_n.u15->bFFFFFFFF;
							loc284_n.u2 = &v443_n.u15->bFFFFFFFF;
						}
						Eq_n v443_n;
						v443_n.u2 = arg0.u15[54].a0000.u2.u2 + (loc284_n - (arg0.u15)[4]);
						if (v443_n == 0x00)
						{
							loc26_n = loc59_n;
							loc37_n = loc10_n;
							loc73_n = loc57_n;
							goto l000DD495;
						}
						if ((v443_n == loc28_n | v445_n ^ 0x01) == 0x00)
						{
							loc26_n = loc59_n;
							loc37_n = loc10_n;
							loc73_n = loc57_n;
							goto l000DD495;
						}
						if (v445_n)
						{
							if (v445_n)
								*loc22_n.u3 = (int32) loc59_n;
							else
								*loc22_n.u3 = (int32) loc57_n;
						}
						else
							Mem3072 = Mem2724;
						loc11_n = loc11;
						if (!v445_n)
						{
							if (loc59_n == 0x00 == 0x00)
								loc59_n.u3[loc56_n] = (int32) 0x00;
							if (loc57_n == 0x00)
							{
								loc25 = loc71_n;
								loc60.u0 = 0x00;
								loc62 = loc59_n;
								goto l000DD023;
							}
							*(loc57_n + loc56_n) = (word32) 0x00;
						}
						loc62 = loc59_n;
						loc60 = loc57_n;
						loc25 = loc71_n;
						break;
					case 0x44:
						goto l000DCEC9;
					case 0x45:
l000DCEC9:
						goto l000DCECB;
					case 0x46:
l000DCECB:
						Mem3076 = Mem1410;
						loc11_n = &g_dw0010;
						loc437 = 0x88;
						break;
					case 0x47:
						Mem3079 = Mem1410;
						loc11_n = (int32 *) &g_t0008;
						loc437 = 0x88;
						break;
					case 0x48:
						goto l000DCEED;
					case 0x49:
l000DCEED:
						Mem3080 = Mem1410;
						loc11_n = &g_dw000A;
						loc437 = 0x88;
						break;
					case 0x4A:
						Mem3082 = Mem1410;
						loc11_n = null;
						loc437 = 0x88;
						break;
					case 0x4B:
						goto l000DCF0F;
					case 0x4C:
l000DCF0F:
						goto l000DCF11;
					case 77:
l000DCF11:
						goto l000DCF13;
					case 0x4E:
l000DCF13:
						goto l000DCF15;
					case 0x4F:
l000DCF15:
						goto l000DCF17;
					case 0x50:
l000DCF17:
						goto l000DCF19;
					case 0x51:
l000DCF19:
						goto l000DCF1B;
					case 0x52:
l000DCF1B:
						Mem1409 = Mem1410;
						Eq_n v488_n = fn000D7B90(arg0, v443_n, 0x00);
						loc67_n = loc67;
						loc69_n = loc69;
						loc11_n = loc11;
						loc10 = loc10_n;
						if (arg0.u15[54] == (arg0.u15)[4] - (arg0.u15)[2])
						{
							loc26_n = loc35_n;
							loc37_n = loc10_n;
							loc73_n = loc36_n;
							goto l000DD495;
						}
						if (loc22_n != 0x00)
						{
							switch (v443_n)
							{
							case 0x00:
								loc22_n.u19->t0000.u0 = (real32) v488_n;
								loc25 = loc58_n;
								loc60 = loc36_n;
								loc62 = loc35_n;
								break;
							case 0x01:
								*loc22_n.u4 = (real64) v488_n;
								loc11_n = loc11;
								loc25 = loc58_n;
								loc60 = loc36_n;
								loc62 = loc35_n;
								break;
							case 0x02:
								*loc22_n.u4 = (real64) v488_n;
								loc11_n = loc11;
								loc25 = loc58_n;
								loc60 = loc36_n;
								loc62 = loc35_n;
								break;
							}
							goto l000DD023;
						}
						loc62 = loc35_n;
						loc60 = loc36_n;
						loc25 = loc58_n;
						Mem3083 = Mem1410;
						loc11_n = loc11;
						break;
					case 0x53:
					case 0x54:
					case 0x55:
					case 0x56:
					case 0x57:
					case 88:
					case 0x59:
					case 0x5A:
					case 0x5B:
					case 0x5C:
					case 0x5D:
					case 0x5E:
					case 0x5F:
					case 0x60:
					case 0x61:
					case 0x62:
					case 99:
					case 100:
					case 101:
					case 0x66:
					case 0x67:
					case 0x68:
					case 0x69:
					case 0x6A:
					case 0x6B:
					case 0x6C:
					case 0x6D:
					case 110:
					case 111:
					case 0x70:
					case 113:
					case 114:
					case 115:
					case 116:
					case 117:
					case 118:
					case 0x77:
					case 0x78:
						Mem3085 = Mem1410;
						loc11_n = loc11;
						loc25 = loc58_n;
						loc60 = loc36_n;
						loc62 = loc35_n;
						break;
					}
l000DD023:
					loc67_n = loc67;
					loc69_n = loc69;
					loc10 = loc10_n;
					if (loc437 == 0x88)
					{
						Eq_n v493_n = fn000D1804(arg0, loc11_n, null, ~0x00);
						loc437 = 0x00;
						if (arg0.u15[54] == (arg0.u15)[4] - (arg0.u15)[2])
						{
							loc26_n = loc35_n;
							loc37_n = loc10_n;
							loc73_n = loc36_n;
							goto l000DD495;
						}
						if (loc22_n != 0x00 & v443_n == 0x70)
						{
							*loc22_n.u3 = (int32) v493_n;
							loc25 = loc58_n;
							loc60 = loc36_n;
							loc62 = loc35_n;
							goto l000DD1C8;
						}
						if (loc22_n != 0x00)
						{
							switch (v443_n)
							{
							case ~0x01:
								*loc22_n.u2 = (int8) (byte) v493_n;
								loc25 = loc58_n;
								loc60 = loc36_n;
								loc62 = loc35_n;
								break;
							case ~0x00:
								loc22_n.u14->t0000.u6.u1 = (int16) (word16) v493_n;
								loc437 = 0x00;
								loc25 = loc58_n;
								loc60 = loc36_n;
								loc62 = loc35_n;
								break;
							case 0x00:
								*loc22_n.u3 = (int32) v493_n;
								loc437 = 0x00;
								loc25 = loc58_n;
								loc60 = loc36_n;
								loc62 = loc35_n;
								break;
							case 0x01:
								*loc22_n.u3 = (int32) v493_n;
								loc437 = 0x00;
								loc25 = loc58_n;
								loc60 = loc36_n;
								loc62 = loc35_n;
								break;
							case 0x02:
								*loc22_n.u4 = (real64) v493_n;
								loc437 = 0x00;
								loc25 = loc58_n;
								loc60 = loc36_n;
								loc62 = loc35_n;
								break;
							case 0x03:
								loc437 = 0x00;
								Mem3460 = Mem3069;
								loc25 = loc58_n;
								loc60 = loc36_n;
								loc62 = loc35_n;
								break;
							}
l000DD1C8:
							loc11 = loc11_n;
							loc10 = loc10_n;
							loc27_n = loc25;
							loc34_n = (loc22_n != 0x00 & 0x01) + loc20_n;
							loc42_n = arg0.u15[2].a0000.u2.u2 + ((arg0.u15)[54] + loc33_n) - (arg0.u15)[4];
							loc63_n = loc60;
							loc66_n = loc62;
							goto l000DD44A;
						}
						loc437 = 0x00;
						loc62 = loc35_n;
						loc60 = loc36_n;
						loc25 = loc58_n;
					}
					Mem3461 = Mem3069;
					goto l000DD1C8;
				}
			}
			fn000D1767(arg0, 0x00);
			Eq_n v443_n;
			v443_n.u2 = arg0.u15[2];
			Eq_n v443_n;
			v443_n.u2 = loc12_n + (v445_n & 0x01);
			Eq_n loc370;
			if (v443_n < (arg0.u15)[50])
			{
				arg0.u15[2] = (struct Eq_n) (v443_n.u14 + 1);
				loc370 = (word32) *v443_n.u2 & 0xFF;
			}
			else
				loc370 = fn000D2493(arg0);
			if (loc370 == ((word32) (*v443_n.u2) & 0xFF) == 0x00)
			{
				loc437 = 22;
l000DD495:
				Eq_n loc70_n = loc70;
				ui32 loc29_n = loc29;
				Eq_n loc72_n = loc72;
				if (loc437 == 22)
				{
					if (arg0.u15[50] == 0x00 == 0x00)
						arg0.u15[2] = (struct Eq_n) arg0.u15[2].bFFFFFFFF;
					if (loc20_n != 0x00 | loc370 > ~0x00)
						goto l000DD584;
					loc29_n = 0x00;
					loc70_n = loc24_n;
					loc72_n = loc23_n;
					loc437 = 155;
				}
				else if (loc437 == 0x9A)
				{
					if (loc20_n == 0x00)
					{
						loc29_n = loc10;
						loc70_n = loc67_n;
						loc72_n = loc69_n;
						loc437 = 155;
					}
					else
					{
						loc26_n = loc69_n;
						loc37_n = loc10;
						loc73_n = loc67_n;
					}
				}
				if (loc437 == 155)
				{
					loc26_n = loc72_n;
					loc37_n = loc29_n;
					loc73_n = loc70_n;
				}
				if (loc37_n != 0x00)
				{
					_free(loc73_n);
					_free(loc26_n);
				}
				goto l000DD583;
			}
			loc27_n = v443_n;
			loc42_n.u14 = loc17_n.u14 + 1;
		}
		else
		{
			Eq_n loc30_n = loc12_n;
			while (true)
			{
				Eq_n v443_n;
				v443_n.u2 = loc30_n + 0x01;
				if (fn000D2665((word32) *v443_n.u2 & 0xFF) == 0x00)
					break;
				loc30_n = v443_n;
			}
			fn000D1767(arg0, 0x00);
			Eq_n loc339_n;
			do
			{
				Eq_n v443_n;
				v443_n.u2 = arg0.u15[2];
				if (v443_n < (arg0.u15)[50])
				{
					arg0.u15[2] = (struct Eq_n) (v443_n.u14 + 1);
					loc339_n = (word32) *v443_n.u2 & 0xFF;
				}
				else
					loc339_n = fn000D2493(arg0);
			} while (fn000D2665(loc339_n) != 0x00);
			Eq_n loc352_n;
			if (arg0.u15[50] == 0x00)
				loc352_n.u2 = arg0.u15[2];
			else
			{
				Eq_n v443_n;
				v443_n.u2 = arg0.u15[2];
				arg0.u15[2] = (struct Eq_n) &v443_n.u15->bFFFFFFFF;
				loc352_n.u2 = &v443_n.u15->bFFFFFFFF;
			}
			loc27_n = loc30_n;
			loc42_n = loc352_n.u2 + ((arg0.u15)[54] + loc17_n) - (arg0.u15)[4];
		}
		loc63_n = loc24_n;
		loc66_n = loc23_n;
		loc34_n = loc20_n;
l000DD44A:
		Eq_n v443_n;
		v443_n.u2 = loc27_n + 0x01;
		int8 v500_n = *v443_n.u2;
		ui32 v443_n = (word32) v500_n;
		if ((int32) v500_n == 0x00)
		{
l000DD584:
			if (loc330_n == 0x00 == 0x00)
				fn000D1351(arg0);
			g_t140030.u2 = (int8 *) v443_n;
			return <invalid>;
		}
		loc12_n = v443_n;
		loc17_n = loc42_n;
		loc20_n = loc34_n;
		loc23_n = loc66_n;
		loc24_n = loc63_n;
		loc252_n = v443_n;
	}
}

// 000DD5A3: Stack Eq_n fn000DD5A3(Stack Eq_n arg0)
// Called from:
//      fn000DBA9B
Eq_n fn000DD5A3(Eq_n arg0)
{
	return <invalid>;
}

// 000DD5D8: Stack Eq_n fn000DD5D8(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000DBA85
Eq_n fn000DD5D8(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v20_n = *((word32) arg0 + 84);
	Eq_n v20_n = fn000D6AC0(v20_n, 0x00, (word32) arg2 + 0x0100);
	Eq_n v20_n = v20_n - v20_n;
	Eq_n v20_n;
	if (v20_n == 0x00)
		v20_n.u2 = (word32) arg2 + 0x0100;
	else
		v20_n = v20_n;
	Eq_n v20_n;
	if (v20_n < arg2)
		v20_n = v20_n;
	else
		v20_n = arg2;
	_memcpy(arg1, v20_n, v20_n);
	arg0.u15[2] = (struct Eq_n) (v20_n + v20_n);
	Eq_n v20_n;
	v20_n.u2 = v20_n + v20_n;
	arg0.u15[4] = (struct Eq_n) v20_n;
	*((word32) arg0 + 84) = v20_n;
	return <invalid>;
}

// 000DD675: Stack Eq_n fn000DD675(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
Eq_n fn000DD675(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	return <invalid>;
}

// 000DD6A2: Stack Eq_n fn000DD6A2(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3, Stack Eq_n arg4)
Eq_n fn000DD6A2(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3, Eq_n arg4)
{
	Eq_n v67_n;
	v67_n.u2 = g_t140030.u2;
	g_t140030.u2 += 1040;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x0410);
	Eq_n v67_n;
	v67_n.u2 = *arg1.u3;
	*v67_n.u3 = (int32) v67_n;
	Eq_n v67_n;
	if (arg0 != 0x00)
		v67_n = arg3;
	else
		v67_n.u0 = 0x0100;
	Eq_n v67_n;
	if (arg0 != 0x00)
		v67_n = arg0;
	else
		v67_n.u15 = v67_n.u15 + 4;
	ui32 v67_n = v67_n != 0x00 & v67_n != 0x00;
	Eq_n loc10_n;
	Eq_n loc14_n;
	Eq_n loc18_n;
	Eq_n loc41_n;
	if (v67_n)
	{
		Eq_n loc7_n = arg2;
		Eq_n loc9_n = v67_n;
		Eq_n loc11_n = v67_n;
		Eq_n loc59_n = v67_n;
		while (true)
		{
			Eq_n v67_n = loc7_n >> 0x02;
			Eq_n v69_n = v67_n >= loc9_n;
			if ((loc7_n > 131 | v69_n) == 0x00)
				break;
			Eq_n v67_n;
			if (v69_n)
				v67_n = loc9_n;
			else
				v67_n = v67_n;
			Eq_n v67_n = loc7_n - v67_n;
			Eq_n v67_n = fn000DD983(loc11_n, v67_n, v67_n, arg4);
			if (v67_n == ~0x00)
			{
				loc10_n = loc11_n;
				loc14_n = v67_n;
				loc18_n.u0 = 0x00;
				loc41_n.u2 = *v67_n.u3;
				goto l000DD84B;
			}
			bool v69_n = loc11_n == v67_n.u15 + 4;
			Eq_n v67_n;
			v67_n.u2 = loc11_n.u2 + (v67_n << 0x02);
			Eq_n v67_n;
			if (v69_n)
				v67_n.u0 = 0x00;
			else
				v67_n = v67_n;
			Eq_n v67_n = loc9_n - v67_n;
			Eq_n v67_n;
			if (v69_n)
				v67_n = loc11_n;
			else
				v67_n = v67_n;
			Eq_n v67_n;
			v67_n.u2 = *v67_n.u3;
			if (!(v67_n != 0x00 & v67_n != 0x00))
			{
				loc10_n = v67_n;
				loc14_n = v67_n;
				loc18_n = v67_n;
				loc41_n = v67_n;
				goto l000DD84C;
			}
			loc7_n = v67_n;
			loc9_n = v67_n;
			loc11_n = v67_n;
			loc59_n = v67_n;
		}
		loc10_n = loc11_n;
		loc14_n = loc7_n;
		loc18_n = loc9_n;
		loc41_n = loc59_n;
	}
	else
	{
		loc10_n = v67_n;
		loc14_n = arg2;
		loc18_n = v67_n;
		loc41_n = v67_n;
l000DD84B:
	}
l000DD84C:
	bool v69_n = loc41_n == 0x00;
	if (v69_n || !(loc18_n != 0x00 & loc14_n != 0x00))
		Mem413 = Mem35;
	else
	{
		Eq_n loc17_n = loc14_n;
		Eq_n loc19_n = loc10_n;
		Eq_n loc21_n = loc18_n;
		Eq_n loc45_n = loc41_n;
		Eq_n v67_n;
		while (true)
		{
			v67_n = fn000DB07F(loc19_n, loc45_n, loc17_n, arg4);
			if (v67_n < 0x01)
				break;
			Eq_n v67_n;
			v67_n.u2 = v67_n.u2 + *v67_n.u3;
			*v67_n.u3 = (int32) v67_n;
			Eq_n v67_n = loc17_n - v67_n;
			Eq_n v67_n;
			v67_n.u2 = &loc21_n.u15->bFFFFFFFF;
			Eq_n v67_n;
			v67_n.u15 = loc19_n.u15 + 2;
			if (!(v67_n != 0x00 & v67_n != 0x00))
				goto l000DD966;
			loc17_n = v67_n;
			loc19_n = v67_n;
			loc21_n = v67_n;
			loc45_n = v67_n;
		}
		switch (v67_n)
		{
		case ~0x00:
			break;
		case 0x00:
			*v67_n.u3 = (int32) 0x00;
			break;
		}
	}
l000DD966:
	if (arg0 != 0x00)
		*arg1.u3 = *v67_n.u3;
	g_t140030.u2 = (int8 *) v67_n;
	return <invalid>;
}

// 000DD983: Stack Eq_n fn000DD983(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3)
// Called from:
//      fn000DD6A2
Eq_n fn000DD983(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3)
{
	Eq_n v196_n;
	v196_n.u1 = *arg1.u3;
	word32 loc195_n;
	int32 loc17;
	Eq_n loc22;
	Eq_n loc23;
	int32 loc24;
	Eq_n loc40;
	Eq_n loc41;
	if (arg3 == 0x00)
		loc195_n = 0x05;
	else
	{
		int32 v196_n = *arg3.u3;
		if (v196_n == 0x00)
			loc195_n = 0x05;
		else if (arg0 == 0x00)
		{
			loc17 = v196_n;
			loc22 = v196_n;
			loc195_n = 0x11;
		}
		else
		{
			*arg3.u3 = 0x00;
			loc23 = arg0;
			loc24 = v196_n;
			loc40 = arg2;
			loc41 = v196_n;
			loc195_n = 0x26;
		}
	}
	Eq_n loc6;
	Eq_n loc7;
	Eq_n loc25;
	Eq_n loc34;
	if (loc195_n == 0x05)
	{
		if (arg0 == 0x00)
		{
			loc6 = v196_n;
			loc195_n = 0x07;
		}
		else
		{
			loc7 = arg0;
			loc25 = arg2;
			loc34 = v196_n;
			loc195_n = 0x06;
		}
	}
	word32 loc195_n;
	Eq_n loc33;
	Eq_n loc13;
	Eq_n loc30;
	while (true)
	{
l000DDA3D:
		if (loc195_n == 0x06)
			break;
		if (loc195_n != 0x07)
		{
			if (loc195_n == 0x11)
			{
				uint32 v196_n = ((word32) loc22.u2->t0000.u0 & 0xFF) >> 0x03;
				if ((v196_n + ~0x0F | v196_n + (loc17 >> 0x1A)) > 0x07)
				{
					loc195_n = 0x12;
					goto l000DE16D;
				}
				Eq_n v196_n;
				v196_n.u2 = loc22.u2 + 1;
				Eq_n loc27_n;
				if ((loc17 & 0x02000000) == 0x00)
				{
					loc27_n = v196_n;
					goto l000DE006;
				}
				if ((int32) (v196_n.u2->t0000.u0 & 0xC0) == ~0x7F == 0x00)
				{
					loc195_n = 0x15;
					goto l000DE16D;
				}
				Eq_n v196_n;
				v196_n.u2 = loc22.u2 + 2;
				if ((loc17 & 0x00080000) == 0x00)
				{
					loc27_n = v196_n;
					goto l000DE005;
				}
				if ((int32) (v196_n.u2->t0000.u0 & 0xC0) == ~0x7F != 0x00)
				{
					loc27_n.u2 = loc22.u2 + 3;
l000DE006:
					loc6 = loc27_n;
					loc195_n = 0x07;
					continue;
				}
				loc195_n = 0x18;
				goto l000DE16D;
			}
			if (loc195_n != 0x26)
				continue;
			ui32 v196_n = (word32) loc41.u2->t0000.u0;
			uint32 v196_n = (v196_n & 0xFF) >> 0x03;
			if ((v196_n + ~0x0F | v196_n + (loc24 >> 0x1A)) > 0x07)
			{
				loc195_n = 0x27;
				goto l000DE16D;
			}
			Eq_n v196_n;
			v196_n.u2 = loc41.u2 + 1;
			int32 v196_n = (v196_n & 0xFF) + ~0x7F | loc24 << 0x06;
			int32 loc31_n;
			Eq_n loc44_n;
			if (v196_n >= 0x00)
			{
				loc31_n = v196_n;
				loc44_n = v196_n;
				goto l000DE13E;
			}
			uint32 v196_n = ((word32) v196_n.u2->t0000.u0 & 0xFF) + ~0x7F;
			if (v196_n > 0x3F)
			{
				loc195_n = 0x2A;
				goto l000DE16D;
			}
			Eq_n v196_n;
			v196_n.u2 = loc41.u2 + 2;
			int32 v196_n = v196_n | v196_n << 0x06;
			if (v196_n < 0x00)
			{
				uint32 v196_n = ((word32) v196_n.u2->t0000.u0 & 0xFF) + ~0x7F;
				if (v196_n > 0x3F)
				{
					loc195_n = 0x2D;
l000DE16D:
					Eq_n loc11;
					Eq_n loc28;
					int32 loc36;
					Eq_n loc12;
					Eq_n loc29;
					if (loc195_n == 0x12)
					{
						loc11.u1 = (word32) loc22 - 1;
						loc28 = arg0;
						loc36 = loc17;
						loc195_n = 0x30;
					}
					else if (loc195_n == 0x15)
					{
						loc11.u1 = (word32) loc22 - 1;
						loc28 = arg0;
						loc36 = loc17;
						loc195_n = 0x30;
					}
					else if (loc195_n == 0x18)
					{
						loc11.u1 = (word32) loc22 - 1;
						loc28 = arg0;
						loc36 = loc17;
						loc195_n = 0x30;
					}
					else if (loc195_n == 0x1B)
						*arg1.u3 = (int32) loc33;
					else if (loc195_n == 0x27)
					{
						loc11.u1 = (word32) loc41 - 1;
						loc28 = loc23;
						loc36 = loc24;
						loc195_n = 0x30;
					}
					else if (loc195_n == 0x2A)
					{
						loc12.u1 = (word32) loc41 - 1;
						loc29 = loc23;
						loc195_n = 0x35;
					}
					else if (loc195_n == 0x2D)
					{
						loc12.u1 = (word32) loc41 - 1;
						loc29 = loc23;
						loc195_n = 0x35;
					}
					if (loc195_n == 0x30)
					{
						if (loc36 == 0x00)
						{
							loc13 = loc11;
							loc30 = loc28;
							loc195_n = 0x31;
						}
						else
						{
							loc12 = loc11;
							loc29 = loc28;
							loc195_n = 0x35;
						}
					}
					if (loc195_n == 0x31)
					{
						if ((int32) loc13.u2->t0000.u0 == 0x00)
						{
							if (loc30 == 0x00 == 0x00)
							{
								*loc30.u3 = 0x00;
								*arg1.u3 = (int32) 0x00;
							}
						}
						else
						{
							loc12 = loc13;
							loc29 = loc30;
							loc195_n = 0x35;
						}
					}
					if (loc195_n == 0x35)
					{
						*___errno_location().u3 = 0x54;
						if (loc29 != 0x00)
							*arg1.u3 = (int32) loc12;
					}
					return <invalid>;
				}
				loc31_n = v196_n | v196_n << 0x06;
				loc44_n.u2 = loc41.u2 + 3;
			}
			else
			{
				loc31_n = v196_n;
				loc44_n = v196_n;
			}
l000DE13E:
			*loc23.u3 = loc31_n;
			loc7.u15 = loc23.u15 + 2;
			loc25.u2 = &loc40.u15->bFFFFFFFF;
			loc34 = loc44_n;
			loc195_n = 0x06;
			continue;
		}
		Eq_n loc5_n = loc6;
		Eq_n loc19_n;
		uint32 v196_n;
		while (true)
		{
			ui32 v196_n = (word32) loc5_n.u2->t0000.u0;
			ui32 loc121_n;
			if ((v196_n & 0xFF) < 0x80)
			{
				if ((loc5_n & 0x03) == 0x00)
				{
					ui32 v196_n = *loc5_n.u1;
					if (((v196_n + ~0x01010100 | v196_n) & 0x80808080) == 0x00)
					{
						Eq_n loc15_n = loc5_n;
						Eq_n v196_n;
						ui32 v196_n;
						while (true)
						{
							v196_n.u1 = (word32) loc15_n + 4;
							v196_n = *v196_n.u1;
							if (((v196_n + ~0x01010100 | v196_n) & 0x80808080) != 0x00)
								break;
							loc15_n = v196_n;
						}
						loc19_n = v196_n;
						loc121_n = v196_n & 0xFF;
					}
					else
					{
						loc19_n = loc5_n;
						loc121_n = v196_n & 0xFF;
					}
				}
				else
				{
					loc19_n = loc5_n;
					loc121_n = v196_n;
				}
			}
			else
			{
				loc19_n = loc5_n;
				loc121_n = v196_n;
			}
			v196_n = loc121_n & 0xFF;
			if (v196_n < 0x80 == 0x00)
				break;
			loc5_n.u2 = loc19_n.u2 + 1;
		}
		if (v196_n > 244)
		{
			loc13 = loc19_n;
			loc30 = arg0;
			loc195_n = 0x31;
			goto l000DE16D;
		}
		loc17 = g_a0A48[v196_n + ~0xC1];
		loc22.u2 = loc19_n.u2 + 1;
		loc195_n = 0x11;
	}
	if (loc25 == 0x00)
	{
		loc33 = loc34;
		loc195_n = 0x1B;
		goto l000DE16D;
	}
	Eq_n loc8_n = loc7;
	Eq_n loc26_n = loc25;
	Eq_n loc35_n = loc34;
l000DDA72:
	ui32 v196_n = (word32) loc35_n.u2->t0000.u0;
	uint32 v196_n = (v196_n & 0xFF) + ~0x00;
	Eq_n loc20;
	Eq_n loc37;
	Eq_n loc39;
	ui32 loc193;
	if (v196_n < 0x7F)
	{
		if (loc26_n > 0x04 & (loc35_n & 0x03) == 0x00)
		{
			Eq_n loc16_n = loc8_n;
			Eq_n loc32_n = loc26_n;
			Eq_n loc38_n = loc35_n;
			ui32 v196_n;
			Eq_n loc186;
			Eq_n loc189;
			Eq_n loc190;
			word32 loc195_n;
			while (true)
			{
				v196_n = *loc38_n.u1;
				if (((v196_n + ~0x01010100 | v196_n) & 0x80808080) == 0x00 == 0x00)
					break;
				*loc16_n.u3 = v196_n & 0xFF;
				loc16_n.u15[2] = (struct Eq_n) ((word32) loc38_n.u2[1] & 0xFF);
				loc16_n.u15[4] = (struct Eq_n) ((word32) loc38_n.u2[2] & 0xFF);
				loc16_n.u17[3] = (struct Eq_n) ((word32) loc38_n.u2[3] & 0xFF);
				Eq_n v196_n;
				v196_n.u1 = (word32) loc38_n + 4;
				Eq_n v196_n;
				v196_n.u15 = loc16_n.u15 + 8;
				Eq_n v196_n;
				v196_n.u2 = &loc32_n.u15->dwFFFFFFFC;
				loc186 = v196_n;
				loc189 = v196_n;
				loc190 = v196_n;
				if (v196_n <= 0x04)
				{
					loc195_n = 0x20;
					goto l000DDBF4;
				}
				loc16_n = v196_n;
				loc32_n = v196_n;
				loc38_n = v196_n;
			}
			loc195_n = 33;
l000DDBF4:
			if (loc195_n == 0x20)
			{
				loc20 = loc189;
				loc37 = loc190;
				loc39 = loc186;
				loc193 = (word32) loc186.u2->t0000.u0;
				goto l000DDC77;
			}
			if (loc195_n == 33)
			{
				loc20 = loc16_n;
				loc37 = loc32_n;
				loc39 = loc38_n;
				loc193 = v196_n & 0xFF;
				goto l000DDC77;
			}
		}
		else
		{
			loc20 = loc8_n;
			loc37 = loc26_n;
			loc39 = loc35_n;
			loc193 = v196_n;
		}
	}
	else
	{
		loc20 = loc8_n;
		loc37 = loc26_n;
		loc39 = loc35_n;
		loc193 = v196_n;
	}
l000DDC77:
	uint32 v196_n = loc193 & 0xFF;
	if (v196_n < 0x80 == 0x00)
	{
		if (v196_n > 244)
		{
			loc13 = loc39;
			loc30 = loc20;
			loc195_n = 0x31;
			goto l000DE16D;
		}
		loc23 = loc20;
		loc24 = g_a0A48[v196_n + ~0xC1];
		loc40 = loc37;
		loc41.u2 = loc39.u2 + 1;
		loc195_n = 0x26;
		goto l000DDA3D;
	}
	*loc20.u3 = (int32) v196_n;
	Eq_n v196_n;
	v196_n.u2 = loc39.u2 + 1;
	Eq_n v196_n;
	v196_n.u15 = loc20.u15 + 2;
	Eq_n v196_n;
	v196_n.u2 = &loc37.u15->bFFFFFFFF;
	if (v196_n == 0x00)
	{
		loc33 = v196_n;
		loc195_n = 0x1B;
		goto l000DE16D;
	}
	loc8_n = v196_n;
	loc26_n = v196_n;
	loc35_n = v196_n;
	goto l000DDA72;
}

// 000DE31D: Stack Eq_n fn000DE31D(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3, Stack Eq_n arg4)
Eq_n fn000DE31D(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3, Eq_n arg4)
{
	Eq_n v68_n;
	v68_n.u2 = g_t140030.u2;
	g_t140030.u2 += 272;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x0110);
	Eq_n v68_n;
	v68_n.u2 = *arg1.u3;
	*v68_n.u3 = (int32) v68_n;
	Eq_n v68_n;
	if (arg0 != 0x00)
		v68_n = arg3;
	else
		v68_n.u0 = 0x0100;
	Eq_n v68_n;
	if (arg0 != 0x00)
		v68_n = arg0;
	else
		v68_n.u15 = v68_n.u15 + 4;
	ui32 v68_n = v68_n != 0x00 & v68_n != 0x00;
	Eq_n loc10_n;
	Eq_n loc14_n;
	Eq_n loc18_n;
	Eq_n loc40_n;
	if (v68_n)
	{
		Eq_n loc7_n = arg2;
		Eq_n loc9_n = v68_n;
		Eq_n loc11_n = v68_n;
		Eq_n loc60_n = v68_n;
		while (true)
		{
			Eq_n v70_n = loc7_n >= loc9_n;
			if ((v70_n | loc7_n > 0x20) == 0x00)
				break;
			Eq_n v68_n;
			if (v70_n)
				v68_n = loc9_n;
			else
				v68_n = loc7_n;
			Eq_n v68_n = loc7_n - v68_n;
			Eq_n v68_n = fn000DE5D1(loc11_n, v68_n, v68_n, 0x00);
			if (v68_n == ~0x00)
			{
				loc10_n = loc11_n;
				loc14_n = v68_n;
				loc18_n.u0 = 0x00;
				loc40_n.u2 = *v68_n.u3;
				goto l000DE4BB;
			}
			bool v70_n = loc11_n == v68_n.u15 + 4;
			Eq_n v68_n;
			v68_n.u2 = loc11_n + v68_n;
			Eq_n v68_n;
			if (v70_n)
				v68_n.u0 = 0x00;
			else
				v68_n = v68_n;
			Eq_n v68_n = loc9_n - v68_n;
			Eq_n v68_n;
			if (v70_n)
				v68_n = loc11_n;
			else
				v68_n = v68_n;
			Eq_n v68_n;
			v68_n.u2 = *v68_n.u3;
			if (!(v68_n != 0x00 & v68_n != 0x00))
			{
				loc10_n = v68_n;
				loc14_n = v68_n;
				loc18_n = v68_n;
				loc40_n = v68_n;
				goto l000DE4BC;
			}
			loc7_n = v68_n;
			loc9_n = v68_n;
			loc11_n = v68_n;
			loc60_n = v68_n;
		}
		loc10_n = loc11_n;
		loc14_n = loc7_n;
		loc18_n = loc9_n;
		loc40_n = loc60_n;
	}
	else
	{
		loc10_n = v68_n;
		loc14_n = arg2;
		loc18_n = v68_n;
		loc40_n = v68_n;
l000DE4BB:
	}
l000DE4BC:
	bool v70_n = loc40_n == 0x00;
	if (!v70_n)
	{
		if (loc18_n != 0x00 & loc14_n != 0x00)
		{
			Eq_n loc17_n = loc14_n;
			Eq_n loc19_n = loc10_n;
			Eq_n loc21_n = loc18_n;
			Eq_n loc45_n = loc40_n;
			Eq_n v68_n;
			while (true)
			{
				v68_n = fn000D779F(loc19_n, *loc45_n.u3, 0x00);
				if (v68_n < 0x01)
					break;
				Eq_n v68_n;
				v68_n.u2 = *v68_n.u3;
				*v68_n.u3 = (int32) (v68_n.u15 + 2);
				Eq_n v68_n;
				v68_n.u2 = &loc17_n.u15->bFFFFFFFF;
				Eq_n v68_n = loc21_n - v68_n;
				Eq_n v68_n;
				v68_n.u2 = loc19_n + v68_n;
				if (!(v68_n != 0x00 & v68_n != 0x00))
					goto l000DE5B4;
				loc17_n = v68_n;
				loc19_n = v68_n;
				loc21_n = v68_n;
				loc45_n.u15 = v68_n.u15 + 2;
			}
			if (v68_n == 0x00)
				*v68_n.u3 = (int32) 0x00;
		}
	}
l000DE5B4:
	if (arg0 != 0x00)
		*arg1.u3 = *v68_n.u3;
	g_t140030.u2 = (int8 *) v68_n;
	return <invalid>;
}

// 000DE5D1: Stack Eq_n fn000DE5D1(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3)
// Called from:
//      fn000DE31D
Eq_n fn000DE5D1(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3)
{
	Eq_n v73_n;
	v73_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	if (arg0 == 0x00)
	{
		Eq_n v73_n;
		v73_n.u1 = *arg1.u3;
		Eq_n v73_n;
		v73_n.u2 = *v73_n.u1;
		if (v73_n == 0x00)
		{
l000DE695:
			goto l000DE8F1;
		}
		Eq_n loc5_n = v73_n;
		Eq_n loc24_n = v73_n;
		while (loc24_n <= 0x7F || fn000D779F(v73_n, loc24_n, 0x00) != ~0x00)
		{
			Eq_n v73_n;
			v73_n.u1 = (word32) loc5_n + 4;
			Eq_n v73_n;
			v73_n.u2 = *v73_n.u1;
			if (v73_n == 0x00)
				goto l000DE695;
			loc5_n = v73_n;
			loc24_n = v73_n;
		}
l000DE8F2:
		g_t140030.u2 = (int8 *) v73_n;
		return <invalid>;
	}
	Eq_n loc6_n;
	Eq_n loc11_n;
	if (arg2 > 0x03)
	{
		Eq_n loc7_n = arg0;
		Eq_n loc12_n = arg2;
		Eq_n loc32_n;
		loc32_n.u1 = *arg1.u3;
		Eq_n loc9_n;
		Eq_n loc15_n;
		while (true)
		{
			Eq_n v73_n;
			v73_n.u2 = *loc32_n.u1;
			Eq_n loc45_n;
			if (v73_n > 0x7F)
			{
				if (v73_n == 0x00)
				{
					*loc7_n.u2 = 0x00;
					*arg1.u3 = (int32) 0x00;
					goto l000DE8F2;
				}
				Eq_n v73_n = fn000D779F(loc7_n, v73_n, 0x00);
				if (v73_n == ~0x00)
					goto l000DE8F2;
				loc9_n.u2 = loc7_n + v73_n;
				loc15_n = loc12_n - v73_n;
				loc45_n = loc32_n;
			}
			else
			{
				*loc7_n.u2 = (byte) v73_n;
				loc9_n.u14 = loc7_n.u14 + 1;
				loc15_n.u2 = &loc12_n.u15->bFFFFFFFF;
				loc45_n.u1 = *arg1.u3;
			}
			Eq_n v73_n;
			v73_n.u1 = (word32) loc45_n + 4;
			*arg1.u3 = (int32) v73_n;
			if (loc15_n <= 0x03)
				break;
			loc7_n = loc9_n;
			loc12_n = loc15_n;
			loc32_n = v73_n;
		}
		loc6_n = loc9_n;
		loc11_n = loc15_n;
	}
	else
	{
		loc6_n = arg0;
		loc11_n = arg2;
	}
	if (loc11_n == 0x00)
	{
l000DE8F1:
		goto l000DE8F2;
	}
	Eq_n loc13_n = loc6_n;
	Eq_n loc16_n = loc11_n;
	Eq_n loc48_n;
	loc48_n.u1 = *arg1.u3;
	while (true)
	{
		Eq_n v73_n;
		v73_n.u2 = *loc48_n.u1;
		Eq_n loc14_n;
		Eq_n loc17_n;
		Eq_n loc66_n;
		if (v73_n > 0x7F)
		{
			word32 loc72_n;
			if (v73_n == 0x00)
			{
				loc72_n = 0x13;
				goto l000DE8B5;
			}
			Eq_n v73_n = fn000D779F(v73_n, v73_n, 0x00);
			if (v73_n == ~0x00)
				goto l000DE8F2;
			if (loc16_n < v73_n)
			{
				loc72_n = 22;
l000DE8B5:
				if (loc72_n == 0x13)
				{
					*loc13_n.u2 = 0x00;
					*arg1.u3 = (int32) 0x00;
					goto l000DE8F2;
				}
				if (loc72_n == 22)
					goto l000DE8F2;
				goto l000DE8F0;
			}
			fn000D779F(loc13_n, *loc48_n.u1, 0x00);
			loc14_n.u2 = loc13_n + v73_n;
			loc17_n = loc16_n - v73_n;
			loc66_n = loc48_n;
		}
		else
		{
			*loc13_n.u2 = (byte) v73_n;
			loc14_n.u14 = loc13_n.u14 + 1;
			loc17_n.u2 = &loc16_n.u15->bFFFFFFFF;
			loc66_n.u1 = *arg1.u3;
		}
		Eq_n v73_n;
		v73_n.u1 = (word32) loc66_n + 4;
		*arg1.u3 = (int32) v73_n;
		if (loc17_n == 0x00)
			goto l000DE8F2;
		loc13_n = loc14_n;
		loc16_n = loc17_n;
		loc48_n = v73_n;
	}
}

// 000DE8FC: Stack Eq_n fn000DE8FC(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000DEC35
Eq_n fn000DE8FC(Eq_n arg0, Eq_n arg1)
{
	Eq_n v30_n;
	v30_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	*v30_n.u2 = (byte) arg1;
	Eq_n v30_n;
	v30_n.u2 = arg0.u17[4];
	Eq_n loc6;
	word32 loc27;
	if (v30_n == 0x00)
	{
		if (fn000D799D(arg0) == 0x00)
		{
			loc6.u2 = arg0.u17[4];
			loc27 = 0x04;
		}
	}
	else
	{
		loc6 = v30_n;
		loc27 = 0x04;
	}
	if (loc27 == 0x04)
	{
		Eq_n v30_n;
		v30_n.u2 = arg0.u15[0x0A];
		if (v30_n < loc6 && ((arg1 & 0xFF) == (int32) (arg0.u15)->b004B) == 0x00)
		{
			arg0.u15[0x0A] = (struct Eq_n) (v30_n.u14 + 1);
			*v30_n.u2 = (byte) arg1;
			goto l000DEA26;
		}
	}
l000DEA26:
	g_t140030.u2 = (int8 *) v30_n;
	return <invalid>;
}

// 000DEA30: Stack Eq_n fn000DEA30(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
Eq_n fn000DEA30(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v21_n;
	v21_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	Eq_n v21_n = _malloc(0xF0);
	if (v21_n != 0x00)
	{
		*v21_n.u3 = *arg2.u3;
		Eq_n v21_n = fn000D29A3(v21_n, 0xF0, arg1, v21_n);
		if (v21_n < 0xF0)
		{
			Eq_n v21_n = fn000E3E00(v21_n, v21_n.u14 + 1);
			Eq_n v21_n;
			if (v21_n != 0x00)
				v21_n = v21_n;
			else
				v21_n = v21_n;
			*arg0.u3 = (int32) v21_n;
l000DEB0E:
			g_t140030.u2 = (int8 *) v21_n;
			return <invalid>;
		}
		_free(v21_n);
		if (v21_n >= 0x00)
		{
			Eq_n v21_n = _malloc(v21_n.u14 + 1);
			*arg0.u3 = (int32) v21_n;
			if (v21_n != 0x00)
				fn000D29A3(v21_n, v21_n.u14 + 1, arg1, arg2);
		}
	}
	goto l000DEB0E;
}

// 000DEB18: Stack Eq_n fn000DEB18(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn000E87B3
//      fn000E89AB
//      fn000E8DC9
//      fn000E8FC9
Eq_n fn000DEB18(Eq_n arg0, Eq_n arg1)
{
	if (arg0 == ~0x00)
		return <invalid>;
	Eq_n loc12_n;
	if (arg1.u15[38] > ~0x00)
		loc12_n = fn000D61F1(arg1);
	else
		loc12_n.u0 = 0x00;
	word32 loc26;
	if (arg1.u15[4] == 0x00)
	{
		if (fn000D2742(arg1) == 0x00)
			loc26 = 0x06;
	}
	else
		loc26 = 0x06;
	if (loc26 == 0x06)
	{
		Eq_n v29_n;
		v29_n.u2 = arg1.u15[2];
		if (v29_n > &((((arg1.u15))[22].ptrFFFFFFF4)->t0004).u0)
		{
			arg1.u15[2] = (struct Eq_n) &v29_n.u15->bFFFFFFFF;
			v29_n.u15->bFFFFFFFF = (byte) arg0;
			*arg1.u3 = (int32) (*arg1.u3 & ~0x10);
			if (loc12_n != 0x00)
				fn000D1351(arg1);
			return <invalid>;
		}
	}
	if (loc12_n != 0x00)
		fn000D1351(arg1);
	return <invalid>;
}

// 000DEC35: Stack Eq_n fn000DEC35(Stack Eq_n arg0, Stack Eq_n arg1)
// Called from:
//      fn0011D654
Eq_n fn000DEC35(Eq_n arg0, Eq_n arg1)
{
	word32 loc35;
	if (arg1.u15[38] < 0x00)
		loc35 = 0x03;
	else if (fn000D61F1(arg1) == 0x00)
		loc35 = 0x03;
	else
	{
		if ((int32) arg1.u15->b004B == arg0)
			loc35 = 0x0A;
		else
		{
			Eq_n v38_n;
			v38_n.u2 = arg1.u15[0x0A];
			if (v38_n < (arg1.u17)[4])
			{
				arg1.u15[0x0A] = (struct Eq_n) (v38_n.u14 + 1);
				*v38_n.u2 = (byte) arg0;
			}
			else
				loc35 = 0x0A;
		}
		if (loc35 == 0x0A)
			fn000DE8FC(arg1, arg0);
		fn000D1351(arg1);
	}
	if (loc35 != 0x03)
		return <invalid>;
	if ((int32) arg1.u15->b004B == arg0 == 0x00)
	{
		Eq_n v38_n;
		v38_n.u2 = arg1.u15[0x0A];
		if (v38_n < (arg1.u17)[4])
		{
			arg1.u15[0x0A] = (struct Eq_n) (v38_n.u14 + 1);
			*v38_n.u2 = (byte) arg0;
			return <invalid>;
		}
	}
	fn000DE8FC(arg1, arg0);
	return <invalid>;
}

// 000DEDA6: Stack Eq_n fn000DEDA6(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2, Stack Eq_n arg3)
// Called from:
//      fn000E7E11
//      fn000E7F2E
//      fn000E7FF3
//      fn000E82AE
//      fn000E83CB
//      fn000E8498
Eq_n fn000DEDA6(Eq_n arg0, Eq_n arg1, Eq_n arg2, Eq_n arg3)
{
	Eq_n v17_n = arg2 * arg1;
	Eq_n loc6_n;
	if (arg3.u15[38] > ~0x00)
	{
		Eq_n v17_n = fn000D61F1(arg3);
		Eq_n v17_n = fn000D61FC(arg0, v17_n, arg3);
		if (v17_n != 0x00)
			fn000D1351(arg3);
		loc6_n = v17_n;
	}
	else
		loc6_n = fn000D61FC(arg0, v17_n, arg3);
	if (loc6_n != v17_n)
		i32u-div(loc6_n, arg1);
	return <invalid>;
}

// 000DEE2E: Stack Eq_n fn000DEE2E(Stack Eq_n arg0)
// Called from:
//      fn000E89AB
//      fn000E8FC9
Eq_n fn000DEE2E(Eq_n arg0)
{
	word32 loc26;
	if (arg0.u15[38] < 0x00)
		loc26 = 0x03;
	else if (fn000D61F1(arg0) == 0x00)
		loc26 = 0x03;
	else
	{
		Eq_n v30_n;
		v30_n.u2 = arg0.u15[2];
		if (v30_n < (arg0.u15)[4])
			arg0.u15[2] = (struct Eq_n) (v30_n.u14 + 1);
		else
			fn000D2693(arg0);
	}
	if (loc26 == 0x03)
	{
		Eq_n v30_n;
		v30_n.u2 = arg0.u15[2];
		if (v30_n < (arg0.u15)[4])
			arg0.u15[2] = (struct Eq_n) (v30_n.u14 + 1);
		else
			fn000D2693(arg0);
	}
	return <invalid>;
}

// 000DEF2C: Stack Eq_n fn000DEF2C(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000DF086
Eq_n fn000DEF2C(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	Eq_n v21_n;
	v21_n.u2 = g_t140030.u2;
	g_t140030.u2 += 112;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x70);
	*v21_n.u4 = 0x00;
	v21_n.u15[4] = (struct Eq_n) 0x00;
	v21_n.u17[4] = (struct Eq_n) 0x00;
	v21_n.u15[0x0C] = (struct Eq_n) 0x00;
	v21_n.u15[16] = (struct Eq_n) 0x00;
	v21_n.u15[20] = (struct Eq_n) 0x00;
	v21_n.u15[24] = (struct Eq_n) 0x00;
	v21_n.u15[28] = (struct Eq_n) 0x00;
	v21_n.u15[32] = (struct Eq_n) 0x00;
	((word32) v21_n + 72)->u0 = 0x00;
	((word32) v21_n + 80)->u0 = 0x00;
	((word32) v21_n + 88)->u0 = 0x00;
	((word32) v21_n + 96)->u0 = 0x00;
	v21_n.u15[52] = (struct Eq_n) 0x00;
	v21_n.u15[2] = (struct Eq_n) arg0;
	v21_n.u15[4] = (struct Eq_n) ~0x00;
	v21_n.u15[22] = (struct Eq_n) arg0;
	v21_n.u15[38] = (struct Eq_n) ~0x00;
	fn000D1767(v21_n, 0x00);
	Eq_n v26_n = fn000D7B90(v21_n, arg2, 0x01);
	int32 v21_n = v21_n.u15[54].a0000.u2.u2 + ((v21_n.u15)[2] - (v21_n.u15)[4]);
	if (arg1 == 0x00 == 0x00)
	{
		Eq_n v21_n;
		v21_n.u2 = arg0.u2 + v21_n;
		Eq_n v21_n;
		if (v21_n != 0x00)
			v21_n = v21_n;
		else
			v21_n = arg0;
		*arg1.u3 = (int32) v21_n;
	}
	g_t140030.u2 = (int8 *) v21_n;
	return <invalid>;
}

// 000DF086: Stack Eq_n fn000DF086(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn000EBF56
//      fn000ECB14
//      fn000ED4F8
Eq_n fn000DF086(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	return <invalid>;
}

// 000DF09C: Stack Eq_n fn000DF09C(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn0011C78F
Eq_n fn000DF09C(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	if (arg2 == 0x00 == 0x00)
	{
		Eq_n loc3_n = arg2;
		Eq_n loc4_n = arg0;
		while (true)
		{
			*loc4_n.u3 = (int32) arg1;
			Eq_n v11_n;
			v11_n.u2 = &loc3_n.u15->bFFFFFFFF;
			Eq_n v11_n;
			v11_n.u15 = loc4_n.u15 + 2;
			if (v11_n == 0x00)
				break;
			loc3_n = v11_n;
			loc4_n = v11_n;
		}
	}
	return <invalid>;
}

// 000DF0F0: Stack Eq_n fn000DF0F0(Stack Eq_n arg0, Stack Eq_n arg1, Stack Eq_n arg2)
// Called from:
//      fn0011C903
Eq_n fn000DF0F0(Eq_n arg0, Eq_n arg1, Eq_n arg2)
{
	if (arg0 - arg1 >> 0x02 < arg2)
	{
		if (arg2 == 0x00 == 0x00)
		{
			Eq_n loc6_n = arg2;
			while (true)
			{
				Eq_n v25_n;
				v25_n.u2 = &loc6_n.u15->bFFFFFFFF;
				arg0.u3[v25_n] = arg1.u3[v25_n];
				if (v25_n == 0x00)
					break;
				loc6_n = v25_n;
			}
		}
	}
	else if (arg2 == 0x00 == 0x00)
	{
		Eq_n loc3_n = arg1;
		Eq_n loc4_n = arg0;
		Eq_n loc5_n = arg2;
		while (true)
		{
			*loc4_n.u3 = *loc3_n.u3;
			Eq_n v25_n;
			v25_n.u2 = &loc5_n.u15->bFFFFFFFF;
			Eq_n v25_n;
			v25_n.u2 = loc3_n + 0x04;
			Eq_n v25_n;
			v25_n.u15 = loc4_n.u15 + 2;
			if (v25_n == 0x00)
				break;
			loc3_n = v25_n;
			loc4_n = v25_n;
			loc5_n = v25_n;
		}
	}
	return <invalid>;
}

// 000DF1CB: Stack Eq_n _malloc(Stack Eq_n arg0)
// Called from:
//      fn000DBA9B
//      fn000DEA30
//      fn000E3D5D
//      fn000E3E00
//      fn000F1281
//      fn000F8A9E
//      fn000F9E56
//      fn000FA320
//      fn000FC957
//      fn000FCE21
//      fn001071CE
//      fn0010C171
//      fn00110FF7
//      fn0011187C
//      fn001131F3
//      fn00113AB3
//      fn0011B67B
Eq_n _malloc(Eq_n arg0)
{
	Eq_n v1157_n;
	v1157_n.u2 = g_t140030.u2;
	g_t140030.u2 += 16;
	if (g_t140030.u2 >= g_t140034.u2)
		abortStackOverflow(0x10);
	Eq_n loc15_n;
	if (arg0 < 0xF5)
	{
		Eq_n v1157_n = arg0 + ((char *) (&g_dw000A) + 1) & ~0x07;
		Eq_n v1157_n;
		if (arg0 < 11)
			v1157_n.u0 = 0x10;
		else
			v1157_n = v1157_n;
		uint32 v1157_n = v1157_n >> 0x03;
		uint32 v1157_n = *(uint32 *) 0x4664;
		uint32 v1157_n = v1157_n >> v1157_n;
		if ((v1157_n & 0x03) == 0x00 == 0x00)
		{
			uint32 v1157_n = (v1157_n & 0x01 ^ 0x01) + v1157_n;
			Eq_n v1157_n = (v1157_n << 0x03) + 18060;
			Eq_n v1157_n;
			v1157_n.u2 = v1157_n.u15[4];
			Eq_n v1157_n;
			v1157_n.u2 = v1157_n.u15[4];
			bool v1159_n = v1157_n == v1157_n;
			if (v1159_n)
				*(uint32 *) 0x4664 = v1157_n & ~(0x01 << v1157_n);
			else
			{
				if (v1157_n < *((union Eq_n *) 0x4674))
					_abort();
				if (v1157_n.u17[3] == v1157_n)
				{
					v1157_n.u17[3] = (struct Eq_n) v1157_n;
					v1157_n.u15[4] = (struct Eq_n) v1157_n;
					goto l000DF33A;
				}
				_abort();
			}
l000DF33A:
			v1157_n.u15[2] = (struct Eq_n) (v1157_n << 0x03 | 0x03);
			struct Eq_n * v1157_n = (struct Eq_n *) (v1157_n.u2 + (v1157_n << 0x03));
			v1157_n->dw0004 |= 0x01;
			g_t140030.u2 = (int8 *) v1157_n;
			return v1157_n.u15 + 4;
		}
		Eq_n v1157_n = *(union Eq_n *) 0x466C;
		if (v1157_n <= v1157_n)
		{
l000DFE77:
			loc15_n = v1157_n;
			goto l000E0D12;
		}
		if (v1157_n == 0x00 == 0x00)
		{
			ui32 v1157_n = 0x02 << v1157_n;
			ui32 v1157_n = v1157_n << v1157_n & (v1157_n | 0x00 - v1157_n);
			ui32 v1157_n = v1157_n & 0x00 - v1157_n;
			uint32 v1157_n = v1157_n + ~0x00 >> 0x0C;
			uint32 v1157_n = v1157_n + ~0x00 >> (v1157_n & 0x10);
			ui32 v1157_n = v1157_n >> 0x05 & 0x08;
			uint32 v1157_n = v1157_n >> v1157_n;
			ui32 v1157_n = v1157_n >> 0x02 & 0x04;
			uint32 v1157_n = v1157_n >> v1157_n;
			ui32 v1157_n = v1157_n >> 0x01 & 0x02;
			uint32 v1157_n = v1157_n >> v1157_n;
			ui32 v1157_n = v1157_n >> 0x01 & 0x01;
			uint32 v1157_n = (v1157_n | v1157_n & 0x10 | v1157_n | v1157_n | v1157_n) + (v1157_n >> v1157_n);
			Eq_n v1157_n = (v1157_n << 0x03) + 18060;
			Eq_n v1157_n;
			v1157_n.u2 = v1157_n.u15[4];
			Eq_n v1157_n;
			v1157_n.u2 = v1157_n.u15[4];
			bool v1159_n = v1157_n == v1157_n;
			uint32 loc1113;
			if (v1159_n)
			{
				uint32 v1157_n = v1157_n & ~(0x01 << v1157_n);
				*(uint32 *) 0x4664 = v1157_n;
				loc1113 = v1157_n;
			}
			else
			{
				if (v1157_n < *((union Eq_n *) 0x4674))
					_abort();
				if (v1157_n.u17[3] == v1157_n)
				{
					v1157_n.u17[3] = (struct Eq_n) v1157_n;
					v1157_n.u15[4] = (struct Eq_n) v1157_n;
					loc1113 = v1157_n;
					goto l000DF5A2;
				}
				_abort();
			}
l000DF5A2:
			v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x03);
			Eq_n v1157_n = (v1157_n << 0x03) - v1157_n;
			Eq_n v1157_n;
			v1157_n.u2 = v1157_n + v1157_n;
			v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x01);
			*(v1157_n + v1157_n) = (word32) v1157_n;
			if (v1157_n == 0x00 == 0x00)
			{
				ui32 v1157_n = 0x01 << (v1157_n >> 0x03);
				Eq_n v1157_n = *(union Eq_n *) 18040;
				Eq_n v1157_n = (v1157_n >> 0x03 << 0x03) + 18060;
				Eq_n loc16;
				word32 * loc78;
				if ((loc1113 & v1157_n) == 0x00)
				{
					*(uint32 *) 0x4664 = loc1113 | v1157_n;
					loc16 = v1157_n;
					loc78 = (word32 *) (v1157_n.u15 + 4);
				}
				else
				{
					Eq_n v1157_n;
					v1157_n.u2 = v1157_n.u15[4];
					if (v1157_n < *((union Eq_n *) 0x4674))
						_abort();
					else
					{
						loc16 = v1157_n;
						loc78 = (word32 *) (v1157_n.u15 + 4);
					}
				}
				*loc78 = (word32) v1157_n;
				loc16.u17[3] = (struct Eq_n) v1157_n;
				v1157_n.u15[4] = (struct Eq_n) loc16;
				v1157_n.u17[3] = (struct Eq_n) v1157_n;
			}
			*(union Eq_n *) 0x466C = v1157_n;
			*(union Eq_n *) 18040 = v1157_n;
			g_t140030.u2 = (int8 *) v1157_n;
			return v1157_n.u15 + 4;
		}
		ui32 v1157_n = *(ui32 *) 0x4668;
		if (v1157_n == 0x00)
			goto l000DFE77;
		ui32 v1157_n = v1157_n & 0x00 - v1157_n;
		uint32 v1157_n = v1157_n + ~0x00 >> 0x0C;
		uint32 v1157_n = v1157_n + ~0x00 >> (v1157_n & 0x10);
		ui32 v1157_n = v1157_n >> 0x05 & 0x08;
		uint32 v1157_n = v1157_n >> v1157_n;
		ui32 v1157_n = v1157_n >> 0x02 & 0x04;
		uint32 v1157_n = v1157_n >> v1157_n;
		ui32 v1157_n = v1157_n >> 0x01 & 0x02;
		uint32 v1157_n = v1157_n >> v1157_n;
		ui32 v1157_n = v1157_n >> 0x01 & 0x01;
		Eq_n v1157_n;
		v1157_n.u2 = ((Eq_n[]) 0x4794)[(v1157_n | v1157_n & 0x10 | v1157_n | v1157_n | v1157_n) + (v1157_n >> v1157_n)].u2;
		Eq_n loc12_n = v1157_n;
		Eq_n loc13_n = v1157_n;
		Eq_n loc14_n = (v1157_n.u15[2] & ~0x07) - v1157_n;
		while (true)
		{
			Eq_n v1157_n;
			v1157_n.u2 = loc12_n.u17[4];
			Eq_n loc188_n;
			if (v1157_n == 0x00)
			{
				Eq_n v1157_n;
				v1157_n.u2 = loc12_n.u15[0x0A];
				if (v1157_n == 0x00)
				{
					Eq_n v1157_n = *(union Eq_n *) 0x4674;
					if (loc13_n < v1157_n)
						_abort();
					Eq_n v1157_n;
					v1157_n.u2 = loc13_n + v1157_n;
					if (loc13_n < v1157_n == 0x00)
						_abort();
					Eq_n v1157_n;
					v1157_n.u2 = loc13_n.u17[3];
					Eq_n v1157_n;
					v1157_n.u2 = loc13_n.u15[0x0C];
					bool v1159_n = v1157_n == loc13_n;
					Eq_n loc51;
					if (v1159_n)
					{
						Eq_n v1157_n;
						v1157_n.u15 = loc13_n.u15 + 0x0A;
						Eq_n v1157_n;
						v1157_n.u2 = *v1157_n.u3;
						Eq_n loc38_n;
						Eq_n loc39_n;
						if (v1157_n == 0x00)
						{
							Eq_n v1157_n;
							v1157_n.u15 = loc13_n.u15 + 8;
							Eq_n v1157_n;
							v1157_n.u2 = *v1157_n.u3;
							if (v1157_n == 0x00)
							{
								loc51.u0 = 0x00;
								goto l000DFAD3;
							}
							loc38_n = v1157_n;
							loc39_n = v1157_n;
						}
						else
						{
							loc38_n = v1157_n;
							loc39_n = v1157_n;
						}
						while (true)
						{
							while (true)
							{
								Eq_n v1157_n;
								v1157_n.u15 = loc38_n.u15 + 0x0A;
								Eq_n v1157_n;
								v1157_n.u2 = *v1157_n.u3;
								if (v1157_n == 0x00 != 0x00)
									break;
								loc38_n = v1157_n;
								loc39_n = v1157_n;
							}
							Eq_n v1157_n;
							v1157_n.u15 = loc38_n.u15 + 8;
							Eq_n v1157_n;
							v1157_n.u2 = *v1157_n.u3;
							if (v1157_n == 0x00)
								break;
							loc38_n = v1157_n;
							loc39_n = v1157_n;
						}
						if (loc39_n >= v1157_n)
						{
							*loc39_n.u3 = (int32) 0x00;
							loc51 = loc38_n;
							goto l000DFAD3;
						}
						_abort();
					}
					else
					{
						Eq_n v1157_n;
						v1157_n.u2 = loc13_n.u15[4];
						if (v1157_n < v1157_n)
							_abort();
						if (v1157_n.u17[3] == loc13_n == 0x00)
							_abort();
						if (v1157_n.u15[4] == loc13_n)
						{
							v1157_n.u17[3] = (struct Eq_n) v1157_n;
							v1157_n.u15[4] = (struct Eq_n) v1157_n;
							loc51 = v1157_n;
							goto l000DFAD3;
						}
						_abort();
					}
l000DFAD3:
					if (v1157_n == 0x00 != 0x00)
					{
l000DFCAC:
						goto l000DFCAC;
					}
					Eq_n v1157_n;
					v1157_n.u2 = loc13_n.u18->dw001C;
					union Eq_n * v1157_n = (v1157_n << 0x02) + 0x4794;
					if (loc13_n == v1157_n->u2)
					{
						v1157_n->u2 = (int8 *) loc51;
						if (loc51 == 0x00)
						{
							*(ui32 *) 0x4668 = v1157_n & ~(0x01 << v1157_n);
							goto l000DFCAC;
						}
					}
					else
					{
						if (v1157_n < *((union Eq_n *) 0x4674))
							_abort();
						if (v1157_n.u17[4] == loc13_n)
							v1157_n.u17[4] = (struct Eq_n) loc51;
						else
							v1157_n.u15[0x0A] = (struct Eq_n) loc51;
						if (loc51 == 0x00)
						{
l000DFCAC:
							if (loc14_n < 0x10)
							{
								Eq_n v1157_n = loc14_n + v1157_n;
								loc13_n.u15[2] = (struct Eq_n) (v1157_n | 0x03);
								struct Eq_n * v1157_n = loc13_n + v1157_n;
								v1157_n->dw0004 |= 0x01;
							}
							else
							{
								loc13_n.u15[2] = (struct Eq_n) (v1157_n | 0x03);
								v1157_n.u15[2] = (struct Eq_n) (loc14_n | 0x01);
								*(v1157_n + loc14_n) = (word32) loc14_n;
								if (v1157_n == 0x00 == 0x00)
								{
									ui32 v1157_n = 0x01 << (v1157_n >> 0x03);
									Eq_n v1157_n = *(union Eq_n *) 18040;
									Eq_n v1157_n = (v1157_n >> 0x03 << 0x03) + 18060;
									Eq_n loc11;
									word32 * loc76;
									if ((v1157_n & v1157_n) == 0x00)
									{
										*(uint32 *) 0x4664 = v1157_n | v1157_n;
										loc11 = v1157_n;
										loc76 = (word32 *) (v1157_n.u15 + 4);
									}
									else
									{
										Eq_n v1157_n;
										v1157_n.u2 = v1157_n.u15[4];
										if (v1157_n < *((union Eq_n *) 0x4674))
											_abort();
										else
										{
											loc11 = v1157_n;
											loc76 = (word32 *) (v1157_n.u15 + 4);
										}
									}
									*loc76 = (word32) v1157_n;
									loc11.u17[3] = (struct Eq_n) v1157_n;
									v1157_n.u15[4] = (struct Eq_n) loc11;
									v1157_n.u17[3] = (struct Eq_n) v1157_n;
								}
								*(union Eq_n *) 0x466C = loc14_n;
								*(union Eq_n *) 18040 = v1157_n;
							}
							g_t140030.u2 = (int8 *) v1157_n;
							return loc13_n.u15 + 4;
						}
					}
					Eq_n v1157_n = *(union Eq_n *) 0x4674;
					if (loc51 < v1157_n)
						_abort();
					loc51.u15[0x0C] = (struct Eq_n) v1157_n;
					Eq_n v1157_n;
					v1157_n.u2 = loc13_n.u17[4];
					if (v1157_n == 0x00 == 0x00)
					{
						if (v1157_n >= v1157_n)
						{
							loc51.u17[4] = (struct Eq_n) v1157_n;
							v1157_n.u15[0x0C] = (struct Eq_n) loc51;
							goto l000DFC48;
						}
						_abort();
					}
l000DFC48:
					Eq_n v1157_n;
					v1157_n.u2 = loc13_n.u15[0x0A];
					if (v1157_n == 0x00 == 0x00)
					{
						if (v1157_n >= *((union Eq_n *) 0x4674))
						{
							loc51.u15[0x0A] = (struct Eq_n) v1157_n;
							v1157_n.u15[0x0C] = (struct Eq_n) loc51;
							goto l000DFCAC;
						}
						_abort();
					}
					goto l000DFCAC;
				}
				loc188_n = v1157_n;
			}
			else
				loc188_n = v1157_n;
			Eq_n v1157_n = (loc188_n.u15[2] & ~0x07) - v1157_n;
			bool v1159_n = v1157_n < loc14_n;
			Eq_n v1157_n;
			if (v1159_n)
				v1157_n = v1157_n;
			else
				v1157_n = loc14_n;
			Eq_n v1157_n;
			if (v1159_n)
				v1157_n = loc188_n;
			else
				v1157_n = loc13_n;
			loc12_n = loc188_n;
			loc13_n = v1157_n;
			loc14_n = v1157_n;
		}
	}
	if (arg0 > ~0x40)
	{
		loc15_n.u0 = ~0x00;
		goto l000E0D11;
	}
	Eq_n v1157_n = arg0 + ((char *) (&g_dw000A) + 1) & ~0x07;
	ui32 v1157_n = *(ui32 *) 0x4668;
	word32 loc1153;
	if (v1157_n == 0x00)
	{
l000E0D10:
		loc15_n = v1157_n;
l000E0D13:
		Eq_n v1157_n = *(union Eq_n *) 0x466C;
		if (v1157_n < loc15_n == 0x00)
		{
			Eq_n v1157_n = v1157_n - loc15_n;
			Eq_n v1157_n = *(union Eq_n *) 18040;
			if (v1157_n > 0x0F)
			{
				Eq_n v1157_n;
				v1157_n.u2 = v1157_n + loc15_n;
				*(union Eq_n *) 18040 = v1157_n;
				*(union Eq_n *) 0x466C = v1157_n;
				v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x01);
				*(v1157_n + v1157_n) = (word32) v1157_n;
				v1157_n.u15[2] = (struct Eq_n) (loc15_n | 0x03);
			}
			else
			{
				((union Eq_n *) 0x466C)->u0 = 0x00;
				((union Eq_n *) 18040)->u0 = 0x00;
				v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x03);
				struct Eq_n * v1157_n = v1157_n + v1157_n;
				v1157_n->dw0004 |= 0x01;
			}
			g_t140030.u2 = (int8 *) v1157_n;
			return v1157_n.u15 + 4;
		}
		Eq_n v1157_n = *(union Eq_n *) 0x4670;
		if (v1157_n > loc15_n)
		{
			Eq_n v1157_n = v1157_n - loc15_n;
			*(union Eq_n *) 0x4670 = v1157_n;
			Eq_n v1157_n = *(union Eq_n *) 18044;
			Eq_n v1157_n;
			v1157_n.u2 = v1157_n + loc15_n;
			*(union Eq_n *) 18044 = v1157_n;
			v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x01);
			v1157_n.u15[2] = (struct Eq_n) (loc15_n | 0x03);
			g_t140030.u2 = (int8 *) v1157_n;
			return v1157_n.u15 + 4;
		}
		Eq_n loc628_n;
		if (*(ui32 *) 0x483C == 0x00)
		{
			((union Eq_n *) 0x4844)->u0 = 0x1000;
			*(ui32 *) 0x4840 = 0x1000;
			*(word32 *) 0x4848 = ~0x00;
			*(word32 *) 0x484C = ~0x00;
			*(word32 *) 0x4850 = 0x00;
			*(ui32 *) 0x4820 = 0x00;
			ui32 v1157_n = v1157_n & ~0x0F ^ 0x55555558;
			*v1157_n.u3 = v1157_n;
			*(ui32 *) 0x483C = v1157_n;
			loc628_n.u0 = 0x1000;
		}
		else
			loc628_n = *(union Eq_n *) 0x4844;
		Eq_n v1157_n = loc15_n.u14 + 47;
		ui32 v1157_n = loc628_n + v1157_n;
		ui32 v1157_n = 0x00 - loc628_n;
		Eq_n v1157_n = v1157_n & v1157_n;
		Eq_n v1157_n;
		v1157_n.u15 = loc15_n.u15 + 24;
		if (v1157_n > loc15_n == 0x00)
		{
			g_t140030.u2 = (int8 *) v1157_n;
			return 0x00;
		}
		uint32 v1157_n = *(uint32 *) 0x481C;
		if (v1157_n == 0x00 == 0x00)
		{
			uint32 v1157_n = *(uint32 *) 0x4814;
			uint32 v1157_n = v1157_n.u2 + v1157_n;
			if (v1157_n <= v1157_n | v1157_n > v1157_n)
			{
				g_t140030.u2 = (int8 *) v1157_n;
				return 0x00;
			}
		}
		bool v1159_n = (*(ui32 *) 0x4820 & 0x04) == 0x00;
		word32 loc1153_n;
		Eq_n loc64;
		Eq_n loc65;
		if (!v1159_n)
		{
l000E13A2:
			loc1153_n = 0xBB;
l000E13A3:
			if (loc1153_n == 0xBB)
			{
				if (v1157_n < 0x7FFFFFFF)
				{
					Eq_n v1157_n = _sbrk(v1157_n);
					Eq_n v1157_n = _sbrk(0x00);
					if (v1157_n < v1157_n & (v1157_n != ~0x00 & v1157_n != ~0x00))
					{
						Eq_n v1157_n = v1157_n - v1157_n;
						if (v1157_n > loc15_n.u15 + 20)
						{
							loc64 = v1157_n;
							loc65 = v1157_n;
							loc1153_n = 0xBE;
						}
					}
				}
			}
			if (loc1153_n != 0xBE)
			{
l000E2C10:
				*___errno_location().u3 = 0x0C;
				g_t140030.u2 = (int8 *) v1157_n;
				return 0x00;
			}
			uint32 v1157_n = loc64.u2 + *((uint32 *) 0x4814);
			*(uint32 *) 0x4814 = v1157_n;
			if (v1157_n > *((uint32 *) 0x4818))
				*(uint32 *) 0x4818 = v1157_n;
			Eq_n v1157_n = *(union Eq_n *) 18044;
			if (v1157_n == 0x00)
			{
				Eq_n v1157_n = *(union Eq_n *) 0x4674;
				if (v1157_n == 0x00 | loc65 < v1157_n)
					*(union Eq_n *) 0x4674 = loc65;
				*(union Eq_n *) 0x4824 = loc65;
				*(union Eq_n *) 0x4828 = loc64;
				*(word32 *) 0x4830 = 0x00;
				*(ui32 *) 0x4688 = *(ui32 *) 0x483C;
				*(word32 *) 0x4684 = ~0x00;
				ui32 loc10_n = 0x00;
				while (true)
				{
					struct Eq_n * v1157_n = (loc10_n << 0x03) + 18060;
					v1157_n->ptr000C = v1157_n;
					v1157_n->ptr0008 = v1157_n;
					ui32 v1157_n = loc10_n + 0x01;
					if (v1157_n == 0x20)
						break;
					loc10_n = v1157_n;
				}
				uint32 v1157_n = (uint32) (loc65.u15 + 4);
				Eq_n v1157_n = (word32) loc64 - 40;
				ui32 v1157_n = 0x00 - v1157_n;
				Eq_n v1157_n;
				if ((v1157_n & 0x07) == 0x00)
					v1157_n.u0 = 0x00;
				else
					v1157_n = v1157_n & 0x07;
				Eq_n v1157_n;
				v1157_n.u2 = loc65 + v1157_n;
				*(union Eq_n *) 18044 = v1157_n;
				Eq_n v1157_n = v1157_n - v1157_n;
				*(union Eq_n *) 0x4670 = v1157_n;
				v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x01);
				*((word32) (v1157_n + v1157_n) + 4) = 0x28;
				*(word32 *) 0x4680 = *(word32 *) 0x484C;
l000E2B79:
				goto l000E2B7A;
			}
			struct Eq_n * loc21_n = (struct Eq_n *) 0x4824;
			word32 * v1157_n;
			Eq_n v1157_n;
			word32 v1157_n;
			while (true)
			{
				v1157_n = (word32 *) ((char *) &loc21_n->t0000 + 4);
				v1157_n.u2 = loc21_n->t0000.u2;
				v1157_n = *v1157_n;
				if (loc65 == v1157_n.u2 + v1157_n)
					break;
				struct Eq_n * v1157_n = loc21_n->ptr0008;
				if (v1157_n == null)
					goto l000E16A3;
				loc21_n = v1157_n;
			}
			loc1153_n = 200;
l000E16A3:
			if (loc1153_n == 200)
			{
				if ((loc21_n->dw000C & 0x08) == 0x00 && v1157_n < loc65 & v1157_n >= v1157_n)
				{
					*v1157_n = loc64.u2 + v1157_n;
					Eq_n v1157_n = *(union Eq_n *) 0x4670;
					ui32 v1157_n = 0x00 - (v1157_n.u15 + 4);
					Eq_n v1157_n;
					if ((v1157_n.u15 + 4 & 0x07) == 0x00)
						v1157_n.u0 = 0x00;
					else
						v1157_n = v1157_n & 0x07;
					Eq_n v1157_n;
					v1157_n.u2 = v1157_n + v1157_n;
					*(union Eq_n *) 18044 = v1157_n;
					Eq_n v1157_n;
					v1157_n.u2 = loc64 - v1157_n + v1157_n;
					*(union Eq_n *) 0x4670 = v1157_n;
					v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x01);
					*((word32) (v1157_n + v1157_n) + 4) = 0x28;
					*(word32 *) 0x4680 = *(word32 *) 0x484C;
					goto l000E2B7A;
				}
			}
			Eq_n v1157_n = *(union Eq_n *) 0x4674;
			Eq_n loc857_n;
			if (loc65 < v1157_n)
			{
				*(union Eq_n *) 0x4674 = loc65;
				loc857_n = loc65;
			}
			else
				loc857_n = v1157_n;
			Eq_n v1157_n;
			v1157_n.u2 = loc65 + loc64;
			struct Eq_n * loc40_n = (struct Eq_n *) 0x4824;
			struct Eq_n * loc7;
			while (loc40_n->t0000.u2 != v1157_n)
			{
				struct Eq_n * v1157_n = loc40_n->ptr0008;
				if (v1157_n == null)
				{
					loc7 = (struct Eq_n *) 0x4824;
					goto l000E1866;
				}
				loc40_n = v1157_n;
			}
			loc1153_n = 0xD0;
l000E1866:
			if (loc1153_n == 0xD0)
			{
				if ((loc40_n->dw000C & 0x08) == 0x00)
				{
					loc40_n->t0000.u2 = (int8 *) loc65;
					word32 * v1157_n = (word32 *) ((char *) &loc40_n->t0000 + 4);
					*v1157_n = loc64.u2 + *v1157_n;
					uint32 v1157_n = (uint32) (loc65.u15 + 4);
					ui32 v1157_n = 0x00 - v1157_n;
					ui32 v1157_n;
					if ((v1157_n & 0x07) == 0x00)
						v1157_n = 0x00;
					else
						v1157_n = v1157_n & 0x07;
					struct Eq_n * v1157_n = (struct Eq_n *) (loc65.u2 + v1157_n);
					ui32 v1157_n = 0x00 - (v1157_n.u15 + 4);
					ui32 v1157_n;
					if ((v1157_n.u15 + 4 & 0x07) == 0x00)
						v1157_n = 0x00;
					else
						v1157_n = v1157_n & 0x07;
					v1157_n->dw0004 = loc15_n | 0x03;
					Eq_n v1157_n;
					v1157_n.u2 = v1157_n.u2 + v1157_n;
					Eq_n v1157_n;
					v1157_n.u2 = v1157_n + loc15_n;
					Eq_n v1157_n = v1157_n - v1157_n - loc15_n;
					bool v1159_n = v1157_n == v1157_n;
					if (v1159_n)
					{
						Eq_n v1157_n;
						v1157_n.u2 = *(union Eq_n *) 0x4670 + v1157_n;
						*(union Eq_n *) 0x4670 = v1157_n;
						*(union Eq_n *) 18044 = v1157_n;
						v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x01);
						goto l000E2489;
					}
					if (v1157_n == *((union Eq_n *) 18040))
					{
						Eq_n v1157_n;
						v1157_n.u2 = *(union Eq_n *) 0x466C + v1157_n;
						*(union Eq_n *) 0x466C = v1157_n;
						*(union Eq_n *) 18040 = v1157_n;
						v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x01);
						*(v1157_n + v1157_n) = (word32) v1157_n;
						goto l000E248A;
					}
					Eq_n v1157_n;
					v1157_n.u2 = v1157_n.u15[2];
					Eq_n loc9_n;
					Eq_n loc22_n;
					if ((v1157_n & 0x03) != 0x01)
					{
						loc9_n = v1157_n;
						loc22_n = v1157_n;
l000E1FA5:
						word32 * v1157_n = (word32 *) (loc9_n.u15 + 2);
						*v1157_n &= ~0x01;
						v1157_n.u15[2] = (struct Eq_n) (loc22_n | 0x01);
						*(v1157_n + loc22_n) = (word32) loc22_n;
						uint32 v1157_n = loc22_n >> 0x03;
						if (loc22_n < 0x0100)
						{
							Eq_n v1157_n = __align(loc22_n, 8) + 18060;
							uint32 v1157_n = *(uint32 *) 0x4664;
							ui32 v1157_n = 0x01 << v1157_n;
							ui32 v1157_n = v1157_n & v1157_n;
							Eq_n loc25;
							word32 * loc74;
							if (v1157_n == 0x00)
							{
								*(uint32 *) 0x4664 = v1157_n | v1157_n;
								loc25 = v1157_n;
								loc74 = (word32 *) (v1157_n.u15 + 4);
							}
							else
							{
								Eq_n v1157_n;
								v1157_n.u2 = v1157_n.u15[4];
								if (v1157_n < *((union Eq_n *) 0x4674) == 0x00)
								{
									loc25 = v1157_n;
									loc74 = (word32 *) (v1157_n.u15 + 4);
									goto l000E20B0;
								}
								_abort();
							}
l000E20B0:
							*loc74 = (word32) v1157_n;
							loc25.u17[3] = (struct Eq_n) v1157_n;
							v1157_n.u15[4] = (struct Eq_n) loc25;
							v1157_n.u17[3] = (struct Eq_n) v1157_n;
							goto l000E248A;
						}
						uint32 v1157_n = loc22_n >> 0x08;
						Eq_n loc26_n;
						if (v1157_n == 0x00)
							loc26_n.u0 = 0x00;
						else
						{
							if (loc22_n > 0x00FFFFFF)
							{
								loc26_n.u0 = 0x1F;
								goto l000E21FD;
							}
							uint32 v1157_n = v1157_n + 0x000FFF00 >> 0x10;
							ui32 v1157_n = v1157_n << (v1157_n & 0x08);
							uint32 v1157_n = v1157_n + 0x0007F000 >> 0x10;
							ui32 v1157_n = v1157_n << (v1157_n & 0x04);
							uint32 v1157_n = v1157_n + 0x0003C000 >> 0x10;
							ui32 v1157_n = 0x0E - ((v1157_n & 0x04 | v1157_n & 0x08) | v1157_n & 0x02) + ((v1157_n << (v1157_n & 0x02)) >> 0x0F);
							loc26_n = loc22_n >> v1157_n + 0x07 & 0x01 | v1157_n << 0x01;
						}
l000E21FD:
						v1157_n.u18->dw001C = (ui32) loc26_n;
						v1157_n.u15[0x0A] = (struct Eq_n) 0x00;
						v1157_n.u17[4] = (struct Eq_n) 0x00;
						ui32 v1157_n = *(ui32 *) 0x4668;
						ui32 v1157_n = 0x01 << loc26_n;
						struct Eq_n * v1158_n = loc26_n << 0x02;
						if ((v1157_n & v1157_n) == 0x00)
						{
							*(ui32 *) 0x4668 = v1157_n | v1157_n;
							*(v1158_n + (Eq_n (*)[]) 0x4794) = (word32) v1157_n;
							v1157_n.u15[0x0C] = (struct Eq_n) (v1158_n + (Eq_n (*)[]) 0x4794);
							v1157_n.u17[3] = (struct Eq_n) v1157_n;
							v1157_n.u15[4] = (struct Eq_n) v1157_n;
							goto l000E248A;
						}
						Eq_n v1157_n;
						v1157_n.u2 = ((Eq_n[]) 0x4794)[loc26_n].u2;
						word32 v1157_n = 0x19 - (loc26_n >> 0x01);
						word32 v1157_n;
						if (loc26_n == 0x1F)
							v1157_n = 0x00;
						else
							v1157_n = v1157_n;
						uint32 loc23_n = loc22_n << v1157_n;
						Eq_n loc24_n = v1157_n;
						Eq_n loc1020;
						word32 loc1153_n;
						while ((loc24_n.u15[2] & ~0x07) != loc22_n)
						{
							Eq_n v1157_n;
							v1157_n.u15 = loc24_n.u15 + 8 + (loc23_n >> 0x1F) * 2;
							loc1020 = v1157_n;
							uint32 v1157_n = loc23_n << 0x01;
							Eq_n v1157_n;
							v1157_n.u2 = *v1157_n.u3;
							if (v1157_n == 0x00)
							{
								loc1153_n = 0x0113;
								goto l000E2383;
							}
							loc23_n = v1157_n;
							loc24_n = v1157_n;
						}
						loc1153_n = 0x0116;
l000E2383:
						if (loc1153_n == 0x0113)
						{
							if (loc1020 >= *((union Eq_n *) 0x4674))
							{
								*loc1020.u3 = (int32) v1157_n;
								v1157_n.u15[0x0C] = (struct Eq_n) loc24_n;
								v1157_n.u17[3] = (struct Eq_n) v1157_n;
								v1157_n.u15[4] = (struct Eq_n) v1157_n;
								goto l000E248A;
							}
							_abort();
						}
						else if (loc1153_n == 0x0116)
						{
							union Eq_n * v1157_n = (union Eq_n *) (loc24_n.u15 + 4);
							Eq_n v1157_n;
							v1157_n.u2 = v1157_n->u2;
							Eq_n v1157_n = *(union Eq_n *) 0x4674;
							if (v1157_n >= v1157_n & loc24_n >= v1157_n)
							{
								v1157_n.u17[3] = (struct Eq_n) v1157_n;
								v1157_n->u2 = (int8 *) v1157_n;
								v1157_n.u15[4] = (struct Eq_n) v1157_n;
								v1157_n.u17[3] = (struct Eq_n) loc24_n;
								v1157_n.u15[0x0C] = (struct Eq_n) 0x00;
								goto l000E248A;
							}
							_abort();
						}
l000E248A:
						g_t140030.u2 = (int8 *) v1157_n;
						return &v1157_n->dw0004 + 1;
					}
					if (v1157_n < 0x0100)
					{
						Eq_n v1157_n;
						v1157_n.u2 = v1157_n.u15[4];
						Eq_n v1157_n = (v1157_n >> 0x03 << 0x03) + 18060;
						Eq_n v1157_n;
						v1157_n.u2 = v1157_n.u17[3];
						Eq_n v1159_n = v1157_n == v1157_n;
						if (v1159_n == 0x00)
						{
							if (v1157_n < loc857_n)
								_abort();
							if (v1157_n.u17[3] == v1157_n)
							{
l000E1B34:
								if (v1157_n == v1157_n)
								{
									*(uint32 *) 0x4664 &= ~(0x01 << (v1157_n >> 0x03));
									goto l000E1F7B;
								}
								bool v1159_n = v1157_n == v1157_n;
								word32 * loc77;
								if (v1159_n)
									loc77 = (word32 *) (v1157_n.u15 + 4);
								else
								{
									if (v1157_n < loc857_n)
										_abort();
									if (v1157_n.u15[4] == v1157_n)
									{
										loc77 = (word32 *) (v1157_n.u15 + 4);
										goto l000E1BD3;
									}
									_abort();
								}
l000E1BD3:
								v1157_n.u17[3] = (struct Eq_n) v1157_n;
								*loc77 = (word32) v1157_n;
								goto l000E1F7A;
							}
							_abort();
						}
						goto l000E1B34;
					}
					Eq_n v1157_n;
					v1157_n.u2 = v1157_n.u17[3];
					Eq_n v1157_n;
					v1157_n.u2 = v1157_n.u15[0x0C];
					bool v1159_n = v1157_n == v1157_n;
					Eq_n loc52;
					if (v1159_n)
					{
						Eq_n v1157_n;
						v1157_n.u2 = v1157_n.u15[0x0A];
						Eq_n loc41_n;
						Eq_n loc42_n;
						if (v1157_n == 0x00)
						{
							Eq_n v1157_n;
							v1157_n.u2 = v1157_n.u17[4];
							if (v1157_n == 0x00)
							{
								loc52.u0 = 0x00;
								goto l000E1D8C;
							}
							loc41_n = v1157_n;
							loc42_n.u15 = v1157_n.u15 + 8;
						}
						else
						{
							loc41_n = v1157_n;
							loc42_n.u15 = v1157_n.u15 + 0x0A;
						}
						while (true)
						{
							while (true)
							{
								Eq_n v1157_n;
								v1157_n.u15 = loc41_n.u15 + 0x0A;
								Eq_n v1157_n;
								v1157_n.u2 = *v1157_n.u3;
								if (v1157_n == 0x00 != 0x00)
									break;
								loc41_n = v1157_n;
								loc42_n = v1157_n;
							}
							Eq_n v1157_n;
							v1157_n.u15 = loc41_n.u15 + 8;
							Eq_n v1157_n;
							v1157_n.u2 = *v1157_n.u3;
							if (v1157_n == 0x00)
								break;
							loc41_n = v1157_n;
							loc42_n = v1157_n;
						}
						if (loc42_n >= loc857_n)
						{
							*loc42_n.u3 = 0x00;
							loc52 = loc41_n;
							goto l000E1D8C;
						}
						_abort();
					}
					else
					{
						Eq_n v1157_n;
						v1157_n.u2 = v1157_n.u15[4];
						if (v1157_n < loc857_n)
							_abort();
						if (v1157_n.u17[3] == v1157_n == 0x00)
							_abort();
						if (v1157_n.u15[4] == v1157_n)
						{
							v1157_n.u17[3] = (struct Eq_n) v1157_n;
							v1157_n.u15[4] = (struct Eq_n) v1157_n;
							loc52 = v1157_n;
							goto l000E1D8C;
						}
						_abort();
					}
l000E1D8C:
					if (v1157_n == 0x00)
						goto l000E1F7B;
					Eq_n v1157_n;
					v1157_n.u2 = v1157_n.u18->dw001C;
					union Eq_n * v1157_n = (v1157_n << 0x02) + 0x4794;
					bool v1159_n = v1157_n == v1157_n->u2;
					if (v1159_n)
					{
						v1157_n->u2 = (int8 *) loc52;
						if (loc52 == 0x00 != 0x00)
						{
							*(ui32 *) 0x4668 &= ~(0x01 << v1157_n);
							goto l000E1F7B;
						}
					}
					else
					{
						if (v1157_n < *((union Eq_n *) 0x4674))
							_abort();
						if (v1157_n.u17[4] == v1157_n)
							v1157_n.u17[4] = (struct Eq_n) loc52;
						else
							v1157_n.u15[0x0A] = (struct Eq_n) loc52;
						if (loc52 == 0x00)
						{
l000E1F7B:
							loc9_n.u2 = v1157_n.u2 + (v1157_n & ~0x07);
							loc22_n.u2 = v1157_n.u2 + (v1157_n & ~0x07);
							goto l000E1FA5;
						}
					}
					Eq_n v1157_n = *(union Eq_n *) 0x4674;
					if (loc52 < v1157_n)
						_abort();
					loc52.u15[0x0C] = (struct Eq_n) v1157_n;
					Eq_n v1157_n;
					v1157_n.u2 = v1157_n.u17[4];
					if (v1157_n == 0x00 == 0x00)
					{
						if (v1157_n >= v1157_n)
						{
							loc52.u17[4] = (struct Eq_n) v1157_n;
							v1157_n.u15[0x0C] = (struct Eq_n) loc52;
							goto l000E1F15;
						}
						_abort();
					}
l000E1F15:
					Eq_n v1157_n;
					v1157_n.u2 = v1157_n.u15[0x0A];
					if (v1157_n == 0x00)
						goto l000E1F7B;
					if (v1157_n >= *((union Eq_n *) 0x4674))
					{
						loc52.u15[0x0A] = (struct Eq_n) v1157_n;
						v1157_n.u15[0x0C] = (struct Eq_n) loc52;
						goto l000E1F7B;
					}
					_abort();
l000E1F7A:
					goto l000E1F7B;
				}
				loc7 = (struct Eq_n *) 0x4824;
			}
			while (true)
			{
				Eq_n v1157_n;
				v1157_n.u2 = loc7->t0000.u2;
				if (v1157_n > v1157_n == 0x00)
				{
					Eq_n v1157_n;
					v1157_n.u2 = v1157_n.u2 + loc7->dw0004;
					if (v1157_n > v1157_n)
					{
						ui32 v1157_n = 0x00 - ((word32) v1157_n - 39);
						uint32 v1157_n;
						if (((word32) v1157_n - 39 & 0x07) == 0x00)
							v1157_n = 0x00;
						else
							v1157_n = v1157_n & 0x07;
						Eq_n v1157_n = (word32) v1157_n - 47 + v1157_n;
						Eq_n v1157_n;
						if (v1157_n < v1157_n.u15 + 8)
							v1157_n = v1157_n;
						else
							v1157_n = v1157_n;
						uint32 v1157_n = (uint32) (loc65.u15 + 4);
						Eq_n v1157_n;
						v1157_n.u1 = v1157_n.u15 + 4;
						word32 * v1157_n = (word32 *) (v1157_n.u15 + 0x0C);
						Eq_n v1157_n = (word32) loc64 - 40;
						ui32 v1157_n = 0x00 - v1157_n;
						Eq_n v1157_n;
						if ((v1157_n & 0x07) == 0x00)
							v1157_n.u0 = 0x00;
						else
							v1157_n = v1157_n & 0x07;
						Eq_n v1157_n;
						v1157_n.u2 = loc65 + v1157_n;
						*(union Eq_n *) 18044 = v1157_n;
						Eq_n v1157_n = v1157_n - v1157_n;
						*(union Eq_n *) 0x4670 = v1157_n;
						v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x01);
						*((word32) (v1157_n + v1157_n) + 4) = 0x28;
						*(word32 *) 0x4680 = *(word32 *) 0x484C;
						ui32 * v1157_n = (ui32 *) (v1157_n.u15 + 2);
						*v1157_n = 0x1B;
						v1157_n.u1->t0000.u15 = (struct Eq_n *) *(union Eq_n *) 0x4824;
						v1157_n.u1->t0008.u0 = (word64) *(union Eq_n *) 0x482C;
						*(union Eq_n *) 0x4824 = loc65;
						*(union Eq_n *) 0x4828 = loc64;
						*(word32 *) 0x4830 = 0x00;
						*(union Eq_n *) 0x482C = v1157_n;
						word32 * loc6_n = v1157_n;
						while (true)
						{
							word32 * v1157_n = loc6_n + 1;
							*v1157_n = 0x07;
							if (v1157_n + 1 >= v1157_n)
								break;
							loc6_n = v1157_n;
						}
						if (v1157_n == v1157_n == 0x00)
						{
							*v1157_n &= ~0x01;
							uint32 v1157_n = v1157_n - v1157_n;
							v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x01);
							*v1157_n.u3 = (int32) v1157_n;
							if (v1157_n < 0x0100)
							{
								uint32 v1157_n = *(uint32 *) 0x4664;
								ui32 v1157_n = 0x01 << (v1157_n >> 0x03);
								Eq_n v1157_n = (v1157_n >> 0x03 << 0x03) + 18060;
								Eq_n loc19;
								word32 * loc73;
								if ((v1157_n & v1157_n) == 0x00)
								{
									*(uint32 *) 0x4664 = v1157_n | v1157_n;
									loc19 = v1157_n;
									loc73 = (word32 *) (v1157_n.u15 + 4);
								}
								else
								{
									Eq_n v1157_n;
									v1157_n.u2 = v1157_n.u15[4];
									if (v1157_n < *((union Eq_n *) 0x4674))
										_abort();
									else
									{
										loc19 = v1157_n;
										loc73 = (word32 *) (v1157_n.u15 + 4);
									}
								}
								*loc73 = (word32) v1157_n;
								loc19.u17[3] = (struct Eq_n) v1157_n;
								v1157_n.u15[4] = (struct Eq_n) loc19;
								v1157_n.u17[3] = (struct Eq_n) v1157_n;
l000E2B7A:
								Eq_n v1157_n = *(union Eq_n *) 0x4670;
								if (v1157_n > loc15_n)
								{
									Eq_n v1157_n = v1157_n - loc15_n;
									*(union Eq_n *) 0x4670 = v1157_n;
									Eq_n v1157_n = *(union Eq_n *) 18044;
									Eq_n v1157_n;
									v1157_n.u2 = v1157_n + loc15_n;
									*(union Eq_n *) 18044 = v1157_n;
									v1157_n.u15[2] = (struct Eq_n) (v1157_n | 0x01);
									v1157_n.u15[2] = (struct Eq_n) (loc15_n | 0x03);
									g_t140030.u2 = (int8 *) v1157_n;
									return v1157_n.u15 + 4;
								}
								goto l000E2C10;
							}
							Eq_n loc20_n;
							if (v1157_n >> 0x08 == 0x00)
								loc20_n.u0 = 0x00;
							else if (v1157_n > 0x00FFFFFF)
								loc20_n.u0 = 0x1F;
							else
							{
								ui32 v1157_n = (v1157_n >> 0x08) + 0x000FFF00 >> 0x10 & 0x08;
								ui32 v1157_n = v1157_n >> 0x08 << v1157_n;
								uint32 v1157_n = v1157_n + 0x0007F000 >> 0x10;
								ui32 v1157_n = v1157_n << (v1157_n & 0x04);
								uint32 v1157_n = v1157_n + 0x0003C000 >> 0x10;
								ui32 v1157_n = 0x0E - ((v1157_n & 0x04 | v1157_n) | v1157_n & 0x02) + ((v1157_n << (v1157_n & 0x02)) >> 0x0F);
								loc20_n = v1157_n >> v1157_n + 0x07 & 0x01 | v1157_n << 0x01;
							}
							v1157_n.u18->dw001C = (ui32) loc20_n;
							v1157_n.u15[0x0A] = (struct Eq_n) 0x00;
							v1157_n.u17[4] = (struct Eq_n) 0x00;
							ui32 v1157_n = *(ui32 *) 0x4668;
							ui32 v1157_n = 0x01 << loc20_n;
							struct Eq_n * v1158_n = loc20_n << 0x02;
							if ((v1157_n & v1157_n) == 0x00)
							{
								*(ui32 *) 0x4668 = v1157_n | v1157_n;
								*(v1158_n + (Eq_n (*)[]) 0x4794) = (word32) v1157_n;
								v1157_n.u15[0x0C] = (struct Eq_n) (v1158_n + (Eq_n (*)[]) 0x4794);
								v1157_n.u17[3] = (struct Eq_n) v1157_n;
								v1157_n.u15[4] = (struct Eq_n) v1157_n;
								goto l000E2B7A;
							}
							Eq_n v1157_n;
							v1157_n.u2 = ((Eq_n[]) 0x4794)[loc20_n].u2;
							word32 v1157_n = 0x19 - (loc20_n >> 0x01);
							word32 v1157_n;
							if (loc20_n == 0x1F)
								v1157_n = 0x00;
							else
								v1157_n = v1157_n;
							uint32 loc17_n = v1157_n << v1157_n;
							Eq_n loc18_n = v1157_n;
							Eq_n loc111;
							word32 loc1153_n;
							while ((loc18_n.u15[2] & ~0x07) != v1157_n)
							{
								Eq_n v1157_n;
								v1157_n.u15 = loc18_n.u15 + 8 + (loc17_n >> 0x1F) * 2;
								loc111 = v1157_n;
								uint32 v1157_n = loc17_n << 0x01;
								Eq_n v1157_n;
								v1157_n.u2 = *v1157_n.u3;
								if (v1157_n == 0x00)
								{
									loc1153_n = 0x012D;
									goto l000E2A8E;
								}
								loc17_n = v1157_n;
								loc18_n = v1157_n;
							}
							loc1153_n = 0x0130;
l000E2A8E:
							if (loc1153_n == 0x012D)
							{
								if (loc111 >= *((union Eq_n *) 0x4674))
								{
									*loc111.u3 = (int32) v1157_n;
									v1157_n.u15[0x0C] = (struct Eq_n) loc18_n;
									v1157_n.u17[3] = (struct Eq_n) v1157_n;
									v1157_n.u15[4] = (struct Eq_n) v1157_n;
									goto l000E2B7A;
								}
								_abort();
							}
							else if (loc1153_n == 0x0130)
							{
								union Eq_n * v1157_n = (union Eq_n *) (loc18_n.u15 + 4);
								Eq_n v1157_n;
								v1157_n.u2 = v1157_n->u2;
								Eq_n v1157_n = *(union Eq_n *) 0x4674;
								if (v1157_n >= v1157_n & loc18_n >= v1157_n)
								{
									v1157_n.u17[3] = (struct Eq_n) v1157_n;
									v1157_n->u2 = (int8 *) v1157_n;
									v1157_n.u15[4] = (struct Eq_n) v1157_n;
									v1157_n.u17[3] = (struct Eq_n) loc18_n;
									v1157_n.u15[0x0C] = (struct Eq_n) 0x00;
									goto l000E2B7A;
								}
								_abort();
							}
						}
						goto l000E2B79;
					}
				}
				loc7 = loc7->ptr0008;
			}
		}
		Eq_n v1157_n = *(union Eq_n *) 18044;
		if (v1157_n != 0x00)
		{
			struct Eq_n * loc8_n = (struct Eq_n *) 0x4824;
			while (true)
			{
				Eq_n v1157_n;
				v1157_n.u2 = loc8_n->t0000.u2;
				if (v1157_n > v1157_n == 0x00)
				{
					up32 * v1157_n = (up32 *) ((char *) &loc8_n->t0000 + 4);
					if (v1157_n.u2 + *v1157_n > v1157_n)
					{
						Eq_n v1157_n = v1157_n - v1157_n & v1157_n;
						Eq_n loc48;
						Eq_n loc49;
						if (v1157_n < 0x7FFFFFFF)
						{
							Eq_n v1157_n = _sbrk(v1157_n);
							if (v1157_n == (loc8_n->t0000).u2 + *v1157_n)
							{
								if (v1157_n == ~0x00 == 0x00)
								{
									loc64 = v1157_n;
									loc65 = v1157_n;
									loc1153_n = 0xBE;
									goto l000E13A3;
								}
							}
							else
							{
								loc48 = v1157_n;
								loc49 = v1157_n;
								loc1153 = 0xB4;
							}
						}
l000E114A:
						if (loc1153 == 0xAC)
						{
							Eq_n v1157_n = _sbrk(0x00);
							if (v1157_n == ~0x00 == 0x00)
							{
								ui32 v1157_n = *(ui32 *) 0x4840;
								ui32 v1157_n = (v1157_n.u2 + (v1157_n + ~0x00) & 0x00 - v1157_n) - v1157_n;
								ui32 v1157_n;
								if ((v1157_n + ~0x00 & v1157_n) == 0x00)
									v1157_n = 0x00;
								else
									v1157_n = v1157_n;
								Eq_n v1157_n;
								v1157_n.u2 = v1157_n.u2 + v1157_n;
								uint32 v1157_n = *(uint32 *) 0x4814;
								uint32 v1157_n = v1157_n.u2 + v1157_n;
								if (v1157_n > loc15_n & v1157_n < 0x7FFFFFFF)
								{
									uint32 v1157_n = *(uint32 *) 0x481C;
									if (v1157_n == 0x00 == 0x00 && v1157_n <= v1157_n | v1157_n > v1157_n)
										goto l000E128A;
									Eq_n v1157_n = _sbrk(v1157_n);
									if (v1157_n == v1157_n)
									{
										loc64 = v1157_n;
										loc65 = v1157_n;
										loc1153_n = 0xBE;
										goto l000E13A3;
									}
									loc48 = v1157_n;
									loc49 = v1157_n;
									loc1153 = 0xB4;
								}
							}
						}
l000E128A:
						if (loc1153 != 0xB4)
						{
l000E1377:
							*(ui32 *) 0x4820 |= 0x04;
							goto l000E13A2;
						}
						Eq_n v1157_n = 0x00 - loc49;
						ui32 v1157_n = v1157_n > loc49 & (loc49 < 0x7FFFFFFF & loc48 != ~0x00);
						Eq_n loc63_n;
						if (v1157_n)
						{
							Eq_n v1157_n = *(union Eq_n *) 0x4844;
							Eq_n v1157_n = v1157_n - loc49 + v1157_n & 0x00 - v1157_n;
							if (v1157_n < 0x7FFFFFFF)
							{
								if (_sbrk(v1157_n) == ~0x00)
								{
									_sbrk(v1157_n);
									goto l000E1377;
								}
								loc63_n.u2 = v1157_n + loc49;
l000E1356:
								Mem3639 = Mem3115;
								if (loc48 == ~0x00 == 0x00)
								{
									loc64 = loc63_n;
									loc65 = loc48;
									loc1153_n = 0xBE;
									goto l000E13A3;
								}
								goto l000E1377;
							}
						}
						loc63_n = loc49;
						goto l000E1356;
					}
				}
				struct Eq_n * v1157_n = loc8_n->ptr0008;
				if (v1157_n == null)
				{
					loc1153 = 0xAC;
					goto l000E114A;
				}
				loc8_n = v1157_n;
			}
		}
		else
		{
			loc1153 = 0xAC;
			goto l000E1149;
		}
	}
	Eq_n v1157_n = 0x00 - v1157_n;
	uint32 v1157_n = arg0 + ((char *) (&g_dw000A) + 1) >> 0x08;
	uint32 loc32_n;
	if (v1157_n == 0x00)
		loc32_n = 0x00;
	else if (v1157_n > 0x00FFFFFF)
		loc32_n = 0x1F;
	else
	{
		uint32 v1157_n = v1157_n + 0x000FFF00 >> 0x10;
		ui32 v1157_n = v1157_n << (v1157_n & 0x08);
		uint32 v1157_n = v1157_n + 0x0007F000 >> 0x10;
		ui32 v1157_n = v1157_n << (v1157_n & 0x04);
		uint32 v1157_n = v1157_n + 0x0003C000 >> 0x10;
		ui32 v1157_n = 0x0E - ((v1157_n & 0x04 | v1157_n & 0x08) | v1157_n & 0x02) + ((v1157_n << (v1157_n & 0x02)) >> 0x0F);
		loc32_n = v1157_n >> v1157_n + 0x07 & 0x01 | v1157_n << 0x01;
	}
	Eq_n v1157_n;
	v1157_n.u2 = ((Eq_n[]) 0x4794)[loc32_n].u2;
	Eq_n loc50;
	Eq_n loc53;
	Eq_n loc54;
	Eq_n loc57;
	Eq_n loc59;
	Eq_n loc62;
	if (v1157_n == 0x00)
	{
		loc50.u0 = 0x00;
		loc53.u0 = 0x00;
		loc54 = v1157_n;
	}
	else
	{
		word32 v1157_n = 0x19 - (loc32_n >> 0x01);
		word32 v1157_n;
		if (loc32_n == 0x1F)
			v1157_n = 0x00;
		else
			v1157_n = v1157_n;
		Eq_n loc27_n;
		loc27_n.u0 = 0x00;
		Eq_n loc30_n = v1157_n;
		Eq_n loc31_n = v1157_n;
		uint32 loc34_n = v1157_n << v1157_n;
		Eq_n loc36_n;
		loc36_n.u0 = 0x00;
		Eq_n loc43_n;
		Eq_n loc44_n;
		Eq_n v1157_n;
		while (true)
		{
			Eq_n v1157_n = (loc31_n.u15[2] & ~0x07) - v1157_n;
			if (v1157_n < loc30_n)
			{
				if (v1157_n == 0x00)
				{
					loc57 = loc31_n;
					loc59.u0 = 0x00;
					loc62 = loc31_n;
					loc1153 = 0x5A;
					goto l000E0175;
				}
				loc43_n = loc31_n;
				loc44_n = v1157_n;
			}
			else
			{
				loc43_n = loc27_n;
				loc44_n = loc30_n;
			}
			Eq_n v1157_n;
			v1157_n.u2 = loc31_n.u15[0x0A];
			Eq_n v1157_n = *((char *) &loc31_n.u17->t0010.u2 + (loc34_n >> 0x1F) * 0x04);
			if (v1157_n == 0x00 | v1157_n == v1157_n)
				v1157_n = loc36_n;
			else
				v1157_n = v1157_n;
			uint32 v1157_n = loc34_n << (v1157_n == 0x00 & 0x01 ^ 0x01);
			if (v1157_n == 0x00)
				break;
			loc27_n = loc43_n;
			loc30_n = loc44_n;
			loc31_n = v1157_n;
			loc34_n = v1157_n;
			loc36_n = v1157_n;
		}
		loc50 = v1157_n;
		loc53 = loc43_n;
		loc54 = loc44_n;
	}
	loc1153 = 0x56;
l000E0175:
	Eq_n loc56;
	Eq_n loc58;
	if (loc1153 == 0x56)
	{
		Eq_n loc61_n;
		if (loc50 == 0x00 & loc53 == 0x00)
		{
			ui32 v1157_n = 0x02 << loc32_n;
			ui32 v1157_n = v1157_n & (v1157_n | 0x00 - v1157_n);
			if (v1157_n == 0x00)
			{
				loc15_n = v1157_n;
				goto l000E0D13;
			}
			ui32 v1157_n = v1157_n & 0x00 - v1157_n;
			uint32 v1157_n = v1157_n + ~0x00 >> 0x0C;
			uint32 v1157_n = v1157_n + ~0x00 >> (v1157_n & 0x10);
			ui32 v1157_n = v1157_n >> 0x05 & 0x08;
			uint32 v1157_n = v1157_n >> v1157_n;
			ui32 v1157_n = v1157_n >> 0x02 & 0x04;
			uint32 v1157_n = v1157_n >> v1157_n;
			ui32 v1157_n = v1157_n >> 0x01 & 0x02;
			uint32 v1157_n = v1157_n >> v1157_n;
			ui32 v1157_n = v1157_n >> 0x01 & 0x01;
			loc61_n.u2 = ((Eq_n[]) 0x4794)[(v1157_n | v1157_n & 0x10 | v1157_n | v1157_n | v1157_n) + (v1157_n >> v1157_n)].u2;
		}
		else
			loc61_n = loc50;
		if (loc61_n == 0x00)
		{
			loc56 = loc53;
			loc58 = loc54;
		}
		else
		{
			loc57 = loc53;
			loc59 = loc54;
			loc62 = loc61_n;
			loc1153 = 0x5A;
		}
	}
	if (loc1153 == 0x5A)
	{
		Eq_n v1157_n;
		Eq_n v1157_n;
		while (true)
		{
			while (true)
			{
				Eq_n v1157_n = (loc62.u15[2] & ~0x07) - v1157_n;
				loc1153 = 0x00;
				bool v1159_n = v1157_n < loc59;
				if (v1159_n)
					v1157_n = v1157_n;
				else
					v1157_n = loc59;
				if (v1159_n)
					v1157_n = loc62;
				else
					v1157_n = loc57;
				Eq_n v1157_n;
				v1157_n.u2 = loc62.u17[4];
				if (v1157_n == 0x00 != 0x00)
					break;
				loc57 = v1157_n;
				loc59 = v1157_n;
				loc62 = v1157_n;
			}
			Eq_n v1157_n;
			v1157_n.u2 = loc62.u15[0x0A];
			if (v1157_n == 0x00)
				break;
			loc57 = v1157_n;
			loc59 = v1157_n;
			loc62 = v1157_n;
		}
		loc56 = v1157_n;
		loc58 = v1157_n;
	}
	if (loc56 == 0x00 || loc58 >= *((union Eq_n *) 0x466C) - v1157_n)
		goto l000E0D10;
	Eq_n v1157_n = *(union Eq_n *) 0x4674;
	if (loc56 < v1157_n)
		_abort();
	Eq_n v1157_n;
	v1157_n.u2 = loc56 + v1157_n;
	if (loc56 < v1157_n == 0x00)
		_abort();
	Eq_n v1157_n;
	v1157_n.u2 = loc56.u17[3];
	Eq_n v1157_n;
	v1157_n.u2 = loc56.u15[0x0C];
	bool v1159_n = v1157_n == loc56;
	Eq_n loc55;
	if (v1159_n)
	{
		Eq_n v1157_n;
		v1157_n.u15 = loc56.u15 + 0x0A;
		Eq_n v1157_n;
		v1157_n.u2 = *v1157_n.u3;
		Eq_n loc46_n;
		Eq_n loc47_n;
		if (v1157_n == 0x00)
		{
			Eq_n v1157_n;
			v1157_n.u15 = loc56.u15 + 8;
			Eq_n v1157_n;
			v1157_n.u2 = *v1157_n.u3;
			if (v1157_n == 0x00)
			{
				loc55.u0 = 0x00;
				goto l000E05D2;
			}
			loc46_n = v1157_n;
			loc47_n = v1157_n;
		}
		else
		{
			loc46_n = v1157_n;
			loc47_n = v1157_n;
		}
		while (true)
		{
			while (true)
			{
				Eq_n v1157_n;
				v1157_n.u15 = loc46_n.u15 + 0x0A;
				Eq_n v1157_n;
				v1157_n.u2 = *v1157_n.u3;
				if (v1157_n == 0x00 != 0x00)
					break;
				loc46_n = v1157_n;
				loc47_n = v1157_n;
			}
			Eq_n v1157_n;
			v1157_n.u15 = loc46_n.u15 + 8;
			Eq_n v1157_n;
			v1157_n.u2 = *v1157_n.u3;
			if (v1157_n == 0x00)
				break;
			loc46_n = v1157_n;
			loc47_n = v1157_n;
		}
		if (loc47_n >= v1157_n)
		{
			*loc47_n.u3 = (int32) 0x00;
			loc55 = loc46_n;
			goto l000E05D2;
		}
		_abort();
	}
	else
	{
		Eq_n v1157_n;
		v1157_n.u2 = loc56.u15[4];
		if (v1157_n < v1157_n)
			_abort();
		if (v1157_n.u17[3] == loc56 == 0x00)
			_abort();
		if (v1157_n.u15[4] == loc56)
		{
			v1157_n.u17[3] = (struct Eq_n) v1157_n;
			v1157_n.u15[4] = (struct Eq_n) v1157_n;
			loc55 = v1157_n;
			goto l000E05D2;
		}
		_abort();
	}
l000E05D2:
	ui32 loc548;
	if (v1157_n == 0x00)
	{
		loc548 = v1157_n;
		goto l000E07C8;
	}
	Eq_n v1157_n;
	v1157_n.u2 = loc56.u18->dw001C;
	union Eq_n * v1157_n = (v1157_n << 0x02) + 0x4794;
	if (loc56 == v1157_n->u2)
	{
		v1157_n->u2 = (int8 *) loc55;
		if (loc55 == 0x00)
		{
			ui32 v1157_n = v1157_n & ~(0x01 << v1157_n);
			*(ui32 *) 0x4668 = v1157_n;
			loc548 = v1157_n;
			goto l000E07C9;
		}
	}
	else
	{
		if (v1157_n < *((union Eq_n *) 0x4674))
			_abort();
		if (v1157_n.u17[4] == loc56)
			v1157_n.u17[4] = (struct Eq_n) loc55;
		else
			v1157_n.u15[0x0A] = (struct Eq_n) loc55;
		if (loc55 == 0x00)
		{
			loc548 = v1157_n;
			goto l000E07C9;
		}
	}
	Eq_n v1157_n = *(union Eq_n *) 0x4674;
	if (loc55 < v1157_n)
		_abort();
	loc55.u15[0x0C] = (struct Eq_n) v1157_n;
	Eq_n v1157_n;
	v1157_n.u2 = loc56.u17[4];
	if (v1157_n == 0x00 == 0x00)
	{
		if (v1157_n >= v1157_n)
		{
			loc55.u17[4] = (struct Eq_n) v1157_n;
			v1157_n.u15[0x0C] = (struct Eq_n) loc55;
			goto l000E0759;
		}
		_abort();
	}
l000E0759:
	Eq_n v1157_n;
	v1157_n.u2 = loc56.u15[0x0A];
	if (v1157_n == 0x00)
		loc548 = v1157_n;
	else
	{
		if (v1157_n >= *((union Eq_n *) 0x4674))
		{
			loc55.u15[0x0A] = (struct Eq_n) v1157_n;
			v1157_n.u15[0x0C] = (struct Eq_n) loc55;
			loc548 = v1157_n;
			goto l000E07C9;
		}
		_abort();
	}
l000E07C9:
	bool v1159_n = loc58 < 0x10;
	if (v1159_n)
	{
		Eq_n v1157_n = loc58 + v1157_n;
		loc56.u15[2] = (struct Eq_n) (v1157_n | 0x03);
		struct Eq_n * v1157_n = loc56 + v1157_n;
		v1157_n->dw0004 |= 0x01;
	}
	else
	{
		loc56.u15[2] = (struct Eq_n) (v1157_n | 0x03);
		v1157_n.u15[2] = (struct Eq_n) (loc58 | 0x01);
		*(v1157_n + loc58) = (word32) loc58;
		uint32 v1157_n = loc58 >> 0x03;
		if (loc58 < 0x0100)
		{
			Eq_n v1157_n = __align(loc58, 8) + 18060;
			uint32 v1157_n = *(uint32 *) 0x4664;
			ui32 v1157_n = 0x01 << v1157_n;
			Eq_n loc37;
			word32 * loc75;
			if ((v1157_n & v1157_n) == 0x00)
			{
				*(uint32 *) 0x4664 = v1157_n | v1157_n;
				loc37 = v1157_n;
				loc75 = (word32 *) (v1157_n.u15 + 4);
			}
			else
			{
				Eq_n v1157_n;
				v1157_n.u2 = v1157_n.u15[4];
				if (v1157_n < *((union Eq_n *) 0x4674))
					_abort();
				else
				{
					loc37 = v1157_n;
					loc75 = (word32 *) (v1157_n.u15 + 4);
				}
			}
			*loc75 = (word32) v1157_n;
			loc37.u17[3] = (struct Eq_n) v1157_n;
			v1157_n.u15[4] = (struct Eq_n) loc37;
			v1157_n.u17[3] = (struct Eq_n) v1157_n;
l000E0CF2:
			g_t140030.u2 = (int8 *) v1157_n;
			return loc56.u15 + 4;
		}
		uint32 v1157_n = loc58 >> 0x08;
		Eq_n loc35_n;
		if (v1157_n == 0x00)
			loc35_n.u0 = 0x00;
		else if (loc58 > 0x00FFFFFF)
			loc35_n.u0 = 0x1F;
		else
		{
			uint32 v1157_n = v1157_n + 0x000FFF00 >> 0x10;
			ui32 v1157_n = v1157_n << (v1157_n & 0x08);
			uint32 v1157_n = v1157_n + 0x0007F000 >> 0x10;
			ui32 v1157_n = v1157_n << (v1157_n & 0x04);
			uint32 v1157_n = v1157_n + 0x0003C000 >> 0x10;
			ui32 v1157_n = 0x0E - ((v1157_n & 0x04 | v1157_n & 0x08) | v1157_n & 0x02) + ((v1157_n << (v1157_n & 0x02)) >> 0x0F);
			loc35_n = loc58 >> v1157_n + 0x07 & 0x01 | v1157_n << 0x01;
		}
		v1157_n.u18->dw001C = (ui32) loc35_n;
		v1157_n.u15[0x0A] = (struct Eq_n) 0x00;
		v1157_n.u17[4] = (struct Eq_n) 0x00;
		ui32 v1157_n = 0x01 << loc35_n;
		struct Eq_n * v1158_n = loc35_n << 0x02;
		if ((loc548 & v1157_n) == 0x00)
		{
			*(ui32 *) 0x4668 = loc548 | v1157_n;
			*(v1158_n + (Eq_n (*)[]) 0x4794) = (word32) v1157_n;
			v1157_n.u15[0x0C] = (struct Eq_n) (v1158_n + (Eq_n (*)[]) 0x4794);
			v1157_n.u17[3] = (struct Eq_n) v1157_n;
			v1157_n.u15[4] = (struct Eq_n) v1157_n;
			goto l000E0CF2;
		}
		Eq_n v1157_n;
		v1157_n.u2 = ((Eq_n[]) 0x4794)[loc35_n].u2;
		word32 v1157_n = 0x19 - (loc35_n >> 0x01);
		word32 v1157_n;
		if (loc35_n == 0x1F)
			v1157_n = 0x00;
		else
			v1157_n = v1157_n;
		uint32 loc28_n = loc58 << v1157_n;
		Eq_n loc29_n = v1157_n;
		Eq_n loc566;
		word32 loc1153_n;
		while ((loc29_n.u15[2] & ~0x07) != loc58)
		{
			Eq_n v1157_n;
			v1157_n.u15 = loc29_n.u15 + 8 + (loc28_n >> 0x1F) * 2;
			loc566 = v1157_n;
			uint32 v1157_n = loc28_n << 0x01;
			Eq_n v1157_n;
			v1157_n.u2 = *v1157_n.u3;
			if (v1157_n == 0x00)
			{
				loc1153_n = 0x91;
				goto l000E0BEB;
			}
			loc28_n = v1157_n;
			loc29_n = v1157_n;
		}
		loc1153_n = 0x94;
l000E0BEB:
		if (loc1153_n == 0x91)
		{
			if (loc566 >= *((union Eq_n *) 0x4674))
			{
				*loc566.u3 = (int32) v1157_n;
				v1157_n.u15[0x0C] = (struct Eq_n) loc29_n;
				v1157_n.u17[3] = (struct Eq_n) v1157_n;
				v1157_n.u15[4] = (struct Eq_n) v1157_n;
				goto l000E0CF2;
			}
			_abort();
		}
		else if (loc1153_n == 0x94)
		{
			union Eq_n * v1157_n = (union Eq_n *) (loc29_n.u15 + 4);
			Eq_n v1157_n;
			v1157_n.u2 = v1157_n->u2;
			Eq_n v1157_n = *(union Eq_n *) 0x4674;
			if (v1157_n >= v1157_n & loc29_n >= v1157_n)
			{
				v1157_n.u17[3] = (struct Eq_n) v1157_n;
				v1157_n->u2 = (int8 *) v1157_n;
				v1157_n.u15[4] = (struct Eq_n) v1157_n;
				v1157_n.u17[3] = (struct Eq_n) loc29_n;
				v1157_n.u15[0x0C] = (struct Eq_n) 0x00;
				goto l000E0CF2;
			}
			_abort();
		}
	}
	goto l000E0CF2;
}

