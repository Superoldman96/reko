// login_text.c
// Generated by decompiling login
// using Reko decompiler version 0.12.2.0.

#include "login.h"

// 00002570: void fn00002570(Sequence word64 r22_r23, Register (ptr32 Eq_n) r5, Register int32 r21, Stack int32 dwArg00, Stack word32 dwArg04)
void fn00002570(word64 r22_r23, void (* r5)(void * r2), int32 r21, int32 dwArg00, word32 dwArg04)
{
	ptr32 fp;
	char * (* r22)[] = SLICE(r22_r23, word32, 32);
	void (* r23)(void * r2) = (word32) r22_r23;
	ptr32 r4_n = fp + 0x04 + dwArg00 * 0x04;
	environ = r4_n + 0x04;
	r22 = fp + 0x04;
	r21 = dwArg00;
	if (dwArg04 != 0x00)
		fn000026A0();
	r23 = r5;
l00002650:
	if (r23 != null)
		fn00002710(r23);
	else if (false)
		fn00000000();
	fn00002558();
	exit(fn000028D0(r21, r22));
}

// 000026A0: void fn000026A0()
// Called from:
//      fn00002570
void fn000026A0()
{
}

// 000026F0: void fn000026F0()
// Called from:
//      fn00002810
void fn000026F0()
{
}

// 00002710: void fn00002710(Register (ptr32 Eq_n) r2)
// Called from:
//      fn00002570
//      fn00002810
void fn00002710(void (* r2)(void * r2))
{
	__cxa_atexit(r2, null, null);
}

// 00002740: void fn00002740()
// Called from:
//      fn00002810
void fn00002740()
{
	ptr32 fp;
	ptr32 r30_n = fp - 0x10;
	ui32 r25_n;
	if (g_dw56BFC != 0x00)
	{
		r25_n = 0x01;
		do
			++r25_n;
		while (g_a56BF8[r25_n] != 0x00);
	}
	else
		r25_n = 0x01;
	ui32 r25_n = r25_n - 0x01;
	<anonymous> ** r24_n = r25_n * 0x04 + 355320;
	ui32 r25_n = r25_n - 0x01;
	if (r25_n != 0x00)
	{
		do
			(*r24_n)();
		while (r25_n != ~0x00);
	}
	struct Eq_n * r31_n = r30_n - 0x10;
	word64 r24_r25_n = r31_n->qw0008;
	r31_n->ptr0014();
}

// 00002810: void fn00002810()
// Called from:
//      fn00002558
void fn00002810()
{
	if (g_dw2600C != 0x00)
		return;
	g_dw2600C = 0x01;
	fn000026F0();
	if (g_dw260E8 != 0x00 && false)
		fn00000000();
	fn00002740();
	fn00002710(&g_t4BD0);
}

// 000028D0: Register int32 fn000028D0(Register int32 r2, Register (ptr32 (arr (ptr32 char))) r3)
// Called from:
//      fn00002570
int32 fn000028D0(int32 r2, char * (* r3)[])
{
	struct Eq_n * r30_n;
	union Eq_n * r22_n;
	char bLoc0548;
	Eq_n fp;
	openlog();
	gethostname();
	struct Eq_n * r30_n = fp - (union Eq_n *****) 0x0880;
	void * r18_n = null;
	union Eq_n * dwLoc086C_n = null;
	word32 r15_n = 0x03;
	if (fp < 0x0548)
	{
		syslog();
		word32 r1_n = strlcpy();
		Eq_n tLoc08C0;
		tLoc08C0.ptr0000 = fp - (union Eq_n *****) 0x0880;
		tLoc08C0.dw0004 = r1_n;
		return fn00003FC8(0x00010000, (struct Eq_n *) 0x00020000, (struct Eq_n *) 0x00060000, (struct Eq_n *) 0x00060000, 0x00060000, (struct Eq_n *) 0x00060000, &tLoc08C0);
	}
	struct Eq_n * r2_n = strchr(&bLoc0548, 0x2E);
	if (r2_n != null)
	{
		if (r2_n->b0001 == 0)
			r2_n = (struct Eq_n *) &r2_n->b0001;
		else
			r2_n = strchr(&r2_n->b0001, 0x2E);
	}
	auth_open();
	if (r2_n == null)
	{
		g_ptr2601C = r2_n;
		syslog();
l00003B90:
		err();
	}
	g_ptr2601C = r2_n;
	auth_setoption();
	word32 r2_n = getuid();
	while (true)
	{
		word32 r2_n = getopt(r2, r3, "fh:pu:L:R:");
		if (r2_n == ~0x00)
			break;
		if (__bit<word32,byte>(cond(r2_n - 0x4C - 0x29), 0x05))
		{
			fn00002A90();
			if (r2_n != 0x00)
			{
				warnc();
				fn00004780(0x01, 0x00010000, (struct Eq_n *) 0x00020000);
			}
			if (false)
			{
				warnx();
				fn00004780(0x01, 0x00010000, (struct Eq_n *) 0x00020000);
			}
			union Eq_n * r13_n = optarg;
			Eq_n tLoc0848;
			tLoc0848.qw0000 = 0x00;
			tLoc0848.qw0018 = 0x00;
			tLoc0848.dw0000 = 0x02;
			tLoc0848.qw0008 = 0x00;
			tLoc0848.qw0010 = 0x00;
			tLoc0848.dw0004 = 0x00;
			struct Eq_n * ptrLoc0850;
			if (getaddrinfo(r13_n, null, &tLoc0848, &ptrLoc0850) != 0x00)
				strlcpy();
			else
			{
				strlcpy();
				freeaddrinfo(ptrLoc0850);
				auth_setoption();
			}
		}
		if (r2_n != 0x00)
		{
			fwrite(&g_v15030, &g_t66CC0);
			fn00004780(0x01, 0x00010000, (struct Eq_n *) 0x00020000);
		}
		syslog();
		if (r2_n != 0x00)
		{
			warnc();
			fn00004780(0x01, 0x00010000, (struct Eq_n *) 0x00020000);
		}
		g_ptr26028 = optarg;
	}
	ui32 r12_n = optind;
	ui32 r19_n = 0x01;
	union Eq_n * r3_n = (union Eq_n *) r3[r12_n];
	word32 r24_n;
	if (r3_n != null)
	{
		r24_n = r2 - r12_n;
		g_ptr26024 = r3_n;
		r19_n = 0x00;
	}
	else
		r24_n = r2 - r12_n;
	union Eq_n * r2_n = geteuid();
	if (r2_n != null)
	{
		auth_close();
		closelog();
		closefrom();
		char * ptrLoc28 = 0x00014F10;
		union Eq_n ***** r11_n;
		if (true)
			r11_n = fp - (union Eq_n *****) 0x1C;
		else
			r11_n = fp - (union Eq_n *****) 0x20;
		if (r19_n == 0x00)
		{
			*r11_n = (union Eq_n *****) g_ptr26024;
			r11_n += (union Eq_n *****) 0x04;
		}
		*r11_n = (union Eq_n *****) null;
		execv("/usr/bin/su", &ptrLoc28);
		warn();
		_exit(0x01);
	}
	ttyname();
	union Eq_n * dwLoc0878_n;
	if (r2_n != null)
	{
		dwLoc0878_n = r2_n;
		if (r2_n->u1 != 0)
		{
l00002D58:
			union Eq_n * r2_n = strrchr(dwLoc0878_n, 0x2F);
			if (r2_n != null)
			{
				g_ptr66ED8 = r2_n;
				g_ptr66ED8 = (union Eq_n *) ((char *) r2_n + 1);
			}
			else
			{
				g_ptr66ED8 = r2_n;
				g_ptr66ED8 = dwLoc0878_n;
			}
			getrlimit();
			if (false)
				syslog();
			else
			{
				setrlimit();
				if (false)
					syslog();
				else
				{
					signal(0x0E, &g_t4260);
					if (__bit<word32,byte>(cond(r24_n - 0x01), 0x01))
						alarm();
					else
					{
						signal(0x03, (void (*)(int32)) 0x01);
						signal(0x02, (void (*)(int32)) 0x01);
						signal(0x01, (void (*)(int32)) 0x01);
						setpriority();
						login_getclass();
						if (true)
						{
							g_ptr26018 = null;
							warnx();
							fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
						}
						else
						{
							g_ptr26018 = null;
							login_getcapnum();
							union Eq_n * r2_n = g_ptr26018;
							g_dw26014 = 86260;
							login_getcapstr();
							if (r2_n != null)
							{
								unsetenv();
								unsetenv();
								if (__bit<word32,byte>(cond((word32) r2_n->u1 - 0x2F), 0x00))
								{
									syslog();
									warnx();
									fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
								}
								strrchr(r2_n, 0x2F);
								auth_setstate();
								auth_call();
								struct Eq_n * r2_n = g_ptr2601C;
								auth_getstate();
								if ((r2_n & 0x07) == 0x00)
									fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
								auth_setenv();
								union Eq_n * r2_n = getenv("AUTH_TYPE");
								if (r2_n != null && strncmp(r2_n, "auth-", 0x05) == 0x00)
									dwLoc086C_n = r2_n;
								union Eq_n * r2_n = getenv("REMOTE_NAME");
								if (r2_n != null)
									g_ptr66E88 = r2_n;
								auth_clroptions();
								if (dwLoc086C_n != null)
									auth_setoption();
								if (false)
									auth_setoption();
								if (g_ptr66E88 != null)
									auth_setoption();
								if (false)
									auth_setoption();
								if (false)
									auth_setoption();
							}
							auth_setitem();
							word32 r22_n = 0x00;
							while (true)
							{
								r30_n->dw0024 = 0x00;
								auth_clean();
								auth_clroption();
								auth_clroption();
								if (r19_n != 0x00)
									break;
								if (true)
									alarm();
								struct Eq_n * r2_n = strchr(g_ptr26024, 0x3A);
								if (r2_n != null)
									r2_n->t0000.u0 = 0x00;
								if (r18_n != null)
									free(r18_n);
								struct Eq_n * r2_n = g_ptr2601C;
								auth_setitem();
								if (r2_n < null)
								{
l00003DD4:
									syslog();
									warn();
									fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
								}
								void * r2_n = strdup(g_ptr26024);
								if (r2_n == null)
									goto l00003DD4;
								r18_n = r2_n;
								ui32 r19_n = 0x00;
								struct Eq_n * r2_n = strchr(g_ptr26024, 0x2F);
								if (r2_n != null)
								{
									if (strncmp(&r2_n->b0001, "root", 0x04) == 0x00)
										r19_n = 0x01;
									r2_n->t0000.u0 = 0x00;
								}
								if (!__bit<word32,byte>(cond(strlen(g_ptr26024) - 0x20), 0x00))
									g_ptr26024->u2.b0020 = 0x00;
								if (g_dw66E8C != 0x00 && strcmp(&r30_n->dw002C + 265, g_ptr26024) != 0x00)
									;
								strlcpy();
								struct Eq_n * r2_n = getpwnam(g_ptr26024);
								if (r2_n == null)
									g_ptr66ED0 = r2_n;
								else
								{
									g_ptr66ED0 = r2_n;
									struct Eq_n * r2_n = g_ptr2601C;
									auth_setpwd();
									if (r2_n < null)
									{
										syslog();
										warn();
										fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
									}
								}
								struct Eq_n * r13_n = g_ptr66ED0;
								union Eq_n * r2_n;
								if (r13_n != null)
									r2_n = r13_n->ptr0018;
								else
									r2_n = null;
								login_getclass();
								if (r2_n != null)
								{
									g_ptr26018 = r2_n;
									login_getstyle();
									if (r2_n == null)
										goto l00003214;
									login_getcapnum();
									r30_n->dw002C = 0x0001519C;
									login_getcapnum();
									struct Eq_n * r13_n = g_ptr66ED0;
									if (r13_n != null)
									{
										if (r2_n == 0x00)
											goto l000031E0;
										if (__bit<word32,byte>(cond(r2_n - r13_n->dw0008), 0x00))
											goto l000031D8;
									}
									else
									{
l000031D8:
										r30_n->dw001C = 0x00;
									}
									r13_n = g_ptr66ED0;
l000031E0:
									r15_n = 0x000151A8;
									if (r13_n != null && r13_n->dw0008 == 0x00)
										r19_n = 0x01;
									if (r30_n->dw001C == 0x00)
									{
										union Eq_n * r2_n = g_ptr26018;
										login_getcaptime();
										if ((r2_n | 0x00014ED8) != 0x00)
										{
											r30_n->dw0024 = 0x00;
											r30_n->dw0024 = 0x01;
											auth_setoption();
										}
										r30_n->dw0024 = 0x00;
										signal(0x01, &g_t47C0);
										auth_verify();
										struct Eq_n * r2_n = g_ptr2601C;
										auth_getstate();
										if (__bit<word32,byte>(r2_n, 0x00))
										{
											r30_n->ptr0028 = r2_n;
											if (r30_n->dw0024 == 0x00)
												goto l00003D24;
											r30_n->ptr0028 = (struct Eq_n *) 0x01;
										}
										else
										{
											r30_n->ptr0028 = r2_n;
l00003D24:
											if ((r30_n->ptr0028 & 0x07) == 0x00)
											{
												r30_n->dw0024 = 0x00;
												goto l00003214;
											}
											r30_n->dw0024 = 0x00;
										}
										struct Eq_n * r2_n = g_ptr2601C;
										auth_setoption();
										if (r2_n < null)
										{
											syslog();
											warn();
											fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
										}
									}
									if (g_ptr66ED0 == null || r19_n != 0x00 && fn000040D0(g_ptr66ED8, out r30_n) == 0x00)
										goto l00003214;
									alarm();
									endpwent();
									union Eq_n * r2_n = g_ptr26018;
									login_getcapstr();
									if (r2_n->u1 != 0 && !__bit<word32,byte>(cond(strlen(r2_n) - 0x03FF), 0x0F))
									{
										syslog();
										warnx();
										fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
									}
									if (r30_n->dw0020 == 0x00)
									{
										word32 * r2_n = calloc();
										if (r2_n == null)
										{
											environ = r2_n;
											goto l00003B90;
										}
										environ = r2_n;
									}
									else
									{
										word32 * r25_n = environ;
										union Eq_n * r2_n = *r25_n;
										if (r2_n != null)
										{
											word32 * r24_n = r25_n;
											while (true)
											{
												if (strncmp(r2_n, "LD_", 0x03) != 0x00 && (strncmp(*r24_n, "ENV=", 0x04) != 0x00 && (strncmp(*r24_n, "BASH_ENV=", 0x09) != 0x00 && strncmp(*r24_n, "IFS=", 0x04) != 0x00)))
												{
													*r25_n = *r24_n;
													++r25_n;
												}
												++r24_n;
												union Eq_n * r13_n = *r24_n;
												if (r13_n == null)
													break;
												r2_n = r13_n;
											}
										}
										*r25_n = 0x00;
									}
									setenv();
									if (false)
									{
l0000343C:
										warn();
										fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
									}
									setenv();
									if (false)
										goto l0000343C;
									if (g_b66E90 == 0)
									{
										fn000046E0(g_ptr66ED8);
										strlcpy();
									}
									snprintf(&r30_n->dw002C + 0x007F, "%s/%s");
									setenv();
									if (false)
									{
l000034C8:
										warn();
										fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
									}
									setenv();
									if (false)
										goto l000034C8;
									setenv();
									if (false)
										goto l000034C8;
									setenv();
									if (false)
										goto l000034C8;
									if (g_ptr66E88 != null)
									{
										setenv();
										if (false)
										{
											warn();
											fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
										}
									}
									if (g_ptr26028 != null)
									{
										setenv();
										if (false)
										{
											warn();
											fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
										}
									}
									union Eq_n * r2_n = g_ptr26018;
									setusercontext();
									if (r2_n != null)
									{
										warn();
										fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
									}
									auth_setenv();
									if (r19_n == 0x00)
										auth_checknologin();
									setegid();
									seteuid();
									word32 r2_n = g_ptr66ED0->dw0020;
									chdir();
									if (r2_n != 0x00)
									{
										union Eq_n * r2_n = g_ptr26018;
										login_getcapbool();
										if (r2_n != null)
										{
											printf("No home directory %s!\n");
											fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
										}
										chdir();
										if (true)
											fn00004780(0x00, r19_n, (struct Eq_n *) 0x00020000);
									}
									word32 r21_n = 0x00;
									if (strcmp(g_ptr66ED0->ptr0024, &g_t14CB4) == 0x00)
									{
l00003570:
										r21_n = 0x01;
										goto l00003574;
									}
									union Eq_n * r2_n = g_ptr26018;
									login_getcapbool();
									if (r2_n != null)
										goto l00003570;
									if (access(".hushlogin", 0x00) == 0x00)
										r21_n = 0x01;
l00003574:
									seteuid();
									setegid();
									struct Eq_n * r2_n = g_ptr2601C;
									auth_getvalue();
									if (r2_n != null)
										printf("WARNING: %s\n\n");
									struct Eq_n * r2_n = g_ptr2601C;
									auth_check_expire();
									if (r2_n < null)
									{
										puts(&g_t14D98);
										fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
									}
									if (r2_n > null || r2_n == null && true)
									{
										if (r21_n != 0x00)
										{
l000035D0:
											goto l000035D4;
										}
										union Eq_n * r2_n = g_ptr26018;
										login_getcaptime();
										struct Eq_n * r13_n = cond(r2_n - r2_n);
										if (__bit<word32,byte>(r13_n, 0x00))
										{
l000039D0:
											ctime();
											printf("Warning: your account expires on %s");
										}
										if (__bit<word32,byte>(r13_n, 0x18))
											goto l000035D0;
										struct Eq_n * r13_n = cond(0x00014CDC - 85188);
										if (!__bit<word32,byte>(r13_n, 0x18))
											goto l000039D0;
									}
l000035D4:
									signal(0x01, null);
									union Eq_n * r24_n = (union Eq_n *) (&r30_n->dw002C + 0x0033);
									memset(r24_n, 0x00);
									time(&r30_n->dw002C + 0x007D);
									strncpy(&r30_n->dw002C + 53, g_ptr26024, 0x20);
									union Eq_n * r3_n = g_ptr66E88;
									if (r3_n != null)
										strncpy(&r30_n->dw002C + 61, r3_n, 0x0100);
									strncpy(r24_n, g_ptr66ED8, 0x08);
									login();
									if (r21_n == 0x00)
										fn000049A0();
									word32 r21_n = fn000042E0(r21_n, out r22_n, out r30_n);
									login_fbtab();
									getgrnam("tty") == 0x00;
									chown();
									if (r19_n != 0x00 && r30_n->dw001C == 0x00)
									{
										if (g_ptr66E88 == null)
											syslog();
										else
										{
											union Eq_n * r6_n = g_ptr26028;
											syslog();
										}
									}
									if (r21_n == 0x00)
									{
										union Eq_n * r2_n = g_ptr26018;
										login_getcapstr();
										if (r2_n != null)
											auth_cat();
										fn00004110();
									}
									signal(0x0E, null);
									signal(0x03, null);
									signal(0x01, null);
									signal(0x02, null);
									signal(0x12, (void (*)(int32)) 0x01);
									r30_n->b0450 = 0x2D;
									strrchr(r22_n, 0x2F) == null;
									strlcpy();
									if (r30_n->dw006C != 0x00 || r30_n->dw0074 != 0x00)
									{
										setrlimit();
										if (false)
											syslog();
									}
									if (r30_n->dw0024 != 0x00)
										puts(&g_t14D34);
									union Eq_n * r2_n = g_ptr26018;
									setusercontext();
									if (r2_n < null)
									{
										warn();
										fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
									}
									if (r2_n != 0x00)
									{
										printf("No home directory %s!\n");
										puts(&g_t14DD0);
										setenv();
									}
									struct Eq_n * r2_n = g_ptr2601C;
									auth_approval();
									if (r2_n == null)
									{
										struct Eq_n * r2_n = g_ptr2601C;
										auth_getstate();
										struct Eq_n * r2_n;
										if (__bit<word32,byte>(r2_n, 0x00))
											r2_n = &g_t14D98;
										else
											r2_n = &g_t14DBC;
										puts(r2_n);
										fn00004780(0x01, r19_n, (struct Eq_n *) 0x00020000);
									}
									else
									{
										closefrom();
										auth_setstate();
										auth_close();
										execlp();
										err();
									}
								}
								g_ptr26018 = r2_n;
l00003214:
								if (__bit<word32,byte>(r30_n->ptr0028, 0x02))
									fn00004780(0x00, r19_n, (struct Eq_n *) 0x00020000);
								if (r19_n != 0x00 && fn000040D0(g_ptr66ED8, out r30_n) == 0x00)
								{
									warnx();
									if (g_ptr66E88 == null)
										syslog();
									else
									{
										union Eq_n * r5_n = g_ptr26028;
										syslog();
									}
								}
								struct Eq_n * r2_n = g_ptr2601C;
								struct Eq_n * r25_n;
								if (r2_n == null)
								{
l00003234:
									r25_n = &g_t151B8;
									goto l00003238;
								}
								auth_getvalue();
								if (r2_n == null)
									goto l00003234;
								r25_n = r2_n;
l00003238:
								puts(r25_n);
								word32 r13_n = g_dw66E8C;
								if (g_ptr66ED0 != null)
								{
									g_dw66E8C = r13_n + 0x01;
									fn000047F0(g_ptr66E88, g_ptr26028, g_ptr66ED8, r30_n);
								}
								g_dw66E8C = r13_n + 0x01;
								++r22_n;
								if (!__bit<word32,byte>(cond(r22_n - r15_n), 0x1B))
								{
									if (!__bit<word32,byte>(cond(r22_n - r30_n->dw002C), 0x00))
									{
										word64 r24_r25_n;
										word32 r1_n;
										word32 r3_n;
										word32 r4_n;
										word32 r5_n;
										word32 r21_n;
										word32 r30_n;
										fn00004520(out r24_r25_n, out r1_n, out r3_n, out r4_n, out r5_n, out r21_n, out r30_n);
										fn00004740(0x01);
									}
								}
								r19_n = 0x01;
							}
							r30_n->dw001C = 0x00;
							fn00003F90(r30_n);
						}
					}
				}
			}
		}
	}
	char bLoc0448;
	snprintf(&bLoc0448, "%s??");
	dwLoc0878_n = &bLoc0448;
	goto l00002D58;
}

// 00002A90: void fn00002A90()
// Called from:
//      fn000028D0
void fn00002A90()
{
}

// 00003F90: void fn00003F90(Register (ptr32 Eq_n) r30)
// Called from:
//      fn000028D0
void fn00003F90(struct Eq_n * r30)
{
	Eq_n tLoc10;
	tLoc10.ptr0000 = r30;
	ptr32 %continuation;
	tLoc10.ptr0004 = %continuation;
	fn00003FC8(0x00010000, (struct Eq_n *) 0x00020000, (struct Eq_n *) 0x00060000, (struct Eq_n *) 0x00060000, 0x00060000, (struct Eq_n *) 0x00060000, &tLoc10);
}

// 00003FC8: Register word32 fn00003FC8(Register ui32 r19, Register (ptr32 Eq_n) r20, Register (ptr32 Eq_n) r21, Register (ptr32 Eq_n) r22, Register ui32 r23, Register (ptr32 Eq_n) r24, Register (ptr32 Eq_n) r30)
// Called from:
//      fn000028D0
//      fn00003F90
word32 fn00003FC8(ui32 r19, struct Eq_n * r20, struct Eq_n * r21, struct Eq_n * r22, ui32 r23, struct Eq_n * r24, struct Eq_n * r30)
{
l00003FC8:
	printf(r19 | 0x51F8);
	r24->ptr6D80 = r21 | 0x6D3C;
	while (r22->dw6D18 == 0x00)
	{
		int32 r13_n = (r23 | 0x6C10)->dw0004;
		ui32 r25_n;
		if (r13_n >= 0x01)
		{
			(r23 | 0x6C10)->dw0004 = r13_n - 0x01;
			byte * r13_n = g_ptr66C10;
			r25_n = (word32) *r13_n;
			g_ptr66C10 = r13_n + 1;
		}
		else
		{
			(r23 | 0x6C10)->dw0004 = r13_n - 0x01;
			__srget();
			r25_n = r23 | 0x6C10;
		}
		if (!__bit<word32,byte>(cond(r25_n - 0x0A), 0x00))
		{
			byte * r12_n = r24->ptr6D80;
			if (__bit<word32,byte>(cond(r12_n - (r21 | 0x6D3C)), 0x1E))
				goto l00003FC8;
			if (!__bit<word32,byte>(cond((word32) r21->b6D3C - 0x2D), 0x00))
			{
				*r12_n = 0x00;
				r20->dw6024 = r21 | 0x6D3C;
				r30->ptr0004();
				word32 r2_n;
				return r2_n;
			}
			else
				fwrite(&g_v15200, &g_t66CC0);
		}
		word32 r12_n = r25_n + 0x01;
		if (r12_n == 0x00)
		{
			word64 r24_r25_n;
			word32 r1_n;
			word32 r3_n;
			word32 r4_n;
			word32 r5_n;
			word32 r21_n;
			word32 r30_n;
			fn00004520(out r24_r25_n, out r1_n, out r3_n, out r4_n, out r5_n, out r21_n, out r30_n);
			fn00004780(0x00, r19, r20);
		}
		byte * r12_n = r24->ptr6D80;
		if (!__bit<word32,byte>(cond(r12_n - 0x00066D7D), 0x1F))
		{
			*r12_n = (byte) r25_n;
			r24->ptr6D80 = r12_n + 1;
		}
	}
	getc(r23 | 0x6C10);
}

// 000040D0: Register (ptr32 Eq_n) fn000040D0(Register (ptr32 Eq_n) r2, Register out (ptr32 Eq_n) r30Out)
// Called from:
//      fn000028D0
union Eq_n * fn000040D0(union Eq_n * r2, struct Eq_n & r30Out)
{
	getttynam();
	if (r2 != null)
		!__bit<word32,byte>(r2->u2.pw_gid, 0x00);
	struct Eq_n * r30_n;
	r30Out = r30_n;
	union Eq_n * r2_n;
	return r2_n;
}

// 00004110: void fn00004110()
// Called from:
//      fn000028D0
void fn00004110()
{
	union Eq_n * r2_n = g_ptr26018;
	login_getcapstr();
	Eq_n r2_n = open(r2_n, 0x00);
	if (r2_n >= 0x00)
	{
		word32 dwLoc2028 = (word32) 0x00;
		dwLoc2028 = 0x4240;
		word32 dwLoc2018;
		sigaction(0x02, &dwLoc2028, &dwLoc2018);
		int32 r2_n;
		word32 dwLoc2008;
		do
			r2_n = read(r2_n, &dwLoc2008);
		while (r2_n > 0x00 && __bit<word32,byte>(cond(write(0x01, &dwLoc2008) - r2_n), 0x1F));
		sigaction(0x02, &dwLoc2018, null);
		close(r2_n);
	}
}

void g_t4260(int32 r2) = ??/* Unexpected function type (fn void (int32)) */ ; // 00004260
// 000042E0: Register word32 fn000042E0(Register word32 r2, Register out word32 r22Out, Register out word32 r30Out)
// Called from:
//      fn000028D0
word32 fn000042E0(word32 r2, word32 & r22Out, word32 & r30Out)
{
	Eq_n r2_n = open(&g_t15268, 0x02);
	if (r2_n >= 0x00)
	{
		__muldi3();
		lseek(r2_n, 0x00);
		word32 dwLoc0118;
		char bLoc0108;
		if (r2 == 0x00)
		{
			ui32 dwLoc0114;
			if (!__bit<word32,byte>(cond(read(r2_n, &dwLoc0118) - 0x0110), 0x00) && (dwLoc0118 | dwLoc0114) != 0x00)
			{
				ctime();
				printf("Last login: %.*s ");
				printf("on %.*s");
				if (bLoc0108 != 0)
				{
					printf(" from %.*s");
					word32 r22_n;
					r22Out = r22_n;
					word32 r30_n;
					r30Out = r30_n;
					word32 r21_n;
					return r21_n;
				}
				if (__isthreaded != 0x00)
					putc(0x0A, &g_ptr66C68);
				int32 r13_n = g_dw66C70;
				if (r13_n < 0x01)
				{
					g_dw66C70 = r13_n - 0x01;
					__swbuf();
				}
				g_dw66C70 = r13_n - 0x01;
				byte * r13_n = g_ptr66C68;
				*r13_n = 0x0A;
				g_ptr66C68 = r13_n + 1;
			}
			__muldi3();
			lseek(r2_n, 0x00);
		}
		else
		{
			memset(&dwLoc0118, 0x00);
			time(&dwLoc0118);
			char bLoc0110;
			strncpy(&bLoc0110, g_ptr66ED8, 0x08);
			union Eq_n * r3_n = g_ptr66E88;
			if (r3_n != null)
				strncpy(&bLoc0108, r3_n, 0x0100);
			else
			{
				write(r2_n, &dwLoc0118);
				close(r2_n);
			}
		}
	}
}

// 00004520: Sequence word64 fn00004520(Sequence out word64 r24_r25Out, Register out word32 r1Out, Register out word32 r3Out, Register out word32 r4Out, Register out word32 r5Out, Register out word32 r21Out, Register out word32 r30Out)
// Called from:
//      fn000028D0
//      fn00004780
word64 fn00004520(word64 & r24_r25Out, word32 & r1Out, word32 & r3Out, word32 & r4Out, word32 & r5Out, word32 & r21Out, word32 & r30Out)
{
	word32 dwLoc18;
	word32 dwLoc18;
	memcpy(&dwLoc18, &g_v15340);
	word32 r5_n = g_dw66E8C;
	if (r5_n == 0x00)
	{
		r24_r25Out = <invalid>;
		word32 r1_n;
		r1Out = r1_n;
		word32 r3_n;
		r3Out = r3_n;
		word32 r4_n;
		r4Out = r4_n;
		word32 r5_n;
		r5Out = r5_n;
		word32 r21_n;
		r21Out = r21_n;
		word32 r30_n;
		r30Out = r30_n;
		word32 r22_n;
		word32 r23_n;
		return SEQ(r22_n, r23_n);
	}
	else
	{
		union Eq_n * r13_n = g_ptr66E88;
		if (r13_n == null)
		{
			struct Eq_n * r13_n = cond(r5_n - 0x01);
			syslog_r();
			word32 r5_n = g_dw66E8C;
			struct Eq_n * r13_n = cond(r5_n - 0x01);
			syslog_r();
		}
		else
		{
			struct Eq_n * r13_n = cond(r5_n - 0x01);
			union Eq_n * r7_n = g_ptr26028;
			syslog_r();
			word32 r5_n = g_dw66E8C;
			struct Eq_n * r13_n = cond(r5_n - 0x01);
			union Eq_n * r7_n = g_ptr26028;
			syslog_r();
		}
	}
}

// 000046E0: void fn000046E0(Register (ptr32 Eq_n) r2)
// Called from:
//      fn000028D0
void fn000046E0(union Eq_n * r2)
{
	if (r2 != null)
	{
		getttynam();
		if (r2 != null)
			return;
	}
	login_getcapstr();
}

// 00004740: void fn00004740(Register int32 r2)
// Called from:
//      fn000028D0
void fn00004740(int32 r2)
{
	auth_close();
	sleep(0x05);
	exit(r2);
}

// 00004780: void fn00004780(Register int32 r2, Register ui32 r19, Register (ptr32 Eq_n) r20)
// Called from:
//      fn000028D0
//      fn00004740
void fn00004780(int32 r2, ui32 r19, struct Eq_n * r20)
{
	word32 r30_n;
	word32 r21_n;
	union Eq_n * r5_n;
	union Eq_n * r4_n;
	union Eq_n * r3_n;
	word32 r1_n;
	word64 r24_r25_n;
	if (g_ptr2601C != null)
	{
		auth_close();
		if (g_ptr26024 != null)
		{
			word64 r22_r23_n = fn00004520(out r24_r25_n, out r1_n, out r3_n, out r4_n, out r5_n, out r21_n, out r30_n);
			struct Eq_n * r31_n = (struct Eq_n *) <invalid>;
			r31_n->dwFFFFFE94 = r19;
			word32 r13_n = __guard_local;
			r31_n->qwFFFFFEA8 = r24_r25_n;
			r31_n->qwFFFFFE98 = (word64) r21_n;
			r31_n->dwFFFFFEB0 = r30_n;
			r31_n->qwFFFFFEA0 = r22_r23_n;
			r31_n->dwFFFFFEB4 = r1_n;
			r31_n->dwFFFFFFF0 = r13_n;
			Eq_n r2_n = open(&g_t15350, 0x02);
			if (r2_n < 0x00)
				fn00004928();
			else
				fn00004848(r4_n, r5_n, r3_n, r2_n, r31_n - 336);
		}
		else
			_exit(0x00);
	}
	else
		exit(r2);
}

void g_t47C0(int32 r2) = ??/* Unexpected function type (fn void (int32)) */ ; // 000047C0
// 000047F0: void fn000047F0(Register (ptr32 Eq_n) r3, Register (ptr32 Eq_n) r4, Register (ptr32 Eq_n) r5, Register (ptr32 Eq_n) r30)
// Called from:
//      fn000028D0
void fn000047F0(union Eq_n * r3, union Eq_n * r4, union Eq_n * r5, struct Eq_n * r30)
{
	Eq_n tLoc0150;
	tLoc0150.ptr0000 = r30;
	ptr32 %continuation;
	tLoc0150.ptr0004 = %continuation;
	Eq_n r2_n = open(&g_t15350, 0x02);
	if (r2_n < 0x00)
		fn00004928();
	else
		fn00004848(r4, r5, r3, r2_n, &tLoc0150);
}

// 00004848: void fn00004848(Register (ptr32 Eq_n) r20, Register (ptr32 Eq_n) r21, Register (ptr32 Eq_n) r22, Register Eq_n r25, Register (ptr32 Eq_n) r30)
// Called from:
//      fn00004780
//      fn000047F0
void fn00004848(union Eq_n * r20, union Eq_n * r21, union Eq_n * r22, Eq_n r25, struct Eq_n * r30)
{
	__muldi3();
	lseek(r25, 0x00);
	if (__bit<word32,byte>(cond(read(r25, (char *) r30 + 8) - 0x0138), 0x01) || (r30->dw0130 | r30->dw0134) == 0x00)
		memset((char *) r30 + 8, 0x00);
	__muldi3();
	lseek(r25, 0x00);
	++r30->dw0138;
	time(&r30->dw0130);
	strncpy((char *) r30 + 8, r21, 0x08);
	if (r22 != null)
		strncpy(&r30->b0030, r22, 0x0100);
	else
		r30->b0030 = 0x00;
	if (r20 != null)
		strncpy(&r30->b0010, r20, 0x20);
	else
		r30->b0010 = 0x00;
	write(r25, (char *) r30 + 8);
	close(r25);
}

// 00004928: void fn00004928()
// Called from:
//      fn00004780
//      fn000047F0
void fn00004928()
{
}

// 000049A0: void fn000049A0()
// Called from:
//      fn000028D0
void fn000049A0()
{
	word32 dwLoc0148;
	memset(&dwLoc0148, 0x00);
	Eq_n r2_n = open(&g_t15350, 0x02);
	if (r2_n >= 0x00)
	{
		__muldi3();
		lseek(r2_n, 0x00);
		word32 dwLoc18;
		if (!__bit<word32,byte>(cond(read(r2_n, &dwLoc0148) - 0x0138), 0x00) && dwLoc18 != 0x00)
		{
			struct Eq_n * r13_n = cond(dwLoc18 - 0x01);
			if (!__bit<word32,byte>(r13_n, 0x02))
				printf("There have been %lu unsuccessful login attempts to your account.\n");
			else
			{
				ctime();
				printf("Last unsuccessful login: %.*s");
				printf(" on %.*s");
				int8 bLoc0120;
				if (bLoc0120 != 0)
				{
					int8 bLoc0140;
					if (bLoc0140 == 0)
						printf(" from %.*s");
					printf(" from %.*s@%.*s");
				}
				if (__isthreaded != 0x00)
					putc(0x0A, &g_ptr66C68);
				else
				{
					int32 r13_n = g_dw66C70;
					if (r13_n < 0x01)
					{
						g_dw66C70 = r13_n - 0x01;
						__swbuf();
					}
					else
					{
						g_dw66C70 = r13_n - 0x01;
						byte * r13_n = g_ptr66C68;
						*r13_n = 0x0A;
						g_ptr66C68 = r13_n + 1;
						__muldi3();
						lseek(r2_n, 0x00);
						write(r2_n, &dwLoc0148);
					}
				}
			}
		}
		else
			close(r2_n);
	}
}

